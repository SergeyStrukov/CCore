----- Basic concepts -----

translation-unit:
  declaration-seq-opt


----- Expressions -----

primary-expression:
  literal
  this
  ( expression )
  id-expression
  lambda-expression

id-expression:
  unqualified-id
  qualified-id

unqualified-id:
  identifier
  operator-function-id
  conversion-function-id
  literal-operator-id
  ~ class-name
  ~ decltype-specifier
  template-id

qualified-id:
  nested-name-specifier template-opt unqualified-id
  :: identifier
  :: operator-function-id
  :: literal-operator-id
  :: template-id

nested-name-specifier:
  ::-opt type-name ::
  ::-opt namespace-name ::
  decltype-specifier ::
  nested-name-specifier identifier ::
  nested-name-specifier template-opt simple-template-id ::

lambda-expression:
  lambda-introducer lambda-declarator-opt compound-statement

lambda-introducer:
  [ lambda-capture-opt ]

lambda-capture:
  capture-default
  capture-list
  capture-default , capture-list

capture-default:
  &
  =

capture-list:

  capture ...-opt
  capture-list , capture ...-opt

capture:
  identifier
  & identifier
  this

lambda-declarator:
  ( parameter-declaration-clause ) mutable-opt
  exception-specification-opt attribute-specifier-seq-opt trailing-return-type-opt

postfix-expression:
  primary-expression
  postfix-expression [ expression ]
  postfix-expression [ braced-init-list ]
  postfix-expression ( expression-list-opt )
  simple-type-specifier ( expression-list-opt )
  typename-specifier ( expression-list-opt )
  simple-type-specifier braced-init-list
  typename-specifier braced-init-list
  postfix-expression . template-opt id-expression
  postfix-expression -> template-opt id-expression
  postfix-expression . pseudo-destructor-name
  postfix-expression -> pseudo-destructor-name
  postfix-expression ++
  postfix-expression --
  dynamic_cast < type-id > ( expression )
  static_cast < type-id > ( expression )
  reinterpret_cast < type-id > ( expression )
  const_cast < type-id > ( expression )
  typeid ( expression )
  typeid ( type-id )

expression-list:
  initializer-list

pseudo-destructor-name:
  nested-name-specifier-opt type-name :: ~ type-name
  nested-name-specifier template simple-template-id :: ~ type-name
  nested-name-specifier-opt ~ type-name
  ~ decltype-specifier

unary-expression:
  postfix-expression
  ++ cast-expression
  -- cast-expression
  unary-operator cast-expression
  sizeof unary-expression
  sizeof ( type-id )
  sizeof ... ( identifier )
  alignof ( type-id )
  noexcept-expression
  new-expression
  delete-expression

unary-operator: 
  * 
  & 
  + 
  - 
  ! 
  ~

new-expression:
  ::-opt new new-placement-opt new-type-id new-initializer-opt
  ::-opt new new-placement-opt ( type-id ) new-initializer-opt

new-placement:
  ( expression-list )

new-type-id:
  type-specifier-seq new-declarator-opt

new-declarator:
  ptr-operator new-declarator-opt
  noptr-new-declarator

noptr-new-declarator:
  [ expression ] attribute-specifier-seq-opt
  noptr-new-declarator [ constant-expression ] attribute-specifier-seq-opt

new-initializer:
  ( expression-list-opt )
  braced-init-list

delete-expression:
  ::-opt delete cast-expression
  ::-opt delete [ ] cast-expression

noexcept-expression:
  noexcept ( expression )

cast-expression:
  unary-expression
  ( type-id ) cast-expression

pm-expression:
  cast-expression
  pm-expression .* cast-expression
  pm-expression ->* cast-expression

multiplicative-expression:
  pm-expression
  multiplicative-expression * pm-expression
  multiplicative-expression / pm-expression
  multiplicative-expression % pm-expression

additive-expression:
  multiplicative-expression
  additive-expression + multiplicative-expression
  additive-expression - multiplicative-expression

shift-expression:
  additive-expression
  shift-expression << additive-expression
  shift-expression >> additive-expression

relational-expression:
  shift-expression
  relational-expression < shift-expression
  relational-expression > shift-expression
  relational-expression <= shift-expression
  relational-expression >= shift-expression

equality-expression:
  relational-expression
  equality-expression == relational-expression
  equality-expression != relational-expression

and-expression:
  equality-expression
  and-expression & equality-expression

exclusive-or-expression:
  and-expression
  exclusive-or-expression ^ and-expression

inclusive-or-expression:
  exclusive-or-expression
  inclusive-or-expression | exclusive-or-expression

logical-and-expression:
  inclusive-or-expression
  logical-and-expression && inclusive-or-expression

logical-or-expression:
  logical-and-expression
  logical-or-expression || logical-and-expression

conditional-expression:
  logical-or-expression
  logical-or-expression ? expression : assignment-expression

assignment-expression:
  conditional-expression
  logical-or-expression assignment-operator initializer-clause
  throw-expression

assignment-operator:
  = 
  *= 
  /= 
  %= 
  += 
  -= 
  >>= 
  <<= 
  &= 
  ^= 
  |=

expression:
  assignment-expression
  expression , assignment-expression

constant-expression:
  conditional-expression


----- Statements -----

statement:
  labeled-statement
  attribute-specifier-seq-opt expression-statement
  attribute-specifier-seq-opt compound-statement
  attribute-specifier-seq-opt selection-statement
  attribute-specifier-seq-opt iteration-statement
  attribute-specifier-seq-opt jump-statement
  declaration-statement
  attribute-specifier-seq-opt try-block

labeled-statement:
  attribute-specifier-seq-opt identifier : statement
  attribute-specifier-seq-opt case constant-expression : statement
  attribute-specifier-seq-opt default : statement

expression-statement:
  expression-opt;

compound-statement:
  { statement-seq-opt }

statement-seq:
  statement
  statement-seq statement

selection-statement:
  if ( condition ) statement
  if ( condition ) statement else statement
  switch ( condition ) statement

condition:
  expression
  attribute-specifier-seq-opt decl-specifier-seq declarator = initializer-clause
  attribute-specifier-seq-opt decl-specifier-seq declarator braced-init-list

iteration-statement:
  while ( condition ) statement
  do statement while ( expression ) ;
  for ( for-init-statement condition-opt ; expression-opt ) statement
  for ( for-range-declaration : for-range-initializer ) statement

for-init-statement:
  expression-statement
  simple-declaration

for-range-declaration:
  attribute-specifier-seq-opt decl-specifier-seq declarator

for-range-initializer:
  expression
  braced-init-list

jump-statement:
  break ;
  continue ;
  return expression-opt ;
  return braced-init-list ;
  goto identifier ;

declaration-statement:
  block-declaration


----- Declarations -----

declaration-seq:
  declaration
  declaration-seq declaration

declaration:
  block-declaration
  function-definition
  template-declaration
  explicit-instantiation
  explicit-specialization
  linkage-specification
  namespace-definition
  empty-declaration
  attribute-declaration

block-declaration:
  simple-declaration
  asm-definition
  namespace-alias-definition
  using-declaration
  using-directive
  static_assert-declaration
  alias-declaration
  opaque-enum-declaration

alias-declaration:
  using identifier attribute-specifier-seq-opt = type-id ;

simple-declaration:
  decl-specifier-seq-opt init-declarator-list-opt ;
  attribute-specifier-seq decl-specifier-seq-opt init-declarator-list ;

static_assert-declaration:
  static_assert ( constant-expression , string-literal ) ;

empty-declaration:
  ;

attribute-declaration:
  attribute-specifier-seq ;

decl-specifier:
  storage-class-specifier
  type-specifier
  function-specifier
  friend
  typedef
  constexpr

decl-specifier-seq:
  decl-specifier attribute-specifier-seq-opt
  decl-specifier decl-specifier-seq

storage-class-specifier:
  register
  static
  thread_local
  extern
  mutable

function-specifier:
  inline
  virtual
  explicit

typedef-name:
  identifier

type-specifier:
  trailing-type-specifier
  class-specifier
  enum-specifier

trailing-type-specifier:
  simple-type-specifier
  elaborated-type-specifier
  typename-specifier
  cv-qualifier

type-specifier-seq:
  type-specifier attribute-specifier-seq-opt
  type-specifier type-specifier-seq

trailing-type-specifier-seq:
  trailing-type-specifier attribute-specifier-seq-opt
  trailing-type-specifier trailing-type-specifier-seq

simple-type-specifier:
  nested-name-specifier-opt type-name
  nested-name-specifier template simple-template-id
  char
  char16_t
  char32_t
  wchar_t
  bool
  short
  int
  long
  signed
  unsigned
  float
  double
  void
  auto
  decltype-specifier

type-name:
  class-name
  enum-name
  typedef-name
  simple-template-id

decltype-specifier:
  decltype ( expression )

elaborated-type-specifier:
  class-key attribute-specifier-seq-opt nested-name-specifier-opt identifier
  class-key nested-name-specifier-opt template-opt simple-template-id
  enum nested-name-specifier-opt identifier

enum-name:
  identifier

enum-specifier:
  enum-head { enumerator-list-opt }
  enum-head { enumerator-list , }

enum-head:
  enum-key attribute-specifier-seq-opt identifier-opt enum-base-opt
  enum-key attribute-specifier-seq-opt nested-name-specifier identifier enum-base-opt

opaque-enum-declaration:
  enum-key attribute-specifier-seq-opt identifier enum-base-opt ;

enum-key:
  enum
  enum class
  enum struct

enum-base:
  : type-specifier-seq

enumerator-list:
  enumerator-definition
  enumerator-list , enumerator-definition

enumerator-definition:
  enumerator
  enumerator = constant-expression

enumerator:
  identifier

namespace-name:
  original-namespace-name
  namespace-alias

original-namespace-name:
  identifier

namespace-definition:
  named-namespace-definition
  unnamed-namespace-definition

named-namespace-definition:
  original-namespace-definition
  extension-namespace-definition

original-namespace-definition:
  inline-opt namespace identifier { namespace-body }

extension-namespace-definition:
  inline-opt namespace original-namespace-name { namespace-body }

unnamed-namespace-definition:
  inline-opt namespace { namespace-body }

namespace-body:
  declaration-seq-opt

namespace-alias:
  identifier

namespace-alias-definition:
  namespace identifier = qualified-namespace-specifier ;

qualified-namespace-specifier:
  nested-name-specifier-opt namespace-name

using-declaration:
  using typename-opt nested-name-specifier unqualified-id ;
  using :: unqualified-id ;

using-directive:
  attribute-specifier-seq-opt using namespace nested-name-specifier-opt namespace-name ;

asm-definition:
  asm ( string-literal ) ;

linkage-specification:
  extern string-literal { declaration-seq-opt }
  extern string-literal declaration

----- Attributes -----

attribute-specifier-seq:
  attribute-specifier-seq-opt attribute-specifier

attribute-specifier:
  [ [ attribute-list ] ]
  alignment-specifier

alignment-specifier:
  alignas ( type-id ...-opt )
  alignas ( assignment-expression ...-opt )

attribute-list:
  attribute-opt
  attribute-list , attribute-opt
  attribute ...
  attribute-list , attribute ...

attribute:
  attribute-token attribute-argument-clause-opt

attribute-token:
  identifier
  attribute-scoped-token

attribute-scoped-token:
  attribute-namespace :: identifier

attribute-namespace:
  identifier

attribute-argument-clause:
  ( balanced-token-seq )

balanced-token-seq:
  balanced-token-opt
  balanced-token-seq balanced-token

balanced-token:
  ( balanced-token-seq )
  [ balanced-token-seq ]
  { balanced-token-seq }
  any token other than a parenthesis, a bracket, or a brace


----- Declarators -----

init-declarator-list:
  init-declarator
  init-declarator-list , init-declarator

init-declarator:
  declarator initializer-opt

declarator:
  ptr-declarator
  noptr-declarator parameters-and-qualifiers trailing-return-type

ptr-declarator:
  noptr-declarator
  ptr-operator ptr-declarator

noptr-declarator:
  declarator-id attribute-specifier-seq-opt
  noptr-declarator parameters-and-qualifiers
  noptr-declarator [ constant-expression-opt ] attribute-specifier-seq-opt
  ( ptr-declarator )

parameters-and-qualifiers:
  ( parameter-declaration-clause ) attribute-specifier-seq-opt cv-qualifier-seq-opt ref-qualifier-opt exception-specification-opt

trailing-return-type:
  -> trailing-type-specifier-seq abstract-declarator-opt

ptr-operator:
  * attribute-specifier-seq-opt cv-qualifier-seq-opt
  & attribute-specifier-seq-opt
  && attribute-specifier-seq-opt
  nested-name-specifier * attribute-specifier-seq-opt cv-qualifier-seq-opt

cv-qualifier-seq:
  cv-qualifier cv-qualifier-seq-opt

cv-qualifier:
  const
  volatile

ref-qualifier:
  &
  &&

declarator-id:
  ...-opt id-expression
  nested-name-specifier-opt class-name

type-id:
  type-specifier-seq abstract-declarator-opt

abstract-declarator:
  ptr-abstract-declarator
  noptr-abstract-declarator-opt parameters-and-qualifiers trailing-return-type
  abstract-pack-declarator

ptr-abstract-declarator:
  noptr-abstract-declarator
  ptr-operator ptr-abstract-declarator-opt

noptr-abstract-declarator:
  noptr-abstract-declarator-opt parameters-and-qualifiers
  noptr-abstract-declarator-opt [ constant-expression-opt ] attribute-specifier-seq-opt
  ( ptr-abstract-declarator )

abstract-pack-declarator:
  noptr-abstract-pack-declarator
  ptr-operator abstract-pack-declarator

noptr-abstract-pack-declarator:
  noptr-abstract-pack-declarator parameters-and-qualifiers
  noptr-abstract-pack-declarator [ constant-expression-opt ] attribute-specifier-seq-opt
  ...

parameter-declaration-clause:
  parameter-declaration-list-opt ...-opt
  parameter-declaration-list , ...

parameter-declaration-list:
  parameter-declaration
  parameter-declaration-list , parameter-declaration

parameter-declaration:
  attribute-specifier-seq-opt decl-specifier-seq declarator
  attribute-specifier-seq-opt decl-specifier-seq declarator = initializer-clause
  attribute-specifier-seq-opt decl-specifier-seq abstract-declarator-opt
  attribute-specifier-seq-opt decl-specifier-seq abstract-declarator-opt = initializer-clause

function-definition:
  attribute-specifier-seq-opt decl-specifier-seq-opt declarator virt-specifier-seq-opt function-body

function-body:
  ctor-initializer-opt compound-statement
  function-try-block
  = default ;
  = delete ;

initializer:
  brace-or-equal-initializer
  ( expression-list )

brace-or-equal-initializer:
  = initializer-clause
  braced-init-list

initializer-clause:
  assignment-expression
  braced-init-list

initializer-list:
  initializer-clause ...-opt
  initializer-list , initializer-clause ...-opt

braced-init-list:
  { initializer-list ,-opt }
  { }


----- Classes -----

class-name:
  identifier
  simple-template-id

class-specifier:
  class-head { member-specification-opt }

class-head:
  class-key attribute-specifier-seq-opt class-head-name class-virt-specifier-opt base-clause-opt
  class-key attribute-specifier-seq-opt base-clause-opt

class-head-name:
  nested-name-specifier-opt class-name

class-virt-specifier:
  final

class-key:
  class
  struct
  union

member-specification:
  member-declaration member-specification-opt
  access-specifier : member-specification-opt

member-declaration:
  attribute-specifier-seq-opt decl-specifier-seq-opt member-declarator-list-opt ;
  function-definition ;-opt
  using-declaration
  static_assert-declaration
  template-declaration
  alias-declaration

member-declarator-list:
  member-declarator
  member-declarator-list , member-declarator

member-declarator:
  declarator virt-specifier-seq-opt pure-specifier-opt
  declarator brace-or-equal-initializer-opt
  identifier-opt attribute-specifier-seq-opt : constant-expression

virt-specifier-seq:
  virt-specifier
  virt-specifier-seq virt-specifier

virt-specifier:
  override
  final

pure-specifier:
  = 0


----- Derived classes -----

base-clause:
  : base-specifier-list

base-specifier-list:
  base-specifier ...-opt
  base-specifier-list , base-specifier ...-opt

base-specifier:
  attribute-specifier-seq-opt base-type-specifier
  attribute-specifier-seq-opt virtual access-specifier-opt base-type-specifier
  attribute-specifier-seq-opt access-specifier virtual-opt base-type-specifier

class-or-decltype:
  nested-name-specifier-opt class-name
  decltype-specifier

base-type-specifier:
  class-or-decltype

access-specifier:
  private
  protected
  public


----- Special member functions -----

conversion-function-id:
  operator conversion-type-id

conversion-type-id:
  type-specifier-seq conversion-declarator-opt

conversion-declarator:
  ptr-operator conversion-declarator-opt

ctor-initializer:
  : mem-initializer-list

mem-initializer-list:
  mem-initializer ...-opt
  mem-initializer , mem-initializer-list ...-opt

mem-initializer:
  mem-initializer-id ( expression-list-opt )
  mem-initializer-id braced-init-list

mem-initializer-id:
  class-or-decltype
  identifier


----- Overloading -----

operator-function-id:
  operator operator

operator:
  new 
  delete 
  new [ ] 
  delete [ ]
  + 
  - 
  * 
  / 
  % 
  ^ 
  & 
  | 
  ~
  ! 
  = 
  < 
  > 
  += 
  -= 
  *= 
  /= 
  %=
  ^= 
  &= 
  |= 
  << 
  >> 
  >>= 
  <<= 
  == 
  !=
  <= 
  >= 
  && 
  || 
  ++ 
  -- 
  , 
  ->* 
  ->
  ( ) 
  [ ]

literal-operator-id:
  operator "" identifier


----- Templates -----

template-declaration:
  template < template-parameter-list > declaration

template-parameter-list:
  template-parameter
  template-parameter-list , template-parameter

template-parameter:
  type-parameter
  parameter-declaration

type-parameter:
  class ...-opt identifier-opt
  class identifier-opt = type-id
  typename ...-opt identifier-opt
  typename identifier-opt= type-id
  template < template-parameter-list > class ...-opt identifier-opt
  template < template-parameter-list > class identifier-opt= id-expression

simple-template-id:
  template-name < template-argument-list-opt >

template-id:
  simple-template-id
  operator-function-id < template-argument-list-opt >
  literal-operator-id < template-argument-list-opt >

template-name:
  identifier

template-argument-list:
  template-argument ...-opt
  template-argument-list , template-argument ...-opt

template-argument:
  constant-expression
  type-id
  id-expression

typename-specifier:
  typename nested-name-specifier identifier
  typename nested-name-specifier template-opt simple-template-id

explicit-instantiation:
  extern-opt template declaration

explicit-specialization:
  template < > declaration


----- Exception handling -----

try-block:
  try compound-statement handler-seq

function-try-block:
  try ctor-initializer-opt compound-statement handler-seq

handler-seq:
  handler handler-seq-opt

handler:
  catch ( exception-declaration ) compound-statement

exception-declaration:
  attribute-specifier-seq-opt type-specifier-seq declarator
  attribute-specifier-seq-opt type-specifier-seq abstract-declarator-opt
  ...

throw-expression:
  throw assignment-expression-opt

exception-specification:
  dynamic-exception-specification
  noexcept-specification

dynamic-exception-specification:
  throw ( type-id-list-opt )

type-id-list:
  type-id ...-opt
  type-id-list , type-id ...-opt

noexcept-specification:
  noexcept ( constant-expression )
  noexcept


----------
