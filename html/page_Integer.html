<!--
/* page_Integer.html */
//----------------------------------------------------------------------------------------
//
//  Project: CCore 1.08
//
//  License: Boost Software License - Version 1.0 - August 17th, 2003 
//
//            see http://www.boost.org/LICENSE_1_0.txt or the local copy
//
//  Copyright (c) 2014 Sergey Strukov. All rights reserved.
//
//----------------------------------------------------------------------------------------
-->

<!DOCTYPE html>
<html>

<head>

 <title>CCore -> Integer</title>

 <link href="CCore.css" rel="stylesheet" type="text/css">

</head>

<body>

<h2>Integer</h2>

<p class="Files">Files <b>CCore/inc/math/Integer.h</b> <b>CCore/src/math/Integer.cpp</b></p>

<p>
<b>Integer</b> is a class, which simulates integer numbers. It can represent numbers from a
huge value range. This range is limited only by the available memory.
</p>

<p>
Internally an <b>Integer</b> value is represented using the array of units. A unit has an unsigned integral type.
The 2'c lendian reprsentation is used. I.e. if the array is <b>(U<sub>0</sub>,...,U<sub>n</sub>)</b>, then the 
value is <b>U<sub>0</sub>+U<sub>1</sub>*B+...+U<sub>n-1</sub>*B<sup>n-1</sup>+2c-signed(U<sub>n</sub>)*B<sup>n</sup></b>,
where <b>B</b> is <b>2<sup>number of unit bits</sup></b>. In other words, the binary representation of the value
is the concatenation of the binary representations of units and the <b>MSB</b> is a signed bit. You may also 
consider units as digits in the base-<b>B</b> positional integer representation. 
All units except the most significant (which is the last in the array) have values from the interval <b>[0,B)</b>,
and the <b>MSU</b> is regarded as a value from the interval <b>[-B/2,B/2)</b>.
</p>
<p>
An <b>Integer</b> value is stored in the normalized form, i.e. you cannot represent it with a less number of units.
It means that the <b>MSU</b> is not a signed extension of the previous unit. 
The null value is represented by the empty array.
</p>

<pre>

template &lt;class Algo,
          template &lt;class T,class A&gt; class ArrayType = RefArray ,
          template &lt;class T,class F=NoThrowFlags&lt;T&gt; &gt; class ArrayAlgoType = ArrayAlgo &gt;
class <span class="Att">Integer</span>
 {
  public:
   
   typedef Algo AlgoType;
   
   typedef typename Algo::Unit Unit;
   
   static const unsigned UnitBits = Algo::UnitBits ;
   
   using TempArrayType = <span class="Att">DynArray&lt;Unit,ArrayAlgoType&lt;Unit&gt; &gt;</span> ;
   
  private: 
   
   <span class="Att">ArrayType&lt;Unit,ArrayAlgoType&lt;Unit&gt; &gt;</span> body;

</pre>

<p>
<b>Integer</b> is a template. The first and most important template parameter is an <b>Algorithm package</b>.
This parameter determines the unit type and the set of low-level functions to perform the integer operations. 
These functions cannot be implemented efficiently in general, so you should use some "fast" implementation
for your particular target CPU. For example, you can use the <a href="https://gmplib.org">GMP library</a> for that purpose.
</p>

<p>
The second and third template parameters define the array to be used to store an integer body. The second
must be either the <b>RefArray</b>(default) or the <b>AtomicRefArray</b>. The third should almost never be used
with non-default value. You can use a non-default value for this parameter to employ, for example, custom memory allocation 
functions. See the <a href="page_Arrays.html">Array page</a> for more information about arrays and array algorithms.
</p>

<p>
<b>AlgoType</b> is the inner type, an alias of the first template parameter.
</p>

<p>
<b>Unit</b> is the unit type.
</p>

<p>
<b>UnitBits</b> is the number of unit bits.
</p>

<p>
<b>TempArrayType</b> is a <b>Unit</b> <b>DynArray</b> with the provided array algorithm package. This type
is intended to be used as the temporary storage type.
</p>

<p>
The body of the <b>Integer</b> is stored in the private field <b>body</b>.
</p>

<pre>

  public:
   
   // generic constructor 

   template &lt;class Builder&gt;
   Integer(DoBuildType,Builder builder) : body(DoBuild,builder) { normalize(); }
   
   // constructors 
  
   Integer() {}
   
   Integer(StrLen str);
   
   template &lt;class UInt&gt;
   Integer(UInt val);
   
   template &lt;class SInt&gt;
   Integer(SInt val);
   
   ~Integer() {}

</pre>

<p>
You can create an <b>Integer</b> using the generic constructor or using special constructors.
The generic constructor uses the provided builder to fill the integer body 
and then performs the normalization. 
</p>

<p>
The default constructor creates the null value. It doesn't throw.
</p>

<p>
You can create an <b>Integer</b> from a string (the usual decimal representation is assumed) or from
any "short" integer, signed or unsigned. These constructors are implicit, so you can use them to 
silently cast operation arguments.
</p>

<pre>

   // methods
   
   CmpResult sign() const;
   
   bool operator ! () const { return !sign(); }
   
   struct BitsOf
    {
     ulen units;
     unsigned msbits;
     
     BitsOf(ulen units_,unsigned msbits_) : units(units_),msbits(msbits_) {}
     
     template &lt;class UInt&gt;
     void total(UInt &amp;ret) const;
     
     unsigned total() const;
    };
   
   BitsOf bitsOf() const;
   
   Integer sq() const;
   
   Integer pow(unsigned deg) const;
   
   void modify() { body.modify(); }
   
   void cloneTo(Integer &amp;ret) const;
   
   Integer &amp; set_null();
   
   PtrLen&lt;const Unit&gt; getBody() const;
   
   PtrLenReverse&lt;const Unit&gt; getBodyReverse() const;
   
   bool isOdd() const;
   
   bool isEven() const;

</pre>

<p>
<b>sign()</b> returns the sign of the number, represented using the <a href="page_Cmp.html"><b>CmpResult</b></a>.
</p>

<p>
<b>operator !</b> returns <b>true</b>, if the number is zero.
</p>

<p>
<b>bitsOf()</b> returns the number of bits of the number. The value is returned as a structure with two fields.
The fields <b>units</b> is the number of full unit bits. The field <b>msbits</b> is the number of bits of the <b>MSU</b>.
You can convert this result into a usual unsigned value using the method <b>total()</b>.
The <b>total()</b> without arguments returns the unsigned value. The <b>total()</b> with argument
returns the value of a desired type in the given argument. An exception is thrown in case of overflow.
For negative numbers the leading 1 is not counted. I.e. is the number <b>N</b> is non-negative, 
then <b>NBits</b> is the minimum such that <b>N&lt;2<sup>NBits</sup></b>. But if the <b>N</b> is negative, 
then <b>NBits</b> is the minimum such that <b>N&gt;=-2<sup>NBits</sup></b>.
</p>

<p>
<b>sq()</b> returns the square of the number.
</p>

<p>
<b>pow()</b> returns the power of the number.
</p>

<p>
<b>modify()</b> "unshares" the body. After this method the number will have the separate body.
</p>

<p>
<b>cloneTo()</b> makes clone of the number at the given argument. The argument will have the separate
body. This method is usefull in multi-task situations.
</p>

<p>
<b>set_null()</b> sets the number to zero and returns the reference to self.
</p>

<p>
<b>getBody()</b> returns the range over the number body.
</p>

<p>
<b>getBodyReverse()</b> returns the reverse range over the number body.
</p>

<p>
<b>isOdd()</b> returns <b>true</b>, if the number is odd.
</p>

<p>
<b>isEven()</b> returns <b>true</b>, if the number is even.
</p>

<pre>

   // cast
   
   template &lt;class UInt&gt;
   UInt cast() const;

</pre>

<p>
<b>cast()</b> does the cast to the given unsigned integral type. The reduction by module is performed 
to get the value. On bit patterns: extra bits are skipped.
</p>

<pre>

   CmpResult objCmp(const Integer &amp;b) const;

</pre>

<p>
<b>objCmp()</b> performs <a href="page_Cmp.html">the 3-way comparision</a> with the argument. 
</p>

<pre>

   // operators
   
   static Integer Neg(PtrLen&lt;const Unit&gt; a);
   
   static Integer Add(PtrLen&lt;const Unit&gt; a,PtrLen&lt;const Unit&gt; b);
   
   static Integer Sub(PtrLen&lt;const Unit&gt; a,PtrLen&lt;const Unit&gt; b);
   
   static Integer Mul(PtrLen&lt;const Unit&gt; a,PtrLen&lt;const Unit&gt; b);
   
   static Integer Sq(PtrLen&lt;const Unit&gt; a);
   
   static Integer Div(PtrLen&lt;const Unit&gt; a,PtrLen&lt;const Unit&gt; b);
   
   static Integer Mod(PtrLen&lt;const Unit&gt; a,PtrLen&lt;const Unit&gt; b);
   
   static Integer LShift(PtrLen&lt;const Unit&gt; a,unsigned shift);
   
   static Integer RShift(PtrLen&lt;const Unit&gt; a,unsigned shift);
   
   struct DivMod
    {
     Integer div;
     Integer mod;
     
     DivMod(PtrLen&lt;const Unit&gt; a,PtrLen&lt;const Unit&gt; b);
    };

</pre>

<p>
This set of static functions makes the result of operation on numbers. The argument(s) is given not 
as an <b>Integer</b> value, but as the range of a number body.
</p>

<p>
<b>Neg()</b> calculates <b>-a</b>.
</p>

<p>
<b>Add()</b> calculates <b>a+b</b>.
</p>

<p>
<b>Sub()</b> calculates <b>a-b</b>.
</p>

<p>
<b>Mul()</b> calculates <b>a*b</b>.
</p>

<p>
<b>Div()</b> calculates <b>a/b</b>. More precisely, the result is <b>[a/b]</b>.
</p>

<p>
<b>Mod()</b> calculates <b>a%b</b>. Both division operations throw an exception if the divisor is zero.
The following is true: <b>a == (a/b)*b + (a%b)</b>. If the <b>b</b> is positive, the remainder is non-negative. 
Otherwise it is non-positive. 
</p>

<p>
<b>LShift()</b> calculates <b>a&lt;&lt;shift</b>. In other words, it calculates <b>a*2<sup>shift</sup></b>.
</p>

<p>
<b>RShift()</b> calculates the arithmetic <b>a&gt;&gt;shift</b>, i.e. the leading bit is propagated.
In other words, it calculates <b>a/2<sup>shift</sup></b>.
</p>

<p>
<b>DivMod</b> is a <b>Class-function</b>, it calcualtes the qoutient (in the field <b>div</b>) 
and the remainder (in the field <b>mod</b>) simultaneously.
</p>                                    

<pre>

   // operators
   
   Integer &amp; neg();
   
   Integer &amp; revsub(const Integer &amp;b);
   
   Integer &amp; operator += (const Integer &amp;b);
   
   Integer &amp; operator -= (const Integer &amp;b);
   
   Integer &amp; operator *= (const Integer &amp;b);
   
   Integer &amp; operator /= (const Integer &amp;b);
   
   Integer &amp; operator %= (const Integer &amp;b);
   
   Integer &amp; operator &lt;&lt;= (unsigned shift);
   
   Integer &amp; operator &gt;&gt;= (unsigned shift);

</pre>

<p>
This set of methods and operators perform self-modifying operations. They return the reference to self.
</p>

<p>
<b>neg()</b> negates the number: <b>obj = - obj</b>.
</p>

<p>
<b>revsub()</b> does the "reversed subtraction", i.e. <b>obj = b - obj</b>. 
</p>

<p>
<b>operator X=</b> does the usual <b>obj = obj X b</b> operation.
</p>

<pre>

   // operators
   
   Integer operator - () const; 
   
   friend Integer operator + (const Integer &amp;a,const Integer &amp;b);
    
   friend Integer operator - (const Integer &amp;a,const Integer &amp;b);
   
   friend Integer operator * (const Integer &amp;a,const Integer &amp;b);
   
   friend Integer operator / (const Integer &amp;a,const Integer &amp;b);
   
   friend Integer operator % (const Integer &amp;a,const Integer &amp;b);
   
   Integer operator &lt;&lt; (unsigned shift) const;
   
   Integer operator &gt;&gt; (unsigned shift) const;
   
   DivMod divmod(const Integer &amp;b) const;
   
   friend bool operator == (const Integer &amp;a,const Integer &amp;b);
   
   friend bool operator != (const Integer &amp;a,const Integer &amp;b);
   
   friend bool operator &lt; (const Integer &amp;a,const Integer &amp;b);
   
   friend bool operator &gt; (const Integer &amp;a,const Integer &amp;b);
   
   friend bool operator &lt;= (const Integer &amp;a,const Integer &amp;b);
   
   friend bool operator &gt;= (const Integer &amp;a,const Integer &amp;b);

</pre>

<p>
The unary <b>operator -</b> returns the negated number: <b>-obj</b>.
</p>

<p>
The family of binary operators: <b>+, -, *, /, %</b>, perform the usual integer arithmetic operations. 
</p>

<p>
The family of binary comparision operators: <b>==, !=, &lt;, &gt;, &lt;=, &gt;=</b>, perform 
the usual integer comparision operations.
</p>

<p>
<b>operator &lt;&lt;</b> returns the <b>obj &lt;&lt; shift</b>.
</p>

<p>
<b>operator &gt;&gt;</b> returns the <b>obj &gt;&gt; shift</b>.
</p>

<p>
<b>divmod()</b> returns the the qoutient and the remainder using the <b>DivMod</b> structure.
</p>

<pre>

   template &lt;class SUInt&gt;
   Integer &amp; revsub(SUInt val);
   
   template &lt;class SUInt&gt;
   Integer &amp; operator += (SUInt val);
   
   template &lt;class SUInt&gt;
   Integer &amp; operator -= (SUInt val);
   
   template &lt;class SUInt&gt;
   Integer &amp; operator *= (SUInt val);
   
   template &lt;class SUInt&gt;
   Integer &amp; operator /= (SUInt val);
   
   template &lt;class SUInt&gt;
   Integer &amp; operator %= (SUInt val);
   
   template &lt;class SUInt&gt;
   friend Integer operator + (const Integer &amp;a,SUInt b);
   
   template &lt;class SUInt&gt;
   friend Integer operator + (SUInt a,const Integer &amp;b);
   
   template &lt;class SUInt&gt;
   friend Integer operator - (const Integer &amp;a,SUInt b);
   
   template &lt;class SUInt&gt;
   friend Integer operator - (SUInt a,const Integer &amp;b);
   
   template &lt;class SUInt&gt;
   friend Integer operator * (const Integer &amp;a,SUInt b);
   
   template &lt;class SUInt&gt;
   friend Integer operator * (SUInt a,const Integer &amp;b);
   
   template &lt;class SUInt&gt;
   friend Integer operator / (const Integer &amp;a,SUInt b);
   
   template &lt;class SUInt&gt;
   friend Integer operator / (SUInt a,const Integer &amp;b);
   
   template &lt;class SUInt&gt;
   friend Integer operator % (const Integer &amp;a,SUInt b);
   
   template &lt;class SUInt&gt;
   friend Integer operator % (SUInt a,const Integer &amp;b);
   
   template &lt;class SUInt&gt;
   DivMod divmod(SUInt b) const;
   
   template &lt;class SUInt&gt;
   CmpResult cmp(SUInt b) const;
   
   template &lt;class SUInt&gt;
   friend bool operator == (const Integer &amp;a,SUInt b);
   
   template &lt;class SUInt&gt;
   friend bool operator == (SUInt a,const Integer &amp;b);
   
   template &lt;class SUInt&gt;
   friend bool operator != (const Integer &amp;a,SUInt b);
   
   template &lt;class SUInt&gt;
   friend bool operator != (SUInt a,const Integer &amp;b);
   
   template &lt;class SUInt&gt;
   friend bool operator &lt; (const Integer &amp;a,SUInt b);
   
   template &lt;class SUInt&gt;
   friend bool operator &lt; (SUInt a,const Integer &amp;b);
   
   template &lt;class SUInt&gt;
   friend bool operator &gt; (const Integer &amp;a,SUInt b);
   
   template &lt;class SUInt&gt;
   friend bool operator &gt; (SUInt a,const Integer &amp;b);
   
   template &lt;class SUInt&gt;
   friend bool operator &lt;= (const Integer &amp;a,SUInt b);
   
   template &lt;class SUInt&gt;
   friend bool operator &lt;= (SUInt a,const Integer &amp;b);
   
   template &lt;class SUInt&gt;
   friend bool operator &gt;= (const Integer &amp;a,SUInt b);
   
   template &lt;class SUInt&gt;
   friend bool operator &gt;= (SUInt a,const Integer &amp;b);

</pre>

<p>
This set of operators and methods handles the mixed-type cases, when one of the argument is a simple 
signed or unsigned integral type. They are introduced for efficiency reason.
</p>

<p>
<b>cmp()</b> performs the comparison with one of simple signed or unsigned integral type.
</p>

<pre>

   // print object

   typedef IntegerPrintOpt PrintOptType; 
   
   template &lt;class P&gt;   
   void print(P &amp;out,PrintOptType opt) const;
   
   // swap/move objects
   
   void objSwap(Integer &amp;obj); 
   
   explicit Integer(ToMoveCtor&lt;Integer&gt; obj);
   
   Integer * objMove(Place&lt;void&gt; place);
   
   // no-throw flags
   
   enum NoThrowFlagType
    {
     Default_no_throw = true,
     Copy_no_throw = true
    };
 };

</pre>

<p>
<b>Integer</b> is printable, swappable and movable type. <b>Integer</b> print options are: output width
and show-sign option. The output is always decimal.
</p>

<pre>

struct <span class="Att">IntegerPrintOpt</span>
 {
  ulen width;
  IntShowSign show_sign;
  
  void setDefault();
  
  IntegerPrintOpt() { setDefault(); }
  
  IntegerPrintOpt(const char *ptr,const char *lim);
  
  //
  // [+][width=0]
  //
 };

</pre>

<h3>RandomInteger</h3>

<h3>GCDAlgo</h3>

<h3>Algo</h3>

</body>

</html>

