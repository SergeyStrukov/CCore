<!--
/* page_ParserGen.html */
//----------------------------------------------------------------------------------------
//
//  Project: CCore 1.02
//
//  License: Boost Software License - Version 1.0 - August 17th, 2003 
//
//            see http://www.boost.org/LICENSE_1_0.txt or the local copy
//
//  Copyright (c) 2012 Sergey Strukov. All rights reserved.
//
//----------------------------------------------------------------------------------------
-->

<!DOCTYPE html>
<html>

<head>

 <title>CCore -> ParserGen</title>

 <link href="CCore.css" rel="stylesheet" type="text/css">

</head>

<body>

<h2>ParserGen</h2>

<p>
This program takes an output from <a href="page_LangLR1.html"><b>LangLR1.exe</b></a> 
and generates several <b>.h</b> and <b>.cpp</b> files. The output code can be used to 
build a C++ lanugage parser.
</p>

<pre>
ParserGen.exe &lt;State.dll-file&gt; &lt;output-prefix&gt;
</pre>

<p>
The first command line argument is a <b>State.dll</b> file, generated by the <b>LangLR1.exe</b>.
The second is an output files prefix. Multiple files with this prefix will be generated.
</p>

<p>
Below is an example for AMP language.
</p>

<p><b>Prefix.atom.gen.h</b></p>

<pre>
/* enum AtomClass */ 

enum AtomClass
 {
  Atom_Nothing,

  Atom_&lt;nake&gt;, /*  (  */
  Atom_&lt;nake&gt;, /*  )  */
  Atom_&lt;nake&gt;, /*  *  */
  Atom_&lt;nake&gt;, /*  +  */
  Atom_&lt;nake&gt;  /*  x  */
 };

const char * GetTextDesc(AtomClass ac);

</pre>

<p>
This is an atom index enum declaration. You must edit this file and give desired names to 
enumerators.
</p>

<p><b>Prefix.atom.gen.cpp</b></p>

<pre>
/* enum AtomClass */ 

const char * GetTextDesc(AtomClass ac)
 {
  static const char *const Table[]=
   {
    "no-atom",

    "(",
    ")",
    "*",
    "+",
    "x"
   };

  return Table[ac];
 }

</pre>

<p><b>Prefix.actions.gen.h</b></p>

<pre>
/* Action::Rule */ 

    Do_A1,
    Do_A2,
    Do_M1,
    Do_M2,
    Do_P1,
    Do_P2
</pre>

<p><b>Prefix.do.gen.h</b></p>

<pre>
/* do_...() */ 

   void do_A1();
   void do_A2();
   void do_M1();
   void do_M2();
   void do_P1();
   void do_P2();
</pre>

<p><b>Prefix.elem.gen.h</b></p>

<pre>
/* elem_...() */ 

   Element_A * elem_A1(Element_M *);
   Element_A * elem_A2(Element_A *,ElementAtom *,Element_M *);
   Element_M * elem_M1(Element_P *);
   Element_M * elem_M2(Element_P *,ElementAtom *,Element_M *);
   Element_P * elem_P1(ElementAtom *);
   Element_P * elem_P2(ElementAtom *,Element_A *,ElementAtom *);
</pre>

<p><b>Prefix.elements1.gen.h</b></p>

<pre>
/* elements */ 

struct Element_A;
struct Element_M;
struct Element_P;
</pre>

<p><b>Prefix.elements2.gen.h</b></p>

<pre>
/* struct Element_A */ 

struct Element_A : ElementBase
 {
  static ulen NextState(ulen state);

  void A1(ElementContext ctx,Element_M *);

  void A2(ElementContext ctx,Element_A *,ElementAtom *,Element_M *);
 };

/* struct Element_M */ 

struct Element_M : ElementBase
 {
  static ulen NextState(ulen state);

  void M1(ElementContext ctx,Element_P *);

  void M2(ElementContext ctx,Element_P *,ElementAtom *,Element_M *);
 };

/* struct Element_P */ 

struct Element_P : ElementBase
 {
  static ulen NextState(ulen state);

  void P1(ElementContext ctx,ElementAtom *);

  void P2(ElementContext ctx,ElementAtom *,Element_A *,ElementAtom *);
 };

</pre>

<p><b>Prefix.atom_state_table.gen.cpp</b></p>

<pre>
/* AtomStateTable */ 

static const StateTableType AtomStateTable[22][6]=
 {
  { 0, 1, 0, 0, 0, 2},
  { 0, 5, 0, 0, 0, 6},
  { 0, 0, 0, 0, 0, 0},
  { 0, 0, 0, 0, 9, 0},
  { 0, 0, 0, 0, 0, 0},
  { 0, 5, 0, 0, 0, 6},
  { 0, 0, 0, 0, 0, 0},
  { 0, 0,11, 0,12, 0},
  { 0, 0, 0, 0, 0, 0},
  { 0, 1, 0, 0, 0, 2},
  { 0, 0,17, 0,12, 0},
  { 0, 0, 0, 0, 0, 0},
  { 0, 5, 0, 0, 0, 6},
  { 0, 5, 0, 0, 0, 6},
  { 0, 0, 0, 0, 0, 0},
  { 0, 0, 0, 0, 0, 0},
  { 0, 0, 0,21, 0, 0},
  { 0, 0, 0, 0, 0, 0},
  { 0, 0, 0, 0, 0, 0},
  { 0, 0, 0,13, 0, 0},
  { 0, 0, 0, 0, 0, 0},
  { 0, 1, 0, 0, 0, 2}
 };

</pre>

<p><b>Prefix.do.gen.cpp</b></p>

<pre>
/* do_...() */ 

void Parser::do_A1()
 {
  Element_M *arg1=pop();

  Element_A *elem=elem_A1(arg1);

  ulen new_state=Element_A::NextState(stack->state);

  push(elem,new_state);
 }

void Parser::do_A2()
 {
  Element_M *arg3=pop();
  ElementAtom *arg2=pop();
  Element_A *arg1=pop();

  Element_A *elem=elem_A2(arg1,arg2,arg3);

  ulen new_state=Element_A::NextState(stack->state);

  push(elem,new_state);
 }

void Parser::do_M1()
 {
  Element_P *arg1=pop();

  Element_M *elem=elem_M1(arg1);

  ulen new_state=Element_M::NextState(stack->state);

  push(elem,new_state);
 }

void Parser::do_M2()
 {
  Element_M *arg3=pop();
  ElementAtom *arg2=pop();
  Element_P *arg1=pop();

  Element_M *elem=elem_M2(arg1,arg2,arg3);

  ulen new_state=Element_M::NextState(stack->state);

  push(elem,new_state);
 }

void Parser::do_P1()
 {
  ElementAtom *arg1=pop();

  Element_P *elem=elem_P1(arg1);

  ulen new_state=Element_P::NextState(stack->state);

  push(elem,new_state);
 }

void Parser::do_P2()
 {
  ElementAtom *arg3=pop();
  Element_A *arg2=pop();
  ElementAtom *arg1=pop();

  Element_P *elem=elem_P2(arg1,arg2,arg3);

  ulen new_state=Element_P::NextState(stack->state);

  push(elem,new_state);
 }

</pre>

<p><b>Prefix.do_rule.gen.cpp</b></p>

<pre>
/* doRule */ 

     case Action::Do_A1 : do_A1(); break;
     case Action::Do_A2 : do_A2(); break;
     case Action::Do_M1 : do_M1(); break;
     case Action::Do_M2 : do_M2(); break;
     case Action::Do_P1 : do_P1(); break;
     case Action::Do_P2 : do_P2(); break;
</pre>

<p><b>Prefix.elem.gen.cpp</b></p>

<pre>
/* elem_...() */ 

Element_A * Parser::elem_A1(Element_M *arg1)
 {
  Element_A *elem=ctx.create&lt;Element_A&gt;();

  elem-&gt;A1(ctx,arg1);

  return elem;
 }

Element_A * Parser::elem_A2(Element_A *arg1,ElementAtom *arg2,Element_M *arg3)
 {
  Element_A *elem=ctx.create&lt;Element_A&gt;();

  elem-&gt;A2(ctx,arg1,arg2,arg3);

  return elem;
 }

Element_M * Parser::elem_M1(Element_P *arg1)
 {
  Element_M *elem=ctx.create&lt;Element_M&gt;();

  elem-&gt;M1(ctx,arg1);

  return elem;
 }

Element_M * Parser::elem_M2(Element_P *arg1,ElementAtom *arg2,Element_M *arg3)
 {
  Element_M *elem=ctx.create&lt;Element_M&gt;();

  elem-&gt;M2(ctx,arg1,arg2,arg3);

  return elem;
 }

Element_P * Parser::elem_P1(ElementAtom *arg1)
 {
  Element_P *elem=ctx.create&lt;Element_P&gt;();

  elem-&gt;P1(ctx,arg1);

  return elem;
 }

Element_P * Parser::elem_P2(ElementAtom *arg1,Element_A *arg2,ElementAtom *arg3)
 {
  Element_P *elem=ctx.create&lt;Element_P&gt;();

  elem-&gt;P2(ctx,arg1,arg2,arg3);

  return elem;
 }

</pre>

<p><b>Prefix.elements3.gen.cpp</b></p>

<pre>
/* struct Element_A */ 

void Element_A::A1(ElementContext,Element_M *)
 {
  // TODO
 }

void Element_A::A2(ElementContext,Element_A *,ElementAtom *,Element_M *)
 {
  // TODO
 }

/* struct Element_M */ 

void Element_M::M1(ElementContext,Element_P *)
 {
  // TODO
 }

void Element_M::M2(ElementContext,Element_P *,ElementAtom *,Element_M *)
 {
  // TODO
 }

/* struct Element_P */ 

void Element_P::P1(ElementContext,ElementAtom *)
 {
  // TODO
 }

void Element_P::P2(ElementContext,ElementAtom *,Element_A *,ElementAtom *)
 {
  // TODO
 }

</pre>

<p><b>Prefix.next_state.gen.cpp</b></p>

<pre>
/* Element_...::NextState() */ 

/* Element_A::NextState() */ 

ulen Element_A::NextState(ulen state)
 {
  static const StateTableType Table[]=
   {
     3, 7, 0, 0, 0,10, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0
   };

  return Table[state];
 }

/* Element_M::NextState() */ 

ulen Element_M::NextState(ulen state)
 {
  static const StateTableType Table[]=
   {
     4, 8, 0, 0, 0, 8, 0, 0, 0,14,
     0, 0,18,20, 0, 0, 0, 0, 0, 0,
     0,15
   };

  return Table[state];
 }

/* Element_P::NextState() */ 

ulen Element_P::NextState(ulen state)
 {
  static const StateTableType Table[]=
   {
    16,19, 0, 0, 0,19, 0, 0, 0,16,
     0, 0,19,19, 0, 0, 0, 0, 0, 0,
     0,16
   };

  return Table[state];
 }

</pre>

<p><b>Prefix.rule_table.gen.cpp</b></p>

<pre>
/* RuleTable */ 

static const RuleTableType RuleTable[22][6]=
 {
  {0,1,0,0,0,1},
  {0,1,0,0,0,1},
  {6,0,0,6,6,0},
  {1,0,0,0,1,0},
  {2,0,0,0,2,0},
  {0,1,0,0,0,1},
  {0,0,6,6,6,0},
  {0,0,1,0,1,0},
  {0,0,2,0,2,0},
  {0,1,0,0,0,1},
  {0,0,1,0,1,0},
  {7,0,0,7,7,0},
  {0,1,0,0,0,1},
  {0,1,0,0,0,1},
  {3,0,0,0,3,0},
  {5,0,0,0,5,0},
  {4,0,0,1,4,0},
  {0,0,7,7,7,0},
  {0,0,3,0,3,0},
  {0,0,4,1,4,0},
  {0,0,5,0,5,0},
  {0,1,0,0,0,1}
 };

</pre>

<p>
These files are pieces of parser declaration.
</p>

<pre>
</pre>

</body>

</html>

