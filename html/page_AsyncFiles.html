<!--
/* page_AsyncFiles.html */
//----------------------------------------------------------------------------------------
//
//  Project: CCore 1.02
//
//  License: Boost Software License - Version 1.0 - August 17th, 2003 
//
//            see http://www.boost.org/LICENSE_1_0.txt or the local copy
//
//  Copyright (c) 2012 Sergey Strukov. All rights reserved.
//
//----------------------------------------------------------------------------------------
-->

<!DOCTYPE html>
<html>

<head>

 <title>CCore -> Async Files</title>

 <link href="CCore.css" rel="stylesheet" type="text/css">

</head>

<body>

<h2>Async Files</h2>

<p class="Files">Files <b>CCore/inc/AsyncFile.h</b> <b>CCore/src/AsyncFile.cpp</b></p>

<p class="Files">Files <b>CCore/inc/AsyncFileToMem.h</b> <b>CCore/src/AsyncFileToMem.cpp</b></p>

<p class="Files">Files <b>CCore/inc/sys/SysAsyncFile.h</b> <b>CCore/src/sys/SysAsyncFile.cpp</b></p>

<p class="Files">Files <b>CCore/inc/sys/SysAsyncFileSystem.h</b> <b>CCore/src/sys/SysAsyncFileSystem.cpp</b></p>

<p>
Async file and file system devices are a packet processing devices, that performes file and file system
operations in asynchronous manner. To be used, the device must be registred in the default 
<a href="page_ObjectHost.html">Object Host</a>. The name of the object must be used as a device name
in file names on that device. I.e. if some object is registered under the name "host", 
the file name "host:/file.txt" refers to the file "/file.txt" on that device or "host:c:/file.txt" refers
to "c:/file.txt".
</p>

<h4>Sys::AsyncFileDevice</h4>

<p>
<b>Sys::AsyncFileDevice</b> is an abstract interface of an async file device. An async file device class
must implement this interface.
</p>

<pre>
struct <span class="att">Sys::AsyncFileDevice</span>
 {
  virtual Sys::AsyncFileState * createState(const ObjHook &hook) noexcept(EnableNoExcept) =0;
 };
</pre>

<p>
To work with a file, a file state object must be created. The class of this object must
implement the <b>Sys::AsyncFileState</b> interface. A state is created by the <b>createState()</b>
method. A pointer to the <b>Sys::AsyncFileState</b> is returned. If the operation is failed, null pointer
is returned. The argument <b>hook</b> should be a hook, which was used to pick the device object (or
a hook to an "upper" object). It is used for the life-time control of the device object itself to prevent
its destruction while one of states is alive.
</p>

<pre>
class <span class="att">Sys::AsyncFileState</span> : public MemBase_nocopy
 {
   ObjHook hook;
   
  protected:  
   
   PacketFormat write_format;
   ulen max_read_len;
   
  public: 
  
   explicit AsyncFileState(const ObjHook &amp;hook_) : hook(hook_) {}
   
   virtual ~AsyncFileState() {}
   
   PacketFormat getWriteFormat() const { return write_format; }
   
   ulen getMaxReadLen() const { return max_read_len; }
   
   virtual void open(Packet&lt;uint8,Sys::AsyncFile::OpenExt&gt; packet,StrLen file_name,FileOpenFlags oflags)=0;
   
   virtual void close(Packet&lt;uint8,Sys::AsyncFile::CloseExt&gt; packet,bool preserve_file)=0;
   
   virtual void write(Packet&lt;uint8,Sys::AsyncFile::WriteExt&gt; packet,FilePosType off)=0;
   
   virtual void read(Packet&lt;uint8,Sys::AsyncFile::ReadExt&gt; packet)=0;
   
   virtual void read(Packet&lt;uint8,Sys::AsyncFile::ReadBufExt&gt; packet)=0;
 };
</pre>

<p>
<b>Sys::AsyncFileState</b> contains inside a copy of the hook, provided to the <b>createState()</b> method.
</p>

<p>
Destructor is virtual, so it is safe to destroy an object using a base class pointer.
</p>

<p>
Two data fields: <b>write_format</b> and <b>max_read_len</b> must be filled by a derived class.
These fields can be red by the methods <b>getWriteFormat()</b> and <b>getMaxReadLen()</b>.
File operations are performed with the following abstract methods. Each operation requires a packet
to be prepared and provided. A method starts an operation, using this packet. Once the operation is complete,
the packet is completed and the result of the operation can be retrieved. The packet can be cancelled 
to cancel the operation. A packet must not be short, its data buffer <b>may</b> 
be used to perform the operation (and may not).
</p>

<p>
<b>open()</b> opens a file. Once this is done, read and write operations can be performed with this file.
Packet data are not required (but packet buffer may be used). File name and open flags are provided as
the method arguments. An implementaion might use the packet buffer to store and transfer this information 
further, for example over a network. The packet extension <b>Sys::AsyncFile::OpenExt</b> is used to return
the operation result:
</p>

<pre>
struct <span class="att">Sys::AsyncFile::OpenExt</span>
 {
  PacketFormat write_format; // output
  ulen max_read_len;         // output
    
  FilePosType file_len;      // output
    
  FileError error;           // output
    
  // methods
    
  void setFileLen(FilePosType file_len_)
   {
    file_len=file_len_;
    error=FileError_Ok;
   }
    
  void setError(FileError error_)
   {
    write_format=Nothing;
    max_read_len=0;
    file_len=0;
    error=error_;
   }
 };
</pre>

<p>
The open operation should use provided methods to fill the result of the operation. First two fields are not used 
to return a value, but should be cleared in case of error.
</p>

<p>
<b>close()</b> closes the opened file. <b>preserve_file</b> cancels the <b>Open_AutoDelete</b> flag.
Once close is done, the state can be deleted. State deletion, while file is not closed, is not recommended
(but not completely avoidable). Packet data are not required (but packet buffer may be used).
The packet extension <b>Sys::AsyncFile::CloseExt</b> is used to return the operation result:
</p>

<pre>
struct <span class="att">Sys::AsyncFile::CloseExt</span>
 {
  FileError error;           // output
    
  // methods
    
  void noError()
   {
    error=FileError_Ok;
   }
    
  void setError(FileError error_)
   {
    error=error_;
   }
 };
</pre>

<h4>Sys::AsyncFileSystemDevice</h4>

</body>

</html>

