<!--
/* page_Taxonomy.html */
//----------------------------------------------------------------------------------------
//
//  Project: CCore 1.02
//
//  License: Boost Software License - Version 1.0 - August 17th, 2003 
//
//            see http://www.boost.org/LICENSE_1_0.txt or the local copy
//
//  Copyright (c) 2012 Sergey Strukov. All rights reserved.
//
//----------------------------------------------------------------------------------------
-->

<!DOCTYPE html>
<html>

<head>

 <title>CCore -> Taxonomy of classes</title>

 <link href="CCore.css" rel="stylesheet" type="text/css">

</head>

<body>

<h2>Taxonomy of classes</h2>

<p>
This page provides the list of common terms and the taxonomy of classes. <b>Class</b> in C++ is a very
generic and powerfull entity, so we classify them by its purpose and nature.
</p>

<h3>Terms</h3>

<p>
<b>Efficient</b> means <b>O(1)-nothrow</b>. I.g. it is a sequence of operations, which has a definite,
reasonably small execution time limit and always successful.
</p>


<p>
<b>Derivability</b> is an ability of some entity to be used as the building block of the whole. See, for example,
<a href="page_Swap.html"><b>Swap</b></a>.
</p>


<h3><i>Class</i>ification</h3>

<h4>Word</h4>

<p>
<b>Word</b> is a enumerator, purposed to verbose some generic action. In C++ there is no named constructors.
But it is possible to add an unused argument of a <b>Word</b> type to clearly distinguish between different
overloaded constructors. See, for example, <a href="page_Nothing.html"><b>Nothing</b></a>. 
</p>

<h4>Guard function</h4>

<p>
<b>Guard function</b> ensures some condition. If the required condition is not true, an exception is thrown.
See, for example, <a href="page_PtrLen.html">GuardIndex()</a>. Usually, we define a guard function by the following pattern:
</p>

<pre>

void GuardXXXCCC(&lt;arg_list&gt;); // exception throwing function

void GuardXXX(&lt;arg_list&gt;) // guard function 
 {
  if( &lt;not condition&gt; ) GuardXXXCCC(&lt;arg_list&gt;);
 }

</pre>

<p>
Class methods can also be guard methods.
</p>

<h4>Abort function</h4>

<p>
<b>Abort function</b> aborts execution with some diagnostic message. For example, 
<a href="page_Init.html">NoObjectAbort()</a> is called when the object has not been initialized.
</p>

<h4>Creator function</h4>

<p>
<b>Creator function</b> creates some object. Normally we create an object using its class constructor. But if we are using
class templates, we have to provide a template argument list. Using <b>Creator function</b> allows infer this list from the
function argument types. See, for example, <a href="page_Tuple.html">MakeTuple()</a>:
</p>

<pre>

template &lt;class ... TT&gt;
Tuple&lt;TT...&gt; MakeTuple(const TT &amp; ... tt);

</pre>

<h4>Partial class</h4>

<p>
<b>Partial class</b> is a class not intended for a direct usage, but designed to be a builing block for a derived class.
Like a sophisticated machines, built from a machine parts, in C++ the complex classes can be constructed from a smaller
and simpler classes. Sometimes such parts are not usable alone. Hence we call them <b>Partial</b>. 
See, for example, <a href="page_ToMemBase.html">ToMemBase</a>. Such classes often have names ending in "Base".
</p>

<h4>Small Data Type</h4>

<p>
<b>Small Data Type</b> is a type like basic types with a small state and data semantic. These types
have <b>efficient</b> copy constructor and assign operator.
</p>

<pre>

struct Point
 {
  int x;
  int y;
 };

</pre>

<h4>Data Type</h4>

<p>
<b>Data Type</b> is a type with data semantic, but with an arbitary large state. The simplest example is the type <b>String</b>.
The purpose of such types is to store some discrete piece of information. The information is stored in some owned buffer.
They may have the copy constructor and the assign operator. These operators can be implemented as <b>efficient</b> 
operations using reference counting.
In <b>CCore</b> we don't make a class copyable if there is no way to make it <b>efficient</b>. In such situation the class
is not copyable, but usually swapable/moveable.
</p>

<h4>Resource Host Type</h4>

<p>
<b>Resource Host Type</b> is a wrapper over some resource handle, like a file descriptor, a socket descriptor, any other OS
object descriptor, object pointer, memory block pointer etc. In destructor the handle is released. The purpose of such types
is to ensure the resource will be eventually released. It also provides some methods to use the resource.
<b>Resource Host Type</b>s are not copyable, but swapable/moveable.
</p>

<h4>Scope Lock Type</h4>

<p>
<b>Scope Lock Type</b> objects are used to "lock" something for the duration of a scope. For example, <b>Mutex::Lock</b>
object is used to lock a mutex:
</p>

<pre>

Mutex mutex;

{
 Mutex::Lock lock(mutex);

 ....
}

</pre>

<h4>Container Type</h4>

<p>
<b>Container Type</b>
</p>

<h4>Pointer Type</h4>

<p>
<b>Pointer Type</b>
</p>

<h4>Cursor</h4>

<p>
<b>Cursor</b>
</p>

<pre>

R r=....;

for(; +r ;++r) { do_with(*r); }

</pre>

<h4>TBC...</h4>

<p>
<b>Range Access Interface</b>
</p>

<p>
<b>Object Pointer Interface</b>
</p>

<p>
<b>Resource Provider Type</b>
</p>

<p>
<b>Device Type</b>
</p>

<p>
<b>Helper Type</b> 
</p>

<p>
<b>Proxy type</b>
</p>

<p>
<b>Property Type</b> is a kind of classes, providing some property and meant to be used as a base to
inherit this property by a derived class. For example, see <a href="page_NoCopy.html"><b>NoCopy</b></a>.
</p>

<p>
<b>Algorithm Package</b>
</p>

<p>
<b>Class-function</b>
</p>

<p>
<b>Meta-class</b>
</p>

<p>
<b>Meta-function</b>
</p>

</body>

</html>

