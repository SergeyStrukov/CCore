<!--
/* page_CCoreGeneral.html */
//----------------------------------------------------------------------------------------
//
//  Project: CCore 1.02
//
//  License: Boost Software License - Version 1.0 - August 17th, 2003 
//
//            see http://www.boost.org/LICENSE_1_0.txt or the local copy
//
//  Copyright (c) 2012 Sergey Strukov. All rights reserved.
//
//----------------------------------------------------------------------------------------
-->

<!DOCTYPE html>
<html>

<head>

 <title>CCore -> CCore General</title>

 <link href="CCore.css" rel="stylesheet" type="text/css">

</head>

<body>

<h2>CCore General</h2>

<h3>Source code organization</h3>

<p>
Most of <b>CCore</b> declarations are enclosed in the namespace <b>CCore</b>.
</p>

<p>
Source code is split into several major parts: <b>CCore</b>, <b>XCore</b>, <b>HCore</b> and <b>Target</b>.
First three are located in the same named directories in the <b>CCore root</b>.
Last one is located in the directory <b>Target/&lt;TargetName&gt;</b>.
Tools are located in the directory <b>tools</b>.
</p>

<p>
Source code parts consist of three directories : <b>inc</b>, <b>src</b>, and <b>test</b>.
So to include a <b>CCore</b> header write
</p>

<pre>

#include &lt;CCore/inc/...&gt;

</pre>

<p>
Each <b>CCore</b> .h file has a correspondent .cpp file, even if it defines nothing.
</p>

<p>
Each target is either <b>HCore</b> or <b>XCore</b> target, so it includes only one part: <b>HCore</b> or <b>XCore</b>.
</p>

<h3>Names and decorations</h3>

<p>
All global entities have capitalized names. I.e. class names, global objects etc. Local object names, non-static members
and method names start from lowercase letters.
</p>

<p>
Here is an example of a class definition:
</p>

<pre>

class SomeClass
 {
   int item_count;

  public:

   int getItemCount() const { return item_count; }

   void setItemCount(int item_count_) { item_count=item_count_; }
 };

</pre>

<p>
The private part goes first, the public is last.
Members are decorated as "item_count". Methods as "getItemCount()". Getters as "getItemCount()" and
setters as "setItemCount()". The argument, used to initialize a member "item_count" named as "item_count_".
</p>

<p>
Suffixes are used to name variants:
</p>

<pre>

struct MemBase;

struct MemBase_nocopy;

</pre>

<p>
Sections are used to group members:
</p>

<pre>
class Sem : public Funchor_nocopy
 {
   .... 

  public:
   
   // constructors
  
   explicit Sem(ulen count=0);
   
   explicit Sem(TextLabel name,ulen count=0);
   
   ~Sem();
   
   // give
   
   void give();
   
   void give_many(ulen dcount);
   
   // take
   
   bool try_take();
   
   void take();
   
   bool take(MSec timeout);
   
   bool take(TimeScope time_scope); 
    
   // functions
   
   Function&lt;void (void)&gt; function_give() { return FunctionOf(this,&amp;Sem::give); }
 };
</pre>

<p>
The popular words are: "count", "len", "obj", "try...", "zstr", "d..." to designate a delta value.
</p>

<h3>operator + and a "null" state</h3>

<p>
There are many types, which have a special state &mdash; "null" state.
Usually for such types the default constructor initialize them in this state.
<b>CCore</b> often defines the <b>Nothing</b>-constructor to do the same.
And two operators: <b>operator +</b> and <b>operator !</b> can be used to check, if the object is "null".
</p>

<pre>
class SomeClass
 {
  public:

   SomeClass(); // set the object into the null state

   SomeClass(NothinType); // set the object into the null state too

   boolable operator + () const; // return true, if the object is not "null"

   bool operator ! () const; // return true, if the object is "null"
 };
</pre>

</body>

</html>

