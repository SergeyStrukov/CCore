<!--
/* page_DeferCall.html */
//----------------------------------------------------------------------------------------
//
//  Project: CCore 1.04
//
//  License: Boost Software License - Version 1.0 - August 17th, 2003 
//
//            see http://www.boost.org/LICENSE_1_0.txt or the local copy
//
//  Copyright (c) 2013 Sergey Strukov. All rights reserved.
//
//----------------------------------------------------------------------------------------
-->

<!DOCTYPE html>
<html>

<head>

 <title>CCore -> DeferCalls</title>

 <link href="CCore.css" rel="stylesheet" type="text/css">

</head>

<body>

<h2>DeferCalls</h2>

<p class="Files">Files <b>CCore/inc/DeferCall.h</b> <b>CCore/src/DeferCall.cpp</b></p>

<p>
<b>DeferCall</b> is a defer call engine. It allows record actions and execute them in a defer call loop.
This technology is similar to the message loop processing, known in the GUI application development, but is not 
restricted to a predefined set of messages.
</p>

<p>
<b>DeferCall</b> is essentially single-threaded. You may run several defer call loops on one per thread basis.
</p>

<p>
To run a <b>DeferCall</b> loop, you have to derive a class from the <b>DeferCallQueue</b>.
</p>

<pre>

class Queue : public DeferCallQueue
 {
   ....

  public:
  
   Queue() 
    {
     activate();
    }
   
   ~Queue() 
    {
     deactivate();
    }
   
   void forward(TimeScope time_scope)
    {
     ....
    }
 };

</pre>

<p>
<b>forward()</b> is called when the defer call queue is empty. This method must generate a new defer call or sleep
within the given <b>time_scope</b> period. <b>forward()</b> should be used to generate defer calls 
to handle external events, like key pressing of mouse movement.
</p>

<p>
Next, you have to create a queue object, then prepare other entities and run the loop.
</p>

<pre>

Queue queue;

....

Queue::Loop();

</pre>

<p>
To stop the loop use the <b>DeferCallQueue::Stop()</b>. The global methods address the current active <b>DeferCallQueue</b>
object for the current thread. Objects, involved in the <b>DeferQueue</b> processing on this thread, 
should live withing the queue object life-time.
</p>

<h4>DeferCall</h4>

<p>
The class <b>DeferCall</b> serves as the base class of other defer call classes. You don't need to use it directly.
</p>

<pre>

class <span class="Att">DeferCall</span> : NoCopy
 {
   ....

  public:
  
   DeferCall();
  
   ~DeferCall();
   
   virtual void call()=0;
   
   virtual void destroy(DeferCallQueue *defer_queue)=0;
   
   void safeCall();
   
   static void * operator new(std::size_t len,DeferCallQueue *defer_queue);
   
   static void * operator new(std::size_t len,JustTryType,DeferCallQueue *defer_queue) noexcept;
   
   static void operator delete(void *mem,DeferCallQueue *defer_queue);
   
   static void operator delete(void *mem,JustTryType,DeferCallQueue *defer_queue);
 };

</pre>

<p>
<b>call()</b> is defined in a derived class and is an actual processing method.
</p>

<p>
<b>destroy()</b> is defined in a derived class to properly destroy the object.
</p>

<p>
<b>safeCall()</b> calls the <b>call()</b> and catches and ignores all exceptions.
</p>

<p>
Other methods are used to allocate and free memory for the object from the given <b>DeferCallQueue</b>.
</p>

<h4>DeferCallHeap</h4>

<p>
The class <b>DeferCallHeap</b> is used to allocate and free memory for <b>DeferCall</b> objects.
An object of this class is used by a <b>DeferCallQueue</b> object for the memory management.
You don't need to use this class directly.
</p>

<pre>

class <span class="Att">DeferCallHeap</span> : NoCopy
 {
   ....

  public:
  
   explicit DeferCallHeap(ulen mem_len);
   
   ~DeferCallHeap();
   
   void * alloc(ulen len);
   
   void free(void *mem);
   
   static ulen GetMaxLen(); // max cached length
 };

</pre>

<p>
The memory is taken from a memory block of <b>mem_len</b> length. This block is allocated by the constructor
and released by the destructor.
</p>

<p>
<b>alloc()</b> returns null, if there is no memory available.
</p>

<p>
<b>free()</b> argument must not be null.
</p>

<p>
<b>GetMaxLen()</b> is used for the memory allocation caching. To speed up memory operations for short objects 
<b>DeferCallHeap</b> maintains a list of short memory blocks up to some count for such allocations.
<b>GetMaxLen()</b> determines the maximum short allocation length.
</p>

<h4>DeferCallQueue</h4>

<p>
The class <b>DeferCallQueue</b> is a main <b>DeferCall</b> engine class. It maintains the list of <b>DeferCall</b>s
and executes them in a loop. The object of this type is registered per thread as the current thread
<b>DeferCall</b> loop object.
</p>

<pre>

class <span class="Att">DeferCallQueue</span> : NoCopy
 {
   ....

  private:
   
   virtual void forward(TimeScope time_scope)=0;
   
  protected:
   
   void activate(); 
   
   void deactivate();
   
  public:
   
   // constructors
   
   static const ulen DefaultMemLen = 1_MByte ;
   
   explicit DeferCallQueue(ulen mem_len=DefaultMemLen);
   
   ~DeferCallQueue();
   
   // heap
   
   void * try_alloc(ulen len);
   
   void * alloc(ulen len);
   
   void free(void *mem); // mem!=0
   
   template &lt;class T&gt;
   void destroy(T *obj);
   
   // call
   
   void post(DeferCall *defer_call);
   
   void post_first(DeferCall *defer_call);
   
   void start_tick(DeferCall *defer_call);
   
   void stop_tick(DeferCall *defer_call); 
   
   // loop
   
   static constexpr MSec DefaultTickPeriod = 40_msec ; // 25 Hz 
   
   void loop(MSec tick_period=DefaultTickPeriod);
   
   void stop();
   
   // per-thread queue
   
   static DeferCallQueue * Get();
   
   static void Loop(MSec tick_period=DefaultTickPeriod);
   
   static void Stop();
 };

</pre>

<p>
<b>forward()</b> must be defined in a derived class. This method is called when the defer call queue is empty.
</p>

<p>
<b>activate()</b> must be called in a derived class constructor to register the object with the current thread. 
If some object is already registered, an exception is thrown.
</p>

<p>
<b>deactivate()</b> must be called in a derived class destructor to unregister the object with the current thread.
</p>

<p>
<b>DefaultMemLen</b> is the default heap capacity.
</p>

<p>
<b>mem_len</b> is a heap capacity. All <b>DeferCall</b> objects for this loop are created in the heap of this capacity.
</p>

<p>
The following four methods are heap methods. You don't need to use these methods directly.
</p>

<p>
<b>try_alloc()</b> returns null, if there is no memory.
</p>

<p>
<b>alloc()</b> throws an exception, if there is no memory.
</p>

<p>
<b>free()</b> releases the memory, the argument must not be null.
</p>

<p>
<b>destroy()</b> destroys a <b>DeferCall</b> object.
</p>

<p>
The following four methods are queue methods. You don't need to use these methods directly.
Arguments must not be null.
</p>

<p>
<b>post()</b> puts the <b>DeferCall</b> object in the queue. The object is consumed.
It will be destroyed after processing or during the queue cleanup after stop.
</p>

<p>
<b>post_first()</b> puts the <b>DeferCall</b> object in the queue head. The object is consumed.
It will be destroyed after processing or during the queue cleanup after stop.
</p>

<p>
<b>start_tick()</b> starts ticks on the object. The object is not consumed. It retains the owner.
</p>

<p>
<b>stop_tick()</b> stops ticks on the object. The object can be destroyed now.
</p>

<p>
The next two methods are loop methods. You don't need to use these methods directly.
</p>

<p>
<b>loop()</b> starts the defer calls loop. The argument is the tick period, defaulted to the <b>DefaultTickPeriod</b>,
equals 40 milliseconds, that gives 25 Hz tick frequency. 
</p>

<p>
<b>stop()</b> stops the loop.
</p>

<p>
Finally, three global methods.
</p>

<p>
<b>Get()</b> gets the active <b>DeferCallQueue</b> object. An exception is thrown, if there is no one.
</p>

<p>
<b>Loop()</b> starts the defer call loop.
</p>

<p>
<b>Stop()</b> stops the loop.
</p>

<h4>DeferCouple</h4>

<pre>

struct <span class="Att">DeferCouple</span>
 {
  DeferCallQueue *defer_queue;
  DeferCall *defer_call;
  
  // constructors
  
  DeferCouple() : defer_queue(0),defer_call(0) {}
  
  DeferCouple(DeferCallQueue *defer_queue_,DeferCall *defer_call_) 
   : defer_queue(defer_queue_),
     defer_call(defer_call_) 
   {
    if( !defer_call ) defer_queue=0; 
   }
  
  // props
  
  bool operator ! () const { return !defer_queue; }
  
  // cleanup
  
  void cleanup() noexcept(EnableNoExcept)
   {
    if( defer_queue )
      {
       defer_call->destroy(defer_queue);
      
       defer_queue=0;
       defer_call=0;
      }
   }
  
  // post
  
  void post() { defer_queue->post(defer_call); }
  
  void post_first() { defer_queue->post_first(defer_call); }
  
  void try_post() { if( defer_queue ) defer_queue->post(defer_call); }
  
  void try_post_first() { if( defer_queue ) defer_queue->post_first(defer_call); }
  
  void start_tick() { defer_queue->start_tick(defer_call); }
  
  void stop_tick() { defer_queue->stop_tick(defer_call); }
 };

</pre>

<h4>DeferTick</h4>

<pre>

class <span class="Att">DeferTick</span> : NoCopy
 {
   ....

  public: 
   
   // constructors
   
   explicit DeferTick(DeferCouple couple_={});
   
   ~DeferTick();
   
   // set/reset
   
   bool set(DeferCouple couple);
   
   bool reset();
   
   void operator = (DeferCouple couple);
   
   // start/stop
   
   bool start();
   
   bool stop();
 };

</pre>

<h4>DeferInput</h4>

<pre>

template &lt;class S&gt;
class <span class="Att">DeferInput</span> : NoCopy
 {
   ....

  public:
   
   template &lt;class ... TT&gt;
   static constexpr ulen GetMessageLength();
 
   // constructors
   
   explicit DeferInput(S *obj);
   
   ~DeferInput();
   
   void cancel();
   
   // post
   
   template &lt;class ... TT&gt;
   DeferCouple create(void (S::* method)(TT... tt),const TT &amp; ... tt); 
   
   template &lt;class ... TT&gt;
   void post(void (S::* method)(TT... tt),const TT &amp; ... tt); 
   
   template &lt;class ... TT&gt;
   void post_first(void (S::* method)(TT... tt),const TT &amp; ... tt); 

   // try post
   
   template &lt;class ... TT&gt;
   DeferCouple try_create(void (S::* method)(TT... tt),const TT &amp; ... tt); 
   
   template &lt;class ... TT&gt;
   void try_post(void (S::* method)(TT... tt),const TT &amp; ... tt); 
   
   template &lt;class ... TT&gt;
   void try_post_first(void (S::* method)(TT... tt),const TT &amp; ... tt); 
   
   // post interface
   
   template &lt;class FuncInit&gt;
   DeferCouple create(FuncInit func_init); // func(S &amp;)
   
   template &lt;class FuncInit&gt;
   void post(FuncInit func_init); 
   
   template &lt;class FuncInit&gt;
   void post_first(FuncInit func_init); 
   
   // try post interface
   
   template &lt;class FuncInit&gt;
   DeferCouple try_create(FuncInit func_init); // func(S &amp;)
   
   template &lt;class FuncInit&gt;
   void try_post(FuncInit func_init); 
   
   template &lt;class FuncInit&gt;
   void try_post_first(FuncInit func_init); 
 };

</pre>

</body>

</html>

