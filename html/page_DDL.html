<!--
/* page_DDL.html */
//----------------------------------------------------------------------------------------
//
//  Project: CCore 1.02
//
//  License: Boost Software License - Version 1.0 - August 17th, 2003 
//
//            see http://www.boost.org/LICENSE_1_0.txt or the local copy
//
//  Copyright (c) 2012 Sergey Strukov. All rights reserved.
//
//----------------------------------------------------------------------------------------
-->

<!DOCTYPE html>
<html>

<head>

 <title>CCore -> DDL</title>

 <link href="CCore.css" rel="stylesheet" type="text/css">

</head>

<body>

<h2>DDL</h2>

<p class="Files">Files <b>CCore/inc/ddl/DDLEngine.h</b> <b>CCore/src/ddl/DDLEngine.cpp</b></p>

<p class="Files">Files <b>CCore/inc/ddl/DDLMap.h</b> <b>CCore/src/ddl/DDLMap.cpp</b></p>

<p class="Files">Files <b>CCore/inc/ddl/DDLTypedMap.h</b> <b>CCore/src/ddl/DDLTypedMap.cpp</b></p>

<p class="Files">Subfolders <b>CCore/inc/ddl</b> <b>CCore/src/ddl</b></p>


<p>
<b>DDL</b> is the <b>Data Definition Language</b>. This language is to record a general-kind data
in a textual form similar to the C language. But there are important differences between how DDL interprets
data and expresions and C. <b>DDL</b> is a "bye-bye <b>XML</b>" language.
</p>

<h2>Brief introduction</h2>

<p>
Documents <b>txt/DDL-1*.*</b> contains number of precise definitions, related to <b>DDL</b> in
a waterless form. An here is a brief introduction to the language.
</p>

<p>
<b>DDL</b> is to define named constants. Each constant has an associated type. Types can be basic and derived.
The most important derived types are structures.
</p>

<p>
Basic types are integral, <b>text</b> and <b>ip</b>. Intergral types are:
</p>

<pre>

uint8    sint8
uint16   sint16
uint32   sint32
uint64   sint64

(sint,uint) = (sint32,uint32) or (sint64,uint64)

int = sint

ulen = uint32 or uint64 >= uint

</pre>

<p>
<b>text</b> type represents a character string. <b>ip</b> type represents an IPv4 address.
</p>

<p>
<b>int</b>, <b>sint</b>, <b>uint</b> are target-dependent "machine-word-length" types.
</p>

<p>
<b>ulen</b> is a target-dependent "machine-address-length" type.
</p>

<p>
Derived types are pointers, arrays and structures:
</p>

<pre>

int a = 10 ;

int * pa = &a ;

text [a] B = { "b1" , "b2" } ;

text [] C = { "c1" , "c2" } ;

struct S
 {
  text name = "unnamed" ;
  int id = 0 ;
 };

S record = { "" , 10 } ;

</pre>

<p>
If the array length is not given explicitly, then it is infered from the initializer.
Structure members may have default initializers.
</p>

<p>
Type aliases and scopes are supported:
</p>

<pre>

scope Data {

type List = int[] ;

} // scope Data

Data#List list = {1,2,3} ;

</pre>

<p>
Dots can be used to designate the current scope or parent scopes:
</p>

<pre>

scope S1 {

int i1 = 1 ;

 scope S2 {

 int i2 = 2 ;

  scope S3 {

  int i3 = 3 ;

   int i = .#i3 + ..#i2 + ...#i1 ; // absolute names

   int j = i3 + i2 + i1 ;          // relative names

   int k = i1 + S2#i2 + S2#S3#i3 ; // more relative names

  }

 }

} 

</pre>

<p>
The language is commutative, i.g. the order of declarations is not important:
</p>

<pre>

int a = c + 1 ;

int b = a + 1 ;

int c = 100 ;

</pre>

<p>
Structures define scopes and may declare types and constants:
</p>

<pre>

struct S 
 {
  type Val = int ;

  const ulen Len = 100 ;

  type List = Val[Len] ;
 };

scope S
 {
  List list = {1,2,3} ;
 }

</pre>

<p>
<b>DDL</b> supports file inclusion:
</p>

<pre>

scope Inc { include &lt;some_file.ddl&gt; }

</pre>

<p>
But the content of an included file must be a proper <b>DDL</b> text, except names may not be defined
inside the included file. Binding a file name with a particular file (real or virtual) 
is implementation-defined. 
</p>

<h2>DDL elements</h2>

<p>
<b>DDL</b> elements are: scopes, types, type aliases, constants, literals and expressions.
<b>DDL</b> text is a sequence of definitions. A definition defines a scope, a struct, 
a type alias or a constant. Literals and expressions are used to define a constant's value.
</p>

<h3>Comments</h3>

<p>
<b>DDL</b> accepts long and short comments:
</p>

<pre>

/* This is a long comment */

// short

</pre>

<h3>Scopes</h3>

<p>
Scope is a "definition directory". Scopes can be nested and splitted. Each named language element
belongs to some scope. The full element name is <b># Scope1name # Scope2Name # ... # ElementName</b>.
</p>

<pre>

scope A { // open scope #A

....

} // close scope #A

scope B { // open scope #B

scope C { // open scope #B#C

....

} // close scope #B#C

....

} // close scope #B

scope A { // open again scope #A 

....

} // close scope #A

</pre>

<p>
When a name is used to refer to a language element, it may be relative or absolute.
A relative name starts from a name, an absolute name starts from the <b>#</b> or one or more dots. 
One dot means the current scope, 2 dots means the parent scope and so on.
A relative name is looked in all scopes down from the current.
</p>

<pre>

scope S1 {

int i = 1 ;

scope S2 {

int i = 2 ;

scope S3 {

int i = 3 ;

int j = -3 ;

scope S4 {

int i = 4 ;

int i1 = i ; // 4

int i2 = j ; // -3

int i3 = S1#i ; // 1

int i4 = #S1#i ; // 1

int i5 = .#i ; // 4

int i6 = ..#i ; // 3

int i7 = ...#i ; // 2

}

}

}

}

</pre>

<h3>Types and type aliases</h3>

<p>
There are basic types and derived types. Basic types are designated by the following keywords:
</p>

<pre>

sint8  uint8
sint16 uint16
sint32 uint32
sint64 uint64

int sint uint ulen

text ip

</pre>

<p>
Derived types are pointers, arrays and structures.
</p>

<p>
Pointer type is designated by the type and the following asterisk:
</p>

<pre>

Type * 

</pre>

<p>
Array type is designated by the type and the following pair of square brackets
with the optional expression inside:
</p>

<pre>

Type []
Type [Expression]

</pre>

<p>
The expression defines the array length. The resulting type of this expression is <b>ulen</b>.
</p>

<p>
Non-pointer and non-array type can be a basic type name, a type alias name, a structure name
or a structure definition.
</p>

<pre>

// basic type name

int a = 0;
ulen b = 0 ;

// type alias name

type Int = int ;

Int c = 0 ;

// struct name

struct S {};

S s = {} ;

// struct definition

struct S1 {} s1 = {} ;

</pre>

<p>
Type alias definition looks like:
</p>

<pre>

type <i>name</i> = Type ;

</pre>

<h3>Structures</h3>

<p>
Structure definition looks like:
</p>

<pre>

struct <i>name</i>
 {
  Type<sub>1</sub> <i>field_name<sub>1</sub></i> [ = Expression<sub>1</sub> ] ;

  ....

  Type<sub>n</sub> <i>field_name<sub>n</sub></i> [ = Expression<sub>n</sub> ] ;
 };

</pre>

<p>
Each structure has a name and a list of fields. Each field has a name, a type and an optional
default value, determined by an expression. It also defines a scope. This scope can be extended.
A structure definition can also defines a scope type aliases, structures and constants:
</p>

<pre>

struct S
 {
  struct T {};

  const ulen Len = 10 ;

  type List = T[Len] ;

  const List list = {} ;
 };

</pre>

<h3>Constants</h3>

<p>
Constant definition looks like:
</p>

<pre>

Type <i>name</i> = Expression ; 

</pre>

<p>
This definition defines the constant with the given name in the current scope with the given type
and value, determined by the expression.
</p>

<p>
Constant can be defined inside a structure definiton with the keyword <b>const</b>:
</p>

<pre>

struct S
 {
  const Type <i>name</i> = Expression ; 
 };

</pre>

<p>
Without <b>const</b> it would be a member definition.
</p>

<h3>Literals</h3>

<p>Universal null literal:</p>

<pre>

null

</pre>

<p>Decimal literals:</p>

<pre>

1234567890

</pre>

<p>Hexadecimal literals:</p>

<pre>

1234567890h
0abcdefH
0ABCDEFh

</pre>

<p>Binary literals:</p>

<pre>

1001B
1010b

</pre>

<p>Simple string literals:</p>

<pre>

'simple text'

</pre>

<p>Advanced string literals process usual back-slash special character representations:</p>

<pre>

"advanced text\n"
"\b\t\n\v\f\r"

</pre>

<p>IP literals:</p>

<pre>

192.168.1.10

</pre>

<h3>Expressions</h3>

<p>
Expressions are used to assign a value to a constant (including implicitly defined constants, like
array lengths or default structure member values). Expression can be scalar or compound.
Scalar expressions can be used to assign a value of a basic type, compound &mdash; for structures
and arrays. A special class of scalar expressions defines a pointer values.
</p>

<p>
The most important thing about expressions: they are calculated in the context of the resulting type.
Resulting type of expression is the type of constant this expression is used to assign a value to.
</p>

<p>
Compound expression is a list of expressions, or a list of named expressions:
</p>

<pre>

struct S
 {
  int a;
  int b;
  int c = 10 ;
 };

S s1 = {} ; // empty list, a = 0, b = 0, c = 10

S s2 = { 1 , 2 } ; // partial list, a = 1, b = 2, c = 10

S s3 = { 1 , 2 , 3 } ; // full list, a = 1, b = 2, c = 3

S s4 = { .a = 1 } ; // named list, a = 1, b = 0, c = 10 

</pre>

<p>
Named lists can be used as a value modifier:
</p>

<pre>

struct S
 {
  int a;
  int b;
  int c = 10 ;
 };

S s = { 1 , 2 , 3 } ;

S s1 = s { .a = -1 } ; // a = -1, b = 2, c = 3 

S s2 = { 1 , 2 } { .a = -1 } ; // a = -1, b = 2, c = 10 

</pre>

<p>
Usual arithmetic operations <b>+a, -a, a+b, a-b, a*b, a/b, a%b</b> can be used with integral values.
Operands are evaluated to the resulting integral type and operation is performed with this value types.
Additive integral operations and multiplication are operations in the correspondent residual ring.
Division operations follows <b>C</b> convension:
</p>

<pre>

a == (a/b)*b+(a%b)

sign( a%b ) == sign(a)

abs( a%b ) < abs(b)

</pre>

<p>
Signed intergal types use 2'd complementary representation. Integral literal conversion performes
by the module reduction. 
</p>

<p>
There is a special integral cast operation:
</p>

<pre>

int x = uint8( 12345 ) ;

</pre>

<p>
The expression inside a cast expression is evaluated to the resulting cast type.
</p>

<p>
<b>ip</b> constant can be received only from an IP literal.
</p>

<p>
<b>text</b> constant can be received from a text literal, IP literals, integral literals and from
a binary plus operator.
</p>

<pre>

text a = "string" ; // string

text b = 1.2.3.4 ; // 1.2.3.4

text c = 100000000000000000000 ; // 100000000000000000000

text d = "string"+2222222222222222222222 ; // string2222222222222222222222

</pre>

<p>
Integral literals are converted as is. IP literals are converted to IP address first.
</p>

<p>
<b>null</b> is a "universal null".
</p>

<pre>

int a = null ;

struct S
 {
  int a;
  int b;
  int c = 10 ; 
 };

S s = null ; // a = 0, b = 0, c = 0

</pre>

<p>
Pointers can be used the same way as in <b>C</b>.
</p>

<pre>

int a = 10 ;

int * pa = &amp;a ;

int b = *pa ; // 10

int[10] c = {0,1,2,3,4,5,6,7,8,9} ;

int * pc = c+5 ;

int d = *pc ; // 5
int e = pc[2] ; // 7

int l = pc - c ; // 5

</pre>

<pre>

struct S
 {
  int a;
  int b;
 };

S s = { 1 , 2 } ;

S * ps = &amp;s ;

int a = ps->a ;
int b = (*ps).b ;

</pre>

<h2>DDL implementation</h2>

<p>
The directory <b>ddl</b> contains a <b>DDL</b> implementaion. It is contained in the namespace <b>DDL</b>.
To process a <b>DDL</b> text there are two main classes: <b>TextEngine</b> and <b>FileEngine</b>.
</p>

<pre>

class <span class="Att">TextEngine</span> : NoCopy
 {
   ....

  public: 
   
   TextEngine(PrintBase &msg,StrLen text,StrLen pretext={});
   
   ~TextEngine();
   
   EngineResult process();
 };

</pre>

<p>
The first constructor argument is a stream, where error messages will be printed.
The second is a text to be processed. 
The third is a "pretext". It is included before the <b>text</b>.
To do the job use the method <b>process()</b>.
This class does not support a file inclusion.
</p>

<pre>

template &lt;class FileName,class FileText&gt;
class <span class="Att">FileEngine</span> : NoCopy
 {
   ....

  public:
   
   static const ulen DefaultMaxFiles = 1000 ;
   static const ulen DefaultMaxIncludes = 100 ;
   static const ulen DefaultMaxFileLen = MaxULen ;
  
   explicit FileEngine(PrintBase &msg,ulen mem_cap=MaxULen,
                                      ulen max_files=DefaultMaxFiles,
                                      ulen max_inc=DefaultMaxIncludes,
                                      ulen max_file_len=DefaultMaxFileLen);
   
   ~FileEngine();
   
   EngineResult process(StrLen file_name,StrLen pretext={});
 };

</pre>

<p>
<b>FileEngine</b> can process a complex input from a real or a virtual file system.
Two template parameters controls the file name processing and the file name to the file content mapping.
The first constructor argument is a error report stream. Other are different engine limits.
The method <b>process()</b> does the job. The first argument is a file name with a <b>DDL</b> text. Additional
files may be opened during include operations.
The second argument is a "pretext". It is included before the file text.
</p>

<p>
On <b>HCore</b> targets ou can use <b>FileToMem</b> as the <b>FileText</b> template parameter.
</p>

<p>
The class <b>FileName</b> is a default implementaion of the <b>FileName</b> template parameter.
</p>

<h3>EngineResult and Map</h3>

<pre>

struct <span class="Att">EngineResult</span>
 {
  Eval *eval;
  BodyNode *body;
  
  bool operator ! () const { return !eval; }

  ....
 };

</pre>

<p>
<b>EngineResult</b> is null in case of error. You may check it using <b>operator !</b>.
</p>

<p>
You can print <b>Eval</b> object to see the result of processing. This object contains a 
complete processing outcome. But for something more usefull, you may use the class <b>Map</b> 
to create a result representation in a single memory block.
</p>

<pre>

class <span class="Att">Map</span> : NoCopy
 {
   ....

  public:
   
   Map(Eval *eval,BodyNode *body);
   
   ~Map();
   
   ulen getLen() const { return total; }
   
   void operator () (void *mem);
   
   void * findConst(StrLen name,const TypeDesc &desc);
 };

</pre>

<p>
When you create a <b>Map</b> object, it is ready to map data into memory. The method <b>getLen()</b>
returns the required memory block length. Once you allocate it, the <b>operator ()</b> can be used
to perform the data mapping. There is a simple helper class <b>MapBase</b> to do these operations.
</p>

<pre>
class <span class="Att">MapBase</span> : NoCopy
 {
   void *mem;
  
  public:
   
   explicit MapBase(Map &map)
    {
     mem=MemAlloc(map.getLen());
     
     map(mem);
    }
   
   ~MapBase()
    {
     MemFree(mem);
    }
 };
</pre>

<p>
Once the mapping is done, you can retrieve the pointer to the particular constant using
the method <b>findConst()</b>. This method takes the constant name and the <b>TypeDesc</b> reference.
There is a set of types, derived from the <b>TypeDesc</b> type, which are used to define
a constant type in a way, compatible with the <b>DDL</b> type system. 
Some fields of these types are mutable, their values are assigned by the <b>findConst()</b>.
Null pointer is returned in case of error.
</p>

<pre>
/* consts */

enum <span class="Att">TypeTag</span>
 {
  TypeTag_sint8,
  TypeTag_uint8,
  
  TypeTag_sint16,
  TypeTag_uint16,
  
  TypeTag_sint32,
  TypeTag_uint32,
  
  TypeTag_sint64,
  TypeTag_uint64,
  
  TypeTag_text,
  TypeTag_ip,
  
  TypeTag_ptr,
  TypeTag_array,
  TypeTag_array_len,
  TypeTag_array_getlen,
  
  TypeTag_struct,
  
  // size-less types 
  
  TypeTag_sint = .... ,
  TypeTag_uint = .... ,
  TypeTag_ulen = .... ,
   
  TypeTag_int = TypeTag_sint 
 };

/* struct TypeDesc_basic */

struct <span class="Att">TypeDesc_basic</span> : TypeDesc
 {
  explicit TypeDesc_basic(TypeTag tag_) { tag=tag_; }
 };

/* struct TypeDesc_ptr */

struct <span class="Att">TypeDesc_ptr</span> : TypeDesc
 {
  const TypeDesc &amp;type;
  
  explicit TypeDesc_ptr(const TypeDesc &amp;type_) : type(type_) { tag=TypeTag_ptr; }
 };

/* struct TypeDesc_array */

struct <span class="Att">TypeDesc_array</span> : TypeDesc
 {
  const TypeDesc &amp;type;
  
  explicit TypeDesc_array(const TypeDesc &amp;type_) : type(type_) { tag=TypeTag_array; }
 };

/* struct TypeDesc_array_len */

struct <span class="Att">TypeDesc_array_len</span> : TypeDesc
 {
  const TypeDesc &amp;type;
  ulen len;
  
  TypeDesc_array_len(const TypeDesc &amp;type_,ulen len_) : type(type_),len(len_) { tag=TypeTag_array_len; }
 };

/* struct TypeDesc_array_getlen */

struct <span class="Att">TypeDesc_array_getlen</span> : TypeDesc
 {
  const TypeDesc &amp;type;
  mutable ulen len;
  
  explicit TypeDesc_array_getlen(const TypeDesc &amp;type_) : type(type_),len(0) { tag=TypeTag_array_getlen; }
 };

/* struct TypeDesc_struct&lt;ulen FieldCount&gt; */

template &lt;ulen FieldCount&gt;
struct <span class="Att">TypeDesc_struct</span> : TypeDesc_struct_base
 {
  Field buf[FieldCount];
  
  template &lt;class ... TT&gt;
  TypeDesc_struct(const TT &amp; ... tt) : TypeDesc_struct_base(buf),buf{tt...} { tag=TypeTag_struct; field_count=FieldCount; }
 };

</pre>

<p>
<b>TypeDesc_basic</b> designates a basic type, it is used with the following tags:
</p>

<pre>

TypeTag_sint8
TypeTag_uint8
  
TypeTag_sint16
TypeTag_uint16
  
TypeTag_sint32
TypeTag_uint32
  
TypeTag_sint64
TypeTag_uint64
  
TypeTag_text
TypeTag_ip

</pre>

<p>
<b>TypeDesc_ptr</b> designates a pointer type (<b>T *</b>).
</p>

<p>
<b>TypeDesc_array</b> designates an array type with implicit length (<b>T []</b>).
</p>

<p>
<b>TypeDesc_array_len</b> designates an array type with explicit length (<b>T [len]</b>).
</p>

<p>
<b>TypeDesc_array_getlen</b> designates an array type with explicit length (<b>T [len]</b>), but this length
is extracted from data. The field <b>len</b> is filled by the <b>findConst()</b> method.
</p>

<p>
<b>TypeDesc_struct</b> designates a struct type.
</p>

<p>
The actual data access is performed by the class <b>DataPtr</b>.
</p>

<pre>
struct <span class="Att">DataPtr</span>
 {
  void *ptr;
  
  // constructors
  
  DataPtr() : ptr(0) {}
  
  DataPtr(void *ptr_) : ptr(ptr_) {}
  
  // methods
  
  bool operator ! () const { return !ptr; }
  
  struct Proxy
   {
    void *ptr;
    
    Proxy(void *ptr_) : ptr(ptr_) {}
    
    template &lt;class T&gt; 
    operator T() const;
   };
  
  Proxy operator * () const { return ptr; }
  
  DataPtr elem(const TypeDesc_struct_base &amp;desc,ulen ind) const;
  
  DataPtr select(const TypeDesc_struct_base &amp;desc,ulen ind) const;
  
  struct ProxyRange
   {
    void *ptr;
    ulen len;
    
    ProxyRange(void *ptr_,ulen len_) : ptr(ptr_),len(len_) {}
    
    template &lt;class T&gt; 
    operator PtrLen&lt;T&gt;() const;
   };
  
  ProxyRange range(ulen len) const { return ProxyRange(ptr,len); }
 };
</pre>

<p>
The object of this type serves as an "universal" constant pointer. It should be initialized by the value, returned 
by the <b>findConst()</b> method. Then if the type of the constant is simple, you can retrieve the value using 
<b>operator *</b>.
</p>

<pre>

DDL::TypeDesc_basic type(DDL::TypeTag_int);

DDL::Map map(....);

DDL::DataPtr ptr=map.findConst("name",type);

if( !ptr )
  {
   // no such constant

   ....
  }
else
  {
   DDL::imp_int value=*ptr;
  }

</pre>

<p>
The following types must be used:
</p>

<pre>

imp_sint8   for  sint8
imp_uint8   for  uint8
imp_sint16  for  sint16
imp_uint16  for  uint16
imp_sint32  for  sint32 
imp_uint32  for  uint32
imp_sint64  for  sint64
imp_uint64  for  uint64

imp_sint    for  sint
imp_uint    for  uint

imp_ulen    for  ulen
imp_int     for  int

StrLen      for  text
imp_uint32  for  ip

ArrayPtr    for  T[]  where

struct <span class="Att">ArrayPtr</span>
 {
  void *ptr;
  ulen len;

  ArrayPtr() : ptr(0),len(0) {}
  
  ArrayPtr(void *ptr_,ulen len_) : ptr(ptr_),len(len_) {}
 };

</pre>

<p>
For a pointer type use the <b>DataPtr</b> type.
</p>

<p>
For an array type with implicit length use the <b>PtrLen&lt;T&gt;</b> type. You cannot do it, if the 
<b>T</b> is a structure type.
</p>

<p>
Two methods <b>elem()</b> and <b>select()</b> support working with a structure type.
</p>

<p>
<b>select()</b> returns the pointer to the structure field, <b>ind</b> is a field index.  
</p>

<p>
<b>elem()</b> can be used to move a pointer to a strucrture, if the element is a member of an array.
<b>ind</b> is an element index after the current element.
</p>

<p>
For arrays with an explicit length, <b>DataPtr</b> points to the first element. 
</p>

<p>
See <b>tools/ParserGen/DataMap.h</b> and <b>tools/ParserGen/DataMap.cpp</b> for an example
of data mapping.
</p>

</body>

</html>

