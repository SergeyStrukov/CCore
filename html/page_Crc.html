<!--
/* page_Crc.html */
//----------------------------------------------------------------------------------------
//
//  Project: CCore 1.02
//
//  License: Boost Software License - Version 1.0 - August 17th, 2003 
//
//            see http://www.boost.org/LICENSE_1_0.txt or the local copy
//
//  Copyright (c) 2012 Sergey Strukov. All rights reserved.
//
//----------------------------------------------------------------------------------------
-->

<!DOCTYPE html>
<html>

<head>

 <title>CCore -> Crc</title>

 <link href="CCore.css" rel="stylesheet" type="text/css">

</head>

<body>

<h2>Crc</h2>

<p class="Files">Files <b>CCore/inc/Crc.h</b> <b>CCore/src/Crc.cpp</b></p>

<p>
There are three Crc classes: <b>Crc16</b>, <b>Crc24</b>, <b>Crc32</b> to caculate Crc value of a byte sequence.
Technically, Crc is a polynomial division reminder. It is used to control sudden errors in a byte stream.
There are 3 popular and standard such Crc, widely used in IT. We call them Crc16, Crc24 and Crc32 by the number of output
bits. In practical applications they are used with some adjustments, i.e. the byte sequence is prepended with some start
sequence in order to calculate its Crc.
</p>

<p>
<b>CCore</b> uses the generic implementation of Crc based on lookup tables. So <b>Crc16</b>, <b>Crc24</b>, <b>Crc32</b> are
instantinations of the generic <b>CrcAccumulator</b> class, parametrized by the <b>Algorithm Package</b>s
<b>AlgoCrc16, AlgoCrc24, AlgoCrc32</b>:
</p>

<pre>

/* struct AlgoCrc16 */ 

struct <span class="att">AlgoCrc16</span>
 {
  typedef uint16 ResultType;
  
  typedef uint8 DataType;
  
  static ResultType Add(ResultType crc,DataType data);
   
  static ResultType Mask(ResultType crc);
   
  static const uint16 Table[256];
 };
 
/* struct AlgoCrc24 */ 

struct <span class="att">AlgoCrc24</span>
 {
  typedef uint32 ResultType;
  
  typedef uint8 DataType;
  
  static ResultType Add(ResultType crc,DataType data);
   
  static ResultType Mask(ResultType crc);
   
  static const uint32 Table[256];
 };
 
/* struct AlgoCrc32 */ 

struct <span class="att">AlgoCrc32</span>
 {
  typedef uint32 ResultType;
  
  typedef uint8 DataType;
  
  static ResultType Add(ResultType crc,DataType data);
   
  static ResultType Mask(ResultType crc);
  
  static const uint32 Table[256];
 };

</pre>

<p>
<b>CrcAccumulator</b> is an "accumulator" class:
</p>

<pre>
template &lt;class Algo&gt;
class CrcAccumulator
 {
  public:
  
   typedef typename Algo::ResultType ResultType;
   
   typedef typename Algo::DataType DataType;
   
  private:
  
   ResultType crc;
   
  public:
  
   explicit CrcAccumulator(ResultType crc_=1);
   
   operator ResultType() const { return crc; }
   
   void add(DataType data);
   
   template &lt;class R&gt;
   void addRange(R r); 
 };

/* types */  

typedef CrcAccumulator&lt;AlgoCrc16&gt; Crc16;
 
typedef CrcAccumulator&lt;AlgoCrc24&gt; Crc24;

typedef CrcAccumulator&lt;AlgoCrc32&gt; Crc32;

</pre>

<p>
You can built the result by "feeding" the object of this class by pieces of data. You can put bytes one-by-one or
add by ranges. The type <b>R</b> in the method <b>addRange()</b> must be a <b>Cursor</b> over a piece of data.
By default, <b>CrcAccumulator</b> starts from the value 1.
</p>

<pre>

PtrLen&lt;uint8&gt; data=....;

Crc32 crc;

crc.addRange(data);

uint32 result=crc;

</pre>

</body>

</html>

