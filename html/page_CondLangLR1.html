<!--
/* page_CondLangLR1.html */
//----------------------------------------------------------------------------------------
//
//  Project: CCore 1.07
//
//  License: Boost Software License - Version 1.0 - August 17th, 2003 
//
//            see http://www.boost.org/LICENSE_1_0.txt or the local copy
//
//  Copyright (c) 2013 Sergey Strukov. All rights reserved.
//
//----------------------------------------------------------------------------------------
-->

<!DOCTYPE html>
<html>

<head>

 <title>CCore -> CondLangLR1</title>

 <link href="CCore.css" rel="stylesheet" type="text/css">

</head>

<body>

<h2>CondLangLR1</h2>

<p>
This utility generates LR1 parsing state machine for the given LR1 language.
The language is define using the conditional recursive grammar.
</p>

<pre>

CondLangLR1.exe &lt;file-name&gt;

</pre>

<p>
The only command-line argument is the language file name. If the file name has no extension, <b>.lang</b> is added.
</p>

<p>
On success two files are generated: <b>.txt</b> file and <b>.ddl</b> file.
They have the same name as the input file and located in the same directory. 
<b>.txt</b> file contains processing information in a readable form.
<b>.ddl</b> file contains state machine definition in <b>DDL2</b> format.
The file <b>LangType.ddl</b> in <b>CCORE_ROOT/tools/CondLangLR1</b> contains required <b>DDL2</b> type definitions.
</p>

<p>
On failure the only <b>.bad.txt</b> file is generated. You can examine this file to understand, why
the input is not an LR1 language and try to fix it.
</p>

<h3>AMP</h3>

<p>
Below is the file <b>AMP.lang</b> with the definition of the AMP language.
</p>

<pre>
/* AMP.lang */

! EXPR : A , M , P
 {
  x               : opVar  = P

  ( EXPR )        : opBra  = P

  EXPR + EXPR.a   : if( a&gt;=M ) opAdd  = A

  EXPR.a * EXPR.b : if( a&gt;=P & b&gt;=M ) opMul  = M
 }

</pre>

<p>
You may see the output for this language in the directory <b>CCORE_ROOT/tools/CondLangLR1/AMP</b>.
</p>

<h2>Conditional recursive grammar</h2>

<p>
Conditional recursive grammar is an advanced version of <a href="page_LangLR1.html#lang">context-free grammer</a>. To define a language by
a uniquely decoded grammar it is often you have to introduce extra non-terminals. For example, you can
define <b>AMP</b> language by the following grammar:
</p>

<pre>

! EXPR
 {
  x               : opVar

  ( EXPR )        : opBra

  EXPR + EXPR     : opAdd

  EXPR * EXPR     : opMul
 }

</pre>

<p>
but this grammer is not uniquely decoded. To make it such you may introduce extra non-terminals:
</p>

<pre>

! A
 {
  M     : cast_A
  A + M : opAdd
 }
 
M
 {
  P     : cast_M
  P * M : opMul
 }
 
P
 {
  x     : opVar
  ( A ) : opBra 
 } 

</pre>

<p>
Conditional grammar is an alternative way. Instead defining of new non-terminals, we introduce
"kinds". Kind is a property of a non-terminal production. 
</p>

<pre>

! EXPR : A , M , P
 {
  x               : opVar  = P

  ( EXPR )        : opBra  = P

  EXPR + EXPR.a   : if( a&gt;=M ) opAdd  = A

  EXPR.a * EXPR.b : if( a&gt;=P & b&gt;=M ) opMul  = M
 }

</pre>

<p>
Here is the non-terminal <b>EXPR</b> with three associated kinds: <b>A</b>, <b>M</b> and <b>P</b>.
When we produce a word of this non-terminal, we assign a kind to it, it is designated by the trailing 
<b>= kind</b> statement. Particular production rule may have an associated condition, 
this condition must be satisfied to apply this rule. For example, the rule <b>opAdd</b> can only be applied
if the kind of the second subexpression (<b>.a</b>) is <b>M</b> or <b>P</b>.
</p>

<p>
Using conditional grammars you avoid rule redundance. You don't need "cast" rules.
The language description becomes also more intuitive.
</p>

<h2>Grammar description</h2>

<p>
We use the term "syntax class" or "synt" for non-terminals. The grammar description consists of synt descriptions.
Each synt has a unique name, it must be a <b>C</b> name. Some synts (usually one) are language synts, the 
resulting language is a union of these synt's productions. These synts are prefixed with the character <b>!</b>.
A synt description starts with the synt name, optionally preceedded by the character <b>!</b>.
If the synt has associated kinds, the synt description continues with the sign <b>:</b> and following
comma separated kind names. Kind names must be <b>C</b> names and must be unique for each synt. At least 
one kind must be provided.
Then production rule decriptions follows, enclosed in the figure brackets.
</p>

<pre>

LANG-DESCRIPTION  <b>=</b>  SYNT-DESCRIPTION<sub>1</sub> SYNT-DESCRIPTION<sub>2</sub> ... SYNT-DESCRIPTION<sub>n</sub>

SYNT-DESCRIPTION  <b>=</b>  !<sup>opt</sup> SyntName KIND-DESCRIPTION<sup>opt</sup> { RULES-DESCRIPTION }

KIND-DESCRIPTION  <b>=</b>  : KindName<sub>1</sub> , KindName<sub>2</sub> , ... , KindName<sub>n</sub>

</pre>

<p>
Kinds of a same synt are considered as linear ordered. The orded is defined by the appearance, i.g. 
a kind is less than another kind, if it appears early in the kinds list.  
</p>

<pre>

KindName<sub>1</sub> < KindName<sub>2</sub> < ... < KindName<sub>n</sub>

</pre>

<p>
A kind has an associated numeric value, which is the index in the kinds list.
</p>

<p>
Rules description is a sequence of rule descriptions.
</p>

<pre>

RULES-DESCRIPTION  <b>=</b>  RULE-DESCRIPTION<sub>1</sub> RULE-DESCRIPTION<sub>2</sub> ... RULE-DESCRIPTION<sub>n</sub>

</pre>

<p>
Each rule description starts from the rule elements sequence. During this part of the input the text is parsed by 
words, divided by space characters. To terminate it you must enter either <b>:</b> to finish the 
rule elements sequence or <b>}</b> to close the rule descriptions, surrounded by at least one 
space character before and after.
</p>

<pre>

RULE-DESCRIPTION  <b>=</b>  RULE-ELEMENTS : RULE_COND<sup>opt</sup> RuleName RULE_KIND<sup>opt</sup>

RULE_KIND         <b>=</b>  = KindName

</pre>

<p>
Each rule has a rule name, it must be either a <b>C</b> name or a compound <b>C</b> name, concatenated from several
<b>C</b> names by the character <b>@</b>, and must be unique for each synt. If the synt has kinds, 
a rule kind must be given, otherwise it must not present.
</p>

<pre>

RULE-ELEMENTS <b>=</b> ELEMENT<sub>1</sub> ... ELEMENT<sub>n</sub>

</pre>

<p>
Rule elements part is parsed on words, separated by space characters. Each word is a 
sequence of printable non-space characters. The word can be a synt name or an atom name. 
Synt name may have a dot-suffix with variable name. Everything which is not a synt name 
is considered as an atom name. Language atom set is defined implicitly by collecting atom names from
rule definitions.
</p>

<pre>

ELEMENT-SYNT <b>=</b> SyntName
               SyntName.VariableName

</pre>

<p>
Two one-character words <b>}</b> and <b>:</b> cannot be used to define an atom. But you can introduce an atom 
with such name using the character <b>`</b> as the prefix, i.e. <b>`}</b> and <b>`:</b> 
are considered as atom names, but modified to the names <b>}</b> and <b>:</b>. 
Also <b>``}</b> is modified to <b>`}</b>, <b>```}</b> to <b>``}</b> and so on.
</p>

<p>
A rule may have an associated rule condition of the form:
</p>

<pre>

RULE-COND <b>=</b> if ( COND-EXPR )

</pre>

<p>
A condition expression is an expression, built from prime expressions using the logical operations
<b>&</b> (logical AND), <b>|</b> (logical OR) and <b>!</b> (logical NOT). <b>&</b> has a higher priority 
than <b>|</b>. Brackets can be used to specify the order of evaluation.
</p>

<p>
Prime expressions are comparision expressions:
</p>

<pre>

  Name<sub>1</sub> == Name<sub>2</sub>
  Name<sub>1</sub> != Name<sub>2</sub>
  Name<sub>1</sub> < Name<sub>2</sub> 
  Name<sub>1</sub> <= Name<sub>2</sub>
  Name<sub>1</sub> > Name<sub>2</sub> 
  Name<sub>1</sub> >= Name<sub>2</sub>

</pre>

<p>
Each name either a variable name or a kind name. At least one name must be a variable name. 
Variables are introduced in the rule element list as the dot-suffix of the synt name. For example,
</p>

<pre>

  EXPR.a * EXPR.b : if( a&gt;=P & b&gt;=M ) opMul  = M

</pre>

<p>
here two variables were introduced: <b>a</b> and <b>b</b>. Each of them designate the kind of 
the correspondent synt production. If the name is a kind name, the corespondent kind is looked-up among the
kinds of the synt, the other name is a variable of. I.e. in the example above <b>P</b> is looked-up among
the kinds of the synt <b>EXPR</b>. Kinds are compared using they numeric values.
</p>

<h2>DDL output</h2>

<p>
<b>DDL</b> output consists of the full description of the language and the LR1 parsing state machine.
</p>

<h2>txt output</h2>

</body>

</html>

