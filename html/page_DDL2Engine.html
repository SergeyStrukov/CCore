<!--
/* page_DDL2Engine.html */
//----------------------------------------------------------------------------------------
//
//  Project: CCore 1.07
//
//  License: Boost Software License - Version 1.0 - August 17th, 2003 
//
//            see http://www.boost.org/LICENSE_1_0.txt or the local copy
//
//  Copyright (c) 2013 Sergey Strukov. All rights reserved.
//
//----------------------------------------------------------------------------------------
-->

<!DOCTYPE html>
<html>

<head>

 <title>CCore -> DDL2Engine</title>

 <link href="CCore.css" rel="stylesheet" type="text/css">

</head>

<body>

<h2>DDL2Engine</h2>

<p class="Files">Files <b>CCore/inc/ddl2/DDL2Engine.h</b> <b>CCore/src/ddl2/DDL2Engine.cpp</b></p>

<p class="Files">Files <b>CCore/inc/ddl2/DDL2Map.h</b> <b>CCore/src/ddl2/DDL2Map.cpp</b></p>

<p class="Files">Files <b>CCore/inc/ddl2/DDL2TypedMap.h</b> <b>CCore/src/ddl2/DDL2TypeMap.cpp</b></p>

<p class="Files">Subfolders <b>CCore/inc/ddl2</b> <b>CCore/src/ddl2</b></p>

<h2>DDL2 implementation</h2>

<p>
The directory <b>ddl2</b> contains a <b>DDL2</b> implementation. It is contained in the namespace <b>DDL2</b>.
To process a <b>DDL2</b> source there are two main classes: <b>TextEngine</b> and <b>FileEngine</b>.
The most of content of this directory is a <b>DDL2</b> parser implementation and not needed to be used directly.
</p>

<p>
Engines return the result of processing of the following type:
</p>

<pre>

struct <span class="Att">EngineResult</span>
 {
  EvalResult *eval;
  BodyNode *body;
  
  EngineResult() : eval(0),body(0) {}
  
  EngineResult(NothingType) : EngineResult() {}
  
  EngineResult(EvalResult *eval_,BodyNode *body_) : eval(eval_),body(body_) {}
  
  EvalResult * operator + () const { return eval; }
  
  bool operator ! () const { return !eval; }
 };

</pre>

<p>
It's a simple lightweight data structure with two fields. <b>eval</b> is a pointer to the <b>EvalResult</b>
object, this object contains constant value table. <b>body</b> is a pointer to the root body node, this node
represents the <b>DDL2</b> source. Walking from this node you can examine the whole source content.
If the processing has failed, the result is null.
</p>

<pre>

class <span class="Att">TextEngine</span> : NoCopy
 {
   ....

  public: 
   
   TextEngine(PrintBase &msg,StrLen text,StrLen pretext={});
   
   ~TextEngine();
   
   EngineResult process();
 };

</pre>

<p>
The first constructor argument is a stream, where error messages will be printed to.
The second is a text to be processed. 
The third is a "pretext". It is included before the <b>text</b>.
To do the job use the method <b>process()</b>.
This engine does not support the file inclusion.
This engine is one-shoot, it should be used to process one input once.
Result objects life-time is ended with the engine life-time end.
</p>

<pre>

template &lt;class FileName,class FileText&gt;
class <span class="Att">FileEngine</span> : NoCopy
 {
   ....

  public:
   
   static const ulen DefaultMaxFiles = 1000 ;
   static const ulen DefaultMaxIncludes = 100 ;
   static const ulen DefaultMaxFileLen = MaxULen ;
  
   explicit FileEngine(PrintBase &msg,ulen mem_cap=MaxULen,
                                      ulen max_files=DefaultMaxFiles,
                                      ulen max_inc=DefaultMaxIncludes,
                                      ulen max_file_len=DefaultMaxFileLen);
   
   ~FileEngine();

   EngineResult process(StrLen file_name,StrLen pretext);

   EngineResult process(StrLen file_name);
 };

</pre>

<p>
<b>FileEngine</b> can process a complex input from a real or a virtual file system.
Two template parameters controls the file name processing and the file name to the file content mapping.
The first constructor argument is a error report stream. Others are different engine limits.
The method <b>process()</b> does the job. The first argument is a file name with a <b>DDL2</b> text. 
Additional files may be opened during include operations.
The second argument is a "pretext". It is included before the file text.
The method <b>process()</b> can be called multiple times for different files. Loaded files are cached.
Result objects life-time is ended with the next call of <b>process()</b>, or with the engine life-time end.
</p>

<p>
The first template parameter <b>FileName</b> is responsible for the file name manipulation.
There is a <a href="page_FileName.html">default implementation of this class</a>. It is recommended
to use this implementation. Any other implementation must be interface compartible with this particular one.
</p>

<p>
The second template parameter must do the same thing as the <b>FileToMem</b> class, i.g. load
the file content into the memory.
</p>

<pre>

class <span class="Att">FileText</span> : NoCopy
 {
  public:

   FileText(StrLen file_name,ulen max_len);

   ~FileText();

   const uint8 * getPtr() const;

   ulen getLen() const;
 };

</pre>

<p>
On <b>HCore</b> targets you can use the class <a href="page_FileToMem.html"><b>FileToMem</b></a> as the <b>FileText</b> template parameter.
</p>

<h3>EvalResult</h3>

<pre>

struct <span class="Att">EvalResult</span> : NoCopy
 {
  DynArray&lt;ConstResult&gt; const_table;
  DynArray&lt;LenResult&gt; len_table;
  
  EvalResult() {}
  
  void erase();
  
  ulen_type getLen(const LenNode &amp;node) const;
 };

</pre>

<p>
<b>EvalResult</b> contains two tables. Each constant, defined in the <b>DDL2</b> source, 
has an associated <b>ConstNode</b> object. This object contains the field <b>index</b>.
The entry in the <b>const_table</b> with this index contains the calculated value of the constant.
Each array type with an explicit array length has an associated <b>LenNode</b> object. 
This object contains the field <b>index</b>.
The entry in the <b>len_table</b> with this index contains the calculated value of the length.
</p>

<pre>

struct <span class="Att">ConstResult</span> : NoThrowFlagsBase
 {
  TypeNode *type;
  ConstNode *node;
  Value value;
  
  void set(ConstNode *node,const Value &amp;value);

  struct PrintOptType
   {
    EvalResult &amp;result;
    
    PrintOptType(EvalResult &amp;result_) : result(result_) {}
   };
  
  template &lt;class P&gt;
  void print(P &amp;out,PrintOptType opt) const;
 };

</pre>

<p>
<b>ConstResult</b> contains three fields. <b>type</b> is a <b>TypeNode</b> pointer,
<b>node</b> is a <b>ConstNode</b> pointer, <b>value</b> is the calculated constant value.
This class is printable. To print you must provide the option, bounded to the original 
<b>EvalResult</b> object. 
</p>

<pre>

struct <span class="Att">LenResult</span> : NoThrowFlagsBase
 {
  LenNode *node;
  ulen_type value;
  
  void set(LenNode *node,ulen_type value);
 
  template &lt;class P&gt;
  void print(P &out) const;
 };

</pre>

<p>
<b>LenResult</b> contains two fields. <b>node</b> is a <b>LenNode</b> pointer,
<b>value</b> is the calculated length value.
</p>

<pre>

struct <span class="Att">LenNode</span>
 {
  ....

  ulen index;
 };

struct <span class="Att">ConstNode</span>
 {
  ....

  ScopeNode *parent;
  ulen depth;

  NameIdNode name;

  ulen index;
 };

struct <span class="Att">ScopeNode</span>
 {
  ....

  ScopeNode *parent;
  
  NameIdNode name;
 };

struct <span class="Att">NameIdNode</span>
 {
  ....

  PosName name;
  
  StrLen getStr() const { return name.str; }
 };

</pre>

<p>
All <b>LenNode</b>s are zero-based indexed. The correspondent index is assigned to the <b>index</b> field.
</p>

<p>
All <b>ConstNode</b>s are zero-based indexed. The correspondent index is assigned to the <b>index</b> field.
<b>ConstNode</b> contains also the filed <b>name</b> with its name and the field <b>parent</b> with the
pointer to the <b>ScopeNode</b> which it belongs to. <b>depth</b> is the scope depth. 
</p>

<p>
<b>ScopeNode</b> has the field <b>parent</b> with the pointer to the <b>ScopeNode</b> which it belongs to.
It also has the field <b>name</b> with the scope name.
</p>

<p>
<b>NameIdNode</b> has the method <b>getStr()</b>. This method returns the name of the item.
</p>

<pre>

union <span class="Att">Value</span>
 {
  imp_sint8  val_sint8;
  imp_uint8  val_uint8;
  imp_sint16 val_sint16;
  imp_uint16 val_uint16;
  imp_sint32 val_sint32;
  imp_uint32 val_uint32;
  imp_sint64 val_sint64;
  imp_uint64 val_uint64;
  
  imp_sint   val_sint;
  imp_uint   val_uint;
  imp_ulen   val_ulen;
  
  SLen       val_slen;
  Text       val_text;
  IP         val_ip;
  
  Block      val_block;
  Ptr        val_ptr;

  // methods
  
  template &lt;class Type&gt;
  Type get() const;
  
  template &lt;class Type&gt;
  void set(Type val);
 };

</pre>

<p>
<b>Value</b> is a union of different types. The actual member depends on the value type.
You may use <b>get&lt;Type&gt;()</b> and <b>set&lt;Type&gt;()</b> methods to get and set values.
</p>

<p>
To represent integral types <b>imp_XXX</b> are used.
</p>

<pre>

struct imp_XXX
 {
  XXX_integral_type value;

  ....
 };
 
</pre>

<p>
Integral types are: <b>sint8, uint8, ...</b> and <b>sint_type, uint_type, ulen_type</b>.
Last three types are platform-dependent.
</p>

<p>
<b>Text</b> represents <b>text</b> type.
</p>

<pre>

struct <span class="Att">Text</span>
 {
  StrLen str;
  
  // constructors
  
  Text() {}
  
  Text(StrLen str_) : str(str_) {}
  
  // print object
  
  template &lt;class P&gt;
  void print(P &amp;out) const;
 };

</pre>

<p>
<b>IP</b> represents <b>ip</b> type.
</p>

<pre>

struct <span class="Att">IP</span>
 {
  uint8 address[4];
  
  // constructors
  
  IP() : address{} {}
  
  IP(uint8 a1,uint8 a2,uint8 a3,uint8 a4) : address{a1,a2,a3,a4} {}
  
  // methods
  
  uint32 toInt() const;
  
  // print object
  
  template &lt;class P&gt;
  void print(P &amp;out) const;
 };

</pre>

<p>
Non-sclalar values, like structures and arrays, are represented using the type <b>Block</b>.
</p>

<pre>

struct <span class="Att">Block</span>
 {
  PtrLen&lt;Value&gt; data;

  ....
 };

</pre>

<p>
Each member of the range <b>data</b> is the value of the correspondent element of aggregate.
</p>

<p>
Pointer values are represented using the type <b>Ptr</b>.
</p>

<pre>

struct <span class="Att">Ptr</span>
 {
  PtrNode *ptr_node;
  bool null;

  ....
 };

struct <span class="Att">PtrNode</span>
 {
  PtrNode *parent;
  ulen_type index;
  TypeNode *type;

  ....
 };

</pre>

<p>
The field <b>ptr_node</b> points to the <b>PtrNode</b> object. This object contains three fileds.
<b>type</b> describes the type of the pointee constant or sub-constant. 
If this constant is a full constant, then <b>parent</b> is null and <b>index</b> is the <b>ConstNode</b> index.
Otherwise <b>parent</b> represents the aggregate, the sub-constant is an element of, and <b>index</b> 
is the aggregate element index.
</p>

<p>
If the pointer is a null pointer of some type, then the field <b>null</b> is true and <b>ptr_node->type</b> 
describes the type.
</p>

<pre>

struct <span class="Att">TypeNode</span> : NoCopy
 {
  struct Base
   {
    enum Type
     {
      Type_none = 0,
      
      Type_sint,
      Type_uint,
      Type_ulen,
      
      Type_sint8,
      Type_uint8,
      Type_sint16,
      Type_uint16,
      Type_sint32,
      Type_uint32,
      Type_sint64,
      Type_uint64,
      
      Type_text,
      Type_ip,
      
      TypeIntMin=Type_sint,
      TypeIntMax=Type_uint64
     };
    
    Type type;
    
    explicit Base(Type type_) : type(type_) {}
    
    bool isIntegral() const { return type &amp;&amp; type&lt;Type_text ; }
    
    bool isText() const { return type==Type_text; }
    
    bool isIP() const { return type==Type_ip; }
   };
  
  struct Ref
   {
    AnyPtr&lt;AliasNode,StructNode&gt; ptr;

    ....
   };
  
  struct Ptr
   {
    TypeNode *type_node;

    ....
   };
  
  struct PolyPtr
   {
    TypeList *type_list;
    
    ....
   };
  
  struct Array
   {
    TypeNode *type_node;

    ....
   };
  
  struct ArrayLen
   {
    TypeNode *type_node;
    
    LenNode len_node;

    ....
   };
  
  struct Struct
   {
    StructNode *struct_node;

    ....
   };
  
  AnyPtr&lt;Base,Ref,Ptr,PolyPtr,Array,ArrayLen,Struct&gt; ptr;

  .... 
 };

</pre>

<p>
<b>TypeNode</b> is used to represent a type. Different type classes are encoded using <b>AnyPtr</b>
field <b>ptr</b>. For example, to encode the type <b>uint8</b>, <b>ptr</b> is initialized by the
pointer to the object of type <b>TypeNode::Base</b> and the field <b>type</b> of this object
has the value <b>TypeNode::Base::Type_uint8</b>.
</p>

<h2>Map</h2>

<p>
The best way to deal with a <b>DDL2</b> processing result is to map it into a block of memory.
The class <b>Map</b> is to do it.
</p>

<pre>

class <span class="Att">Map</span> : NoCopy
 {
  public:
  
   explicit Map(EngineResult result);
  
   ~Map();
  
   ulen getLen() const;
  
   void operator () (void *mem);
  
   bool findStruct(StrLen name,const TypeDesc &desc); 
  
   void * findConst(StrLen name,const TypeDesc &desc);
 };

</pre>

<p>
You create an object of the type <b>Map</b>, providing the <b>EngineResult</b> as the argument.
Then you have to allocate an aligned block of memory of the length <b>getLen()</b>.
Once it's done, use the overloaded <b>operator ()</b> to map data into this memory block.
You may destroy the <b>Map</b> object and the <b>Engine</b> object at this point and keep the memory block
as long as required. To find a particular constant you can use the method <b>findConst()</b> with 
the constant name and type, encoded using the class <b>TypeDesc</b>. If there is no such constant or 
types mismatch then null is returned. Otherwise the pointer to the mapped value is returned.
</p>

<pre>

/* consts */

enum <span class="Att">TypeTag</span>
 {
  // basic
 
  TypeTag_sint,         // sint_type
  TypeTag_uint,         // uint_type
  TypeTag_ulen,         // ulen_type
  
  TypeTag_sint8,        // sint8
  TypeTag_uint8,        // uint8
  TypeTag_sint16,       // sint16
  TypeTag_uint16,       // uint16
  TypeTag_sint32,       // sint32
  TypeTag_uint32,       // uint32
  TypeTag_sint64,       // sint64
  TypeTag_uint64,       // uint64
  
  TypeTag_text,         // StrLen
  TypeTag_ip,           // uint32
  
  // other
  
  TypeTag_ptr,          // DataPtr
  TypeTag_polyptr,      // TypedDataPtr
  TypeTag_array,        // ArrayPtr -> elem[len]
  TypeTag_array_len,    // elem[len]
  TypeTag_array_getlen, // elem[len]
  
  TypeTag_struct,       // {field1,field2,...}
  
  // none
  
  TypeTag_none,
  
  // int
  
  TypeTag_int = TypeTag_sint 
 };

/* struct TypeDesc */

struct <span class="Att">TypeDesc</span>
 {
  const TypeTag tag;
  
  explicit TypeDesc(const TypeTag tag_) : tag(tag_) {}
 };

</pre>

<p>
<b>TypeDesc</b>, in fact, is a base class for the family of derived classes, designed to represnt different
type classes. The field <b>tag</b> has a describing type value, and derived classes has additional fields
with extra information if required.
</p>

<pre>

struct <span class="Att">TypeDesc_basic</span> : TypeDesc
 {
  explicit TypeDesc_basic(TypeTag tag);
 };

</pre>

<p>
This class is to represent basic types. You provide in constructor argument the correspondent type tag.
</p>

<pre>

struct <span class="Att">TypeDesc_ptr</span> : TypeDesc
 {
  const TypeDesc &amp;type;
  
  explicit TypeDesc_ptr(const TypeDesc &amp;type);
 };

</pre>

<p>
This class reprensents single type pointers. You provide in constructor argument the type descriptor.
</p>

<pre>

template &lt;ulen TypeCount&gt;
struct <span class="Att">TypeDesc_polyptr</span> : TypeDesc_polyptr_base
 {
  const Type buf[TypeCount];
 
  template &lt;class ... TT&gt;
  explicit TypeDesc_polyptr(const TT &amp; ... tt);
 };

</pre>

<p>
This class represents polymorphic pointer types. You provide in constructor arguments a list of type 
desciptors. <b>TypeCount</b> is a number of types.
</p>

<pre>

struct <span class="Att">TypeDesc_array</span> : TypeDesc
 {
  const TypeDesc &amp;type;
  
  explicit TypeDesc_array(const TypeDesc &amp;type);
 };

</pre>

<p>
This class represents array types without length. You provide in constructor argument the element type descriptor.
</p>

<pre>

struct <span class="Att">TypeDesc_array_len</span> : TypeDesc
 {
  const TypeDesc &amp;type;
  const ulen_type len;
  
  TypeDesc_array_len(const TypeDesc &amp;type,ulen_type len);
 };

</pre>

<p>
This class represents array types with a given length. You provide in constructor arguments the element type descriptor
and the array length.
</p>

<pre>

struct <span class="Att">TypeDesc_array_getlen</span> : TypeDesc
 {
  const TypeDesc &type;
  mutable ulen_type len; // filled by getConst() method
  
  explicit TypeDesc_array_getlen(const TypeDesc &amp;type);
 };

</pre>

<p>
This class represents array types with a given length. You provide in constructor argument the element type descriptor.
But the actual array length is filled by the method <b>getConst()</b>.
</p>

<pre>

template &lt;ulen FieldCount&gt;
struct <span class="Att">TypeDesc_struct</span> : TypeDesc_struct_base
 {
  const Field buf[FieldCount];
  
  template &lt;class ... TT&gt;
  explicit TypeDesc_struct(const TT &amp; ... tt);
 };

</pre>

<p>
This class represents structure types. You provide in constructor arguments a list of field type 
desciptors. <b>FieldCount</b> is a number of fields.
</p>

<h3>DataPtr</h3>

<p>
<b>DataPtr</b> is a helper class. It is a "universal pointer" class. You may initialize an object
of this type by the value, returned by the method <b>findConst()</b>.
</p>

<pre>

struct <span class="Att">DataPtr</span>
 {
  void *ptr;
  
  // constructors
  
  DataPtr() : ptr(0) {}
  
  DataPtr(void *ptr_) : ptr(ptr_) {}
  
  // methods
  
  void * operator + () const { return ptr; }
  
  bool operator ! () const { return !ptr; }
  
  struct Proxy
   {
    void *ptr;
    
    Proxy(void *ptr_) : ptr(ptr_) {}
    
    template &lt;class T&gt;
    operator T() const;
   };
  
  Proxy operator * () const { return ptr; }
  
  DataPtr elem(const TypeDesc_struct_base &amp;desc,ulen ind) const;
  
  DataPtr select(const TypeDesc_struct_base &amp;desc,ulen ind) const;
  
  struct ProxyRange
   {
    void *ptr;
    ulen len;
    
    ProxyRange(void *ptr_,ulen len_) : ptr(ptr_),len(len_) {}
    
    template &lt;class T&gt;
    operator PtrLen&lt;T&gt;() const;
   };
  
  ProxyRange range(ulen len) const { return ProxyRange(ptr,len); }
 };

</pre>

<p>
Then you may use this object to get the constant value. Use the <b>operator *</b> and assign the result to
the variable of the proper type. You may find the proper type in the <b>TypeTag</b> definition above.
</p>

<p>
You cannot use the <b>operator *</b>, however, if the constant type is a structure or an array with length.
For structure types you may use the method <b>select()</b> to create a <b>DataPtr</b> to the desired field.
The first argument is a structure type descriptor, the second is the zero-based field index. The desciptor
contains inside some internal values, filled by the method <b>findConst()</b> to locate a particular field.
</p>

<p>
If the constant type is an array without length, you can cast to the type <b>ArrayPtr</b>, but you can also
use the type <b>PtrLen&lt;T&gt;</b>, where the type T corresponds to the element type. Again, you cannot do it,
if the element type is a structure or an array with length.
</p>

<pre>

struct <span class="Att">ArrayPtr</span>
 {
  void *ptr;
  ulen len;

  ArrayPtr() : ptr(0),len(0) {}
  
  ArrayPtr(void *ptr_,ulen len_) : ptr(ptr_),len(len_) {}
 };

</pre>

<h3>TypedDataPtr</h3>

<h2>TypedMap</h2>

</body>

</html>

