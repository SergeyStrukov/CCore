<!--
/* page_Metaphysics.html */
//----------------------------------------------------------------------------------------
//
//  Project: CCore 1.02
//
//  License: Boost Software License - Version 1.0 - August 17th, 2003 
//
//            see http://www.boost.org/LICENSE_1_0.txt or the local copy
//
//  Copyright (c) 2012 Sergey Strukov. All rights reserved.
//
//----------------------------------------------------------------------------------------
-->

<!DOCTYPE html>
<html>

<head>

 <title>CCore -> Metaphisics</title>

 <link href="CCore.css" rel="stylesheet" type="text/css">

</head>

<body>

<h2>Metaphysics of the programming</h2>

<p><i>"Truce is concrete, philosophy is fruitless"</i></p>

<p>
So this page is about fruitlessness.
</p>

<h4>Programming is a mathematical engineering</h4>

<h4>Programming creates a quality, not a quantity</h4>

<p>
Yes, that is the major difference between programming and manufacture. 
The purpose of manufacture is the reproduction of the same thing again and again.
Reproduction of a program can be done instantly by the command <b>copy</b>.
The purpose of the programming is to create something new, unique.
</p>

<p>
So developing a program we create a new quality to make the word better, safer, friendly etc. Or non-quality
to make the work worse, risky, hostile etc. You think it does not concern you, because you get your money and leave?
To where, to another globe, perhaps? To ruin it too? There is no escape. Humanity will learn how to
control the power of the software of will be crashed by it. The power which comes from the command <b>copy</b>.
When you program a quantity, you program a bug quantity.
</p>

<p>
What is the difference between a good programmer and a bad one? Good writes a small, bugless code, bad writes a large, 
fat and bugful. Good spends most time to learn, understand and design a good, structured, mathematically correct code 
and a short time to make it running. Bad is not capable to learn much, deeply understand a subject and tools,
he writes whole novels of poor literature code and then spends most of the working time to make it running. Somehow. 
Good automates its work. It creates software components and tools for repeated tasks. 
Bad is destined to do and hate a manual job.
</p>

<p>
In the software development quality becomes quantity. That is the key point. There is no such thing as a deadline.
There is a goodline. Deadline is a badline. Don't go towards it.
Well developed code grows faster, it incorporates new features
smoothly, it can be well tested, defect fixes are much simpler. The proper strategy in a large-scale development is 
to maintain a high code quality from the start to the finish. Prototype and redesign! Test comprehensively!
Make a reliable software from a reliable software components!
</p>

<h4>Premature generalization is a root of all evil</h4>

<h4>Ugly airplane does not flight</h4>

<p>
Simply like that. Ugly code is a bad code.
</p>

<h4>Everybody means nobody</h4>

<p>
There is no such thing as "good for everybody". "Good for everybody" means "good for nobody".
Design you software components like a good tailor. To make a good suit make it suit.
It means don't develop a universal components, good for an abstract everybody. Know how do you suppose to use it
and make it good for a particular purpose. And thing good for somebody has a change to be good for manybody 
(but not for everybody). You will find many such things in <b>CCore</b>, so don't be surprised.
</p>

<h4>Efficiency is NOT a number of bytes or CPU clocks, it is an absence of excessive and pointless actions</h4>

<h4>Complexity and metaphors</h4>

<p>
I like the metaphor of the basket with apples. Peoples can put an apple to the basket or can get an apple from it.
If the basket is empty you have to wait until somebody else put an apple. This is a metaphor of semaphore.
Why metaphors are important? Because if you know a metaphor you can easily derive a precise definition
of the software entity from it. You can specify a set of methods and its meaning, you can understand how to use
an object without the reading tons of manuals. Metaphor is a seed. It can grow to a mature software component.
Good software is metaphoric.
</p>

<p>
Metaphor is the most powerful weapon of the human mind to struggle with complexity. Using them you
turn on the most deep and powerful human mind ability.
</p>

<h4>A black cat in a dark room</h4>

<p>
Filthy programmers make a lot of errors. There is no problem to find them, usually you can read code
and find a lot. But what's about a good one? When you write a good code, how about errors? How to catch
a black cat in a dark room? Despite the common misunderstanding, it is not too much difficult actually.
The REAL problem is: how to prove there is no cat? It is possible to create a defectless software,
even a complex one, both theoretically and practically. But if you have one, how to prove it? 
</p>

<p>
There is only one reliable way. Prove to prove. The same way as we prove mathematical theorems.
In the pure mathematics we are able to build very complicated mathematical constructions and prove their
properties by the logical deduction. The same way is good for the software development.
Good programmer does not just write code. He formulates and proves different code properties.
Therefore, good programmer must have a well developed mathematical mind. Unfortunately, modern
development tools does not record this part of job.
</p>

<p>
There is a difference between the pure mathematics and the software development though. 
In the software development
to cover all significant code properties you must prove a huge number of simple statements.
So to make it feasible it is necessary to build code in such a way, that this number will not be insane. 
And here we come to different software development techniques, like functional, object and abstract
decompositions.
</p>

<p>
Functional decomposition arose from an observation, that some action sequences are repeated again and again.
Object decomposition arose from an observation, that some data combinations are repeated again and again.
Abstract decomposition arose from an observation, that software entities can be "parametrized" by another
software entities. Each time we repeat some build again and again, we can repeat its property proofs too.
So a good software decomposition not only allows us to build a complex software, but it allows
to make it correct too.
</p>

</body>

</html>

