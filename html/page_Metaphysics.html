<!--
/* page_Metaphysics.html */
//----------------------------------------------------------------------------------------
//
//  Project: CCore 1.02
//
//  License: Boost Software License - Version 1.0 - August 17th, 2003 
//
//            see http://www.boost.org/LICENSE_1_0.txt or the local copy
//
//  Copyright (c) 2012 Sergey Strukov. All rights reserved.
//
//----------------------------------------------------------------------------------------
-->

<!DOCTYPE html>
<html>

<head>

 <title>CCore -> Metaphisics</title>

 <link href="CCore.css" rel="stylesheet" type="text/css">

</head>

<body>

<h2>Metaphysics of the programming</h2>

<p><i>"Truce is concrete, philosophy is fruitless"</i></p>

<p>
So this page is about fruitlessness.
</p>

<h4>Programming is a mathematical engineering</h4>

<h4>Programming creates a quality, not a quantity</h4>

<p>
Yes, that is the major difference between programming and manufacture. 
The purpose of manufacture is the reproduction of the same thing again and again.
Reproduction of program can be done instantly by the command <b>copy</b>.
The purpose of programming is to create something new, unique.
</p>

<p>
So developing program we create a new quality to make the word better, safer, friendly etc. Or non-quality
to make the work worse, risky, hostile etc. You think it does not concern you, because you get your money and leave?
To where, to another globe, perhaps? To ruin it too? There is no escape. Humanity will learn how to
control the power of the software of will be crashed by it. The power which comes from the command <b>copy</b>.
When you program a quantity, you program a bug quantity.
</p>

<p>
What the difference between a good programmer and a bad one? Good writes a small, bugless code, bad writes a large, 
fat and bugful. Good spends most time to learn, understand and design a good, structured, mathematically correct code 
and a short time to make it running. Bad is not capable to learn much, deeply understand a subject and tools,
he writes a whole novels of poor literature code and then spends most of the working time to make it running. Somehow. 
Good automates its work. It creates software components and tools for repeated tasks. 
Bad is destined to do and hate a manual job.
</p>

<p>
In software development quality becomes quantity. That is the key point. There is no such thing as a deadline.
There is a goodline. Deadline is a badline. Don't go towards it.
The good developed code grows faster, it incorporates new features
smoothly, it can be well tested, defect fixes are much simpler. The proper strategy in a large-scale development is 
to maintain a high code quality from the start to the finish. Prototype and redesign! Test comprehensively!
Make a reliable software from a reliable software components!
</p>

<h4>Premature generalization is a root of all evil</h4>

<h4>Ugly airplane does not flight</h4>

<h4>Efficiency is NOT a number of bytes or CPU clocks, it is an absense of excessive and pointless actions</h4>

<h4>Complexity and metaphors</h4>

<p>
Metaphor is the most powerful weapon of the human mind to struggle with complexity.
</p>

<h4>A black cat in a dark room</h4>

<p>
Poor programmers make a lot of errors. There is no problem to find them, usually you can read a code
and find a lot. Bad what's about a good one? When you write a good code, how about errors? How to catch
a black cat in a dark room? Despite the common misunderstanding, it is not too much difficult actually.
The REAL problem is: how to prove there is no cat? It is possible to create a defectless software,
even a complex one, both theoretically and practically. But if you have one, how to prove it? 
</p>

<h4>A error zoo becomes a bug zoo</h4>

<h4>Breaking weaknesses</h4>

</body>

</html>

