<!--
/* page_PTP.html */
//----------------------------------------------------------------------------------------
//
//  Project: CCore 1.02
//
//  License: Boost Software License - Version 1.0 - August 17th, 2003 
//
//            see http://www.boost.org/LICENSE_1_0.txt or the local copy
//
//  Copyright (c) 2012 Sergey Strukov. All rights reserved.
//
//----------------------------------------------------------------------------------------
-->

<!DOCTYPE html>
<html>

<head>

 <title>CCore -> PTP</title>

 <link href="CCore.css" rel="stylesheet" type="text/css">

</head>

<body>

<h2>PTP</h2>

<p class="Files">Files <b>CCore/inc/net/PTPBase.h</b> <b>CCore/src/net/PTPBase.cpp</b></p>

<p class="Files">Files <b>CCore/inc/net/PTPExtra.h</b> <b>CCore/src/net/PTPExtra.cpp</b></p>

<p class="Files">Files <b>CCore/inc/net/PTPClientDevice.h</b> <b>CCore/src/net/PTPClientDevice.cpp</b></p>

<p class="Files">Files <b>CCore/inc/net/PTPServerDevice.h</b> <b>CCore/src/net/PTPServerDevice.cpp</b></p>

<p>
<b>PTP</b> is the <b>Packet Transaction Protocol</b>. This is a packet-based, reliable, transactional, 
parallel point-to-point protocol. It is best suited to implement an asyncronous call-type 
client-server interaction. It works atop a packet-based communication layer. There is no security features
in the protocol.
</p>

<h3>Protocol description</h3>

<p>
<b>PTP</b> defines rules for two endpoints, one is the <b>Server</b>, another is the <b>Client</b>. 
These endpoints exchange raw data packets (byte packets). <b>Client</b> issues call requests, 
<b>Server</b> takes call data, process it and returns some resulting data. 
From the <b>Client</b> perspective, it makes a function call. Function arguments
is a byte range. <b>Server</b> "evaluates" the function and return a result &mdash; another byte range.
The meaning of data is out of scope <b>PTP</b> protocol, it is defined by an upper protocol level.
Usually, <b>Server</b> may serve multiple <b>Client</b>s. 
From the protocol perspective all transactions are parallel and independent.
</p>

<p>
Protocol defines the following constsnts:
</p>

<pre>

const unsigned MaxPacketLen = 1472 ; // max UDP data len if( Eth.MTU == 1500 )
const unsigned DeltaInfoLen =   32 ;
const unsigned MaxInfoLen   = 1440 ; // MaxPacketLen-DeltaInfoLen
   
const unsigned MinTimeout   =   300 ; // msec, 0.3 sec   
const unsigned MaxTimeout   = 10000 ; // msec, 10  sec  
const unsigned DeltaTimeout =   100 ; // msec, 0.1 sec 

</pre>

<p>
<b>MaxPacketLen</b> &mdash; the maximum packet length.
</p>

<p>
<b>DeltaInfoLen</b> &mdash; delta between packet length and information length.
</p>

<p>
<b>MaxInfoLen</b> &mdash; the maximum information length.
</p>

<p>
<b>MinTimeout</b> &mdash; minimum timeout value.
</p>

<p>
<b>MaxTimeout</b> &mdash; maximum timeout value.
</p>

<p>
<b>DeltaTimeout</b> is the timeout increment. Each time a timeout value is used, it is incremented
by <b>DeltaTimeout</b> up to <b>MaxTimeout</b>.
</p>

<p>
Protocol defines the following data types:
</p>

<pre>

typedef ??? uint8;
   
typedef ??? uint16;
   
typedef ??? uint32;
   
typedef ??? uint64;


typedef uint32 PacketType;

typedef uint32 SlotId;
   
typedef uint32 RecallNumber;
 
struct TransId
 {
  uint64 number;
  uint64 clock;
 };

struct Info
 {
  uint32 len : len<=MaxInfoLen ; 
  uint8 data[len];
 };

</pre>

<p>
<b>uint8, uint16, uint32, uint64</b> are usual arithmetic unsigned integral types. For the protocol purpose
they are transported using the big-endian representation.
</p>

<p>
<b>PacketType</b> is used to represent a packet type.
</p>

<p>
<b>SlotId</b> is used to represent a slot id. <b>Slot</b> is a processing resource on both side.
</p>

<p>
<b>RecallNumber</b> is used to represent a recall number.
</p>

<p>
<b>TransId</b> is 128-bit value, it is generated by the <b>Client</b> and served as the unique
transaction id. It's recommended, that the <b>number</b> is incremented with each transaction 
and the <b>clock</b> is a high-frequency clock or another random input.
</p>

<p>
<b>Info</b> is a call or return information. It is sent as the length, followed by the information bytes. 
</p>

<p>
There are 8 packet types, 3 with attached information and 5 are short. Each packet starts
with a fixed format header. Info packets are ended with <b>Info</b>.
</p>

<pre>

struct Packet_CALL // info, Client to Server
 {
  PacketType type = 1 ;
  TransId tid;
  SlotId client_slot;
     
  Info client_info;
 };
 
struct Packet_RET // info, Server to Client
 {
  PacketType type = 2 ;
  TransId tid;
  SlotId client_slot;
  SlotId server_slot;
     
  Info server_info;
 };
 
struct Packet_RECALL // info, Client to Server
 {
  PacketType type = 3 ;
  TransId tid;
  SlotId client_slot;
     
  RecallNumber number;

  Info client_info;
 };

struct Packet_ACK // short, Client to Server
 {
  PacketType type = 4 ;
  TransId tid;
  SlotId client_slot;
  SlotId server_slot;
 };
    
struct Packet_NOINFO // short, Server to Client
 {
  PacketType type = 5 ;
  TransId tid;
  SlotId client_slot;
  SlotId server_slot;
 }; 
    
struct Packet_RERET // short, Server to Client
 {
  PacketType type = 6 ;
  TransId tid;
  SlotId client_slot;
  SlotId server_slot;
 }; 
    
struct Packet_SENDRET // short, Client to Server
 {
  PacketType type = 7 ;
  TransId tid;
  SlotId client_slot;
  SlotId server_slot;
 }; 
    
struct Packet_CANCEL // short, Server to Client
 {
  PacketType type = 8 ;
  TransId tid;
  SlotId client_slot;
  SlotId server_slot;
 }; 

</pre>

<p>
To start a transaction, <b>Client</b> prepares client <b>Info</b>, generates <b>TransId</b> and client <b>SlotId</b>.
Then it prepares and sends the <b>CALL</b> packet.
</p>

<pre>

Client                -&gt;   CALL   -&gt; Server

TransId tid;
SlotId client_slot;
Info client_info;

</pre>

<p>
<b>Server</b> accepts transaction by creating a server <b>SlotId</b>. It may replay with
<b>RET</b>, <b>CANCEL</b>, <b>NOINFO</b> or <b>RERET</b> packets.
</p>

<pre>

Client                &lt;-   RET    &lt;- Server

TransId tid;                         TransId tid;
SlotId client_slot;                  SlotId client_slot;
Info client_info;                    SlotId server_slot;
                                     Info client_info; // "arguments"
                                     Info server_info; // "result"

</pre>

<p>
<b>Client</b> completes transaction by the <b>ACK</b> packet, it cleanup the processing slot. 
<b>Server</b> cleanup the processing slot upon reception of this packet.
</p>

<pre>

Client                -&gt;   ACK    -&gt; Server

TransId tid;                         TransId tid;
SlotId client_slot;                  SlotId client_slot;
SlotId server_slot;                  SlotId server_slot;
Info client_info;                    Info client_info;
Info server_info;                    Info server_info;                 
                                     
</pre>

<p>
The "good" case if a transaction is finished by these 3 packets. Everthing else is to make the
protocol reliable.
</p>

<p>
Once <b>Client</b> is sent the <b>CALL</b> packet, it setup a timer to count timeout.
The initial timeout value is the <b>MinTimeout</b>. If this timer is expires before an expected reply,
the <b>RECALL</b> packet is sent. <b>number</b> starts from 1 and is incremented with saturation 
per each <b>RECALL</b> packet. Net timeout value is incremented each time it is expired.
</p>

<pre>

Client                -&gt;  RECALL  -&gt; Server

TransId tid;
SlotId client_slot;
Info client_info;

RecallNumber number = 1 ;
bool no_info = false ;

</pre>

<p>
<b>Server</b> may send the <b>NOINFO</b> packet instead of <b>RET</b> packet 
to confirm it has received the <b>CALL</b> packet.
</p>

<pre>

Client                &lt;-  NOINFO  &lt;- Server

TransId tid;                         TransId tid;
SlotId client_slot;                  SlotId client_slot;
Info client_info;                    SlotId server_slot;
                                     Info client_info;

</pre>

<p>
If <b>Client</b> gets this packet it sets the flag <b>no_info</b> in the processing slot.
If this flag is set, then <b>Client</b> sends the <b>SENDRET</b> packet upon a timeout expiration 
instead of <b>RECALL</b>.
</p>

<pre>

Client                -&gt;  SENDRET -&gt; Server

TransId tid;                         TransId tid;
SlotId client_slot;                  SlotId client_slot;
SlotId server_slot;                  SlotId server_slot;
Info client_info;                    Info client_info;

bool no_info = true ;

</pre>

<p>
To cancel a transaction <b>Server</b> may send the <b>CANCEL</b> packet.
<b>Client</b> respondes with the <b>ACK</b> packet and cleanup the processing slot.
</p>

<p>
<b>Server</b> may also send the <b>RERET</b> (Ready Return) packet. In response, <b>Client</b> 
sends the <b>SENDRET</b> packet.
</p>

<p>
Server starts a transaction processing upon <b>CALL</b> or <b>RECALL</b> packet.
If there is no available slots the packet is discarded. If the packet is <b>CALL</b> and the
transaction id is used, then the packet is discarded. If <b>Server</b> serves multiple <b>Client</b>s,
<b>Client</b> id must be accounted for the transaction identification.
The <b>CALL</b> packet starts the transaction processing. If the <b>RECALL</b> packet has the 
new transaction id, it also starts the transaction processing. Otherwise one of the packet
<b>RET</b>, <b>CANCEL</b> or <b>NOINFO</b> is returned to the <b>Client</b>. <b>RET</b> or <b>CANCEL</b>
is returned if the slot processing is finished, <b>NOINFO</b> if the slot processing is in progress.
</p>

<p>
When <b>Server</b> completes the slot processing and has the processing result, it sends the <b>RET</b> 
packet or <b>CANCEL</b> packet, if the processing is cancelled by the execution entity.
Once it is done, the <b>Server</b> setup a timer to count timeout. When timer is expired,
<b>Server</b> sends <b>RERET</b> packet. Server sends <b>RET</b> or <b>CANCEL</b> 
packet as the answer on <b>SENDRET</b> packet from Client. And only <b>ACK</b> packet finally cleanup 
the processing slot.
</p>

<p>
If <b>Server</b> gets <b>SENDRET</b> packet and cannot find the correspondent processing slot, 
it respondes with <b>CANCEL</b> packet.
</p>

<p>
If <b>Client</b> gets any packet and cannot find the correspondent processing slot, 
it respondes with <b>ACK</b> packet.
</p>

<p>
The file <b>txt/PTP.txt.cpp</b> contains a precise protocol description in pseudo-C++ code. 
</p>

<h3>PTPClientDevice</h3>

<p>
<b>PTPClientDevice</b> is an implementaion of PTP client protocol as a device class. 
</p>

<h3>PTPServerDevice</h3>

<p>
<b>PTPServerDevice</b> is an implementaion of PTP server protocol as a device class. 
</p>

</body>

</html>

