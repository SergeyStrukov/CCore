<!--
/* page_PTP.html */
//----------------------------------------------------------------------------------------
//
//  Project: CCore 1.02
//
//  License: Boost Software License - Version 1.0 - August 17th, 2003 
//
//            see http://www.boost.org/LICENSE_1_0.txt or the local copy
//
//  Copyright (c) 2012 Sergey Strukov. All rights reserved.
//
//----------------------------------------------------------------------------------------
-->

<!DOCTYPE html>
<html>

<head>

 <title>CCore -> PTP</title>

 <link href="CCore.css" rel="stylesheet" type="text/css">

</head>

<body>

<h2>PTP</h2>

<p class="Files">Files <b>CCore/inc/net/PTPBase.h</b> <b>CCore/src/net/PTPBase.cpp</b></p>

<p class="Files">Files <b>CCore/inc/net/PTPExtra.h</b> <b>CCore/src/net/PTPExtra.cpp</b></p>

<p class="Files">Files <b>CCore/inc/net/PTPClientDevice.h</b> <b>CCore/src/net/PTPClientDevice.cpp</b></p>

<p class="Files">Files <b>CCore/inc/net/PTPServerDevice.h</b> <b>CCore/src/net/PTPServerDevice.cpp</b></p>

<p>
<b>PTP</b> is the <b>Packet Transaction Protocol</b>. This is a packet-based, reliable, transactional, 
parallel point-to-point protocol. It is best suited to implement an asyncronous call-type 
client-server interaction. It works atop a packet-based communication layer. There is no security features
in the protocol.
</p>

<h3>Protocol description</h3>

<p>
<b>PTP</b> defines rules for two endpoints, one is the <b>Server</b>, another is the <b>Client</b>. 
These endpoints exchange raw data packets (byte packets). <b>Client</b> issues call requests, 
<b>Server</b> takes call data, process it and returns some resulting data. 
From the <b>Client</b> perspective, it makes a function call. Function arguments
is a byte range. <b>Server</b> "evaluates" the function and return a result &mdash; another byte range.
The meaning of data is out of scope <b>PTP</b> protocol, it is defined by an upper protocol level.
Usually, <b>Server</b> may serve multiple <b>Client</b>s. 
From the protocol perspective all transactions are parallel and independent.
</p>

<p>
Protocol defines the following constants:
</p>

<pre>

const unsigned MaxPacketLen = 1472 ;
const unsigned DeltaInfoLen =   32 ;
const unsigned MaxInfoLen   = 1440 ; // MaxPacketLen-DeltaInfoLen
   
const unsigned MinTimeout   =   300 ; // msec, 0.3 sec   
const unsigned MaxTimeout   = 10000 ; // msec, 10  sec  
const unsigned DeltaTimeout =   100 ; // msec, 0.1 sec 

</pre>

<p>
<b>MaxPacketLen</b> &mdash; maximum packet length. This value is choosen
as the maximum UDP data length fits a standard Ethernet frame length.
</p>

<p>
<b>DeltaInfoLen</b> &mdash; maximum delta between packet length and information length.
</p>

<p>
<b>MaxInfoLen</b> &mdash; maximum information length.
</p>

<p>
<b>MinTimeout</b> &mdash; minimum timeout value.
</p>

<p>
<b>MaxTimeout</b> &mdash; maximum timeout value.
</p>

<p>
<b>DeltaTimeout</b> &mdash; timeout increment. Each time a timeout value is used, it is incremented
by <b>DeltaTimeout</b> up to <b>MaxTimeout</b>.
</p>

<p>
Protocol defines the following data types:
</p>

<pre>

typedef ??? uint8;
   
typedef ??? uint16;
   
typedef ??? uint32;
   
typedef ??? uint64;


typedef uint32 PacketType;

typedef uint32 SlotId;
   
typedef uint32 RecallNumber;
 
struct TransId
 {
  uint64 number;
  uint64 clock;
 };

struct Info
 {
  uint32 len : len<=MaxInfoLen ; 
  uint8 data[len];
 };

</pre>

<p>
<b>uint8, uint16, uint32, uint64</b> are usual arithmetic unsigned integral types. For the protocol purpose
they are transported using the big-endian representation.
</p>

<p>
<b>PacketType</b> is used to represent a packet type.
</p>

<p>
<b>SlotId</b> is used to represent a slot id. <b>Slot</b> is a processing resource on both side.
It contains data, related with a single transaction.
</p>

<p>
<b>RecallNumber</b> is used to represent a recall number.
</p>

<p>
<b>TransId</b> is 128-bit value, it is generated by <b>Client</b> and serves as the unique
transaction id. It's recommended, that the <b>number</b> is incremented with each transaction 
and the <b>clock</b> is a high-frequency clock or another random input. A random mask can be
applyed to <b>TransId</b> for better diversity.
</p>

<p>
<b>Info</b> is a call or return information. It is sent as the length, followed by the information bytes. 
</p>

<p>
There are 8 packet types, 3 with attached information and 5 are short. Each packet starts
with a fixed format header. Info packets are ended with <b>Info</b>.
</p>

<pre>

struct Packet_CALL // info, Client to Server
 {
  PacketType type = 1 ;
  TransId tid;
  SlotId client_slot;
     
  Info client_info;
 };
 
struct Packet_RET // info, Server to Client
 {
  PacketType type = 2 ;
  TransId tid;
  SlotId client_slot;
  SlotId server_slot;
     
  Info server_info;
 };
 
struct Packet_RECALL // info, Client to Server
 {
  PacketType type = 3 ;
  TransId tid;
  SlotId client_slot;
     
  RecallNumber number;

  Info client_info;
 };

struct Packet_ACK // short, Client to Server
 {
  PacketType type = 4 ;
  TransId tid;
  SlotId client_slot;
  SlotId server_slot;
 };
    
struct Packet_NOINFO // short, Server to Client
 {
  PacketType type = 5 ;
  TransId tid;
  SlotId client_slot;
  SlotId server_slot;
 }; 
    
struct Packet_RERET // short, Server to Client
 {
  PacketType type = 6 ;
  TransId tid;
  SlotId client_slot;
  SlotId server_slot;
 }; 
    
struct Packet_SENDRET // short, Client to Server
 {
  PacketType type = 7 ;
  TransId tid;
  SlotId client_slot;
  SlotId server_slot;
 }; 
    
struct Packet_CANCEL // short, Server to Client
 {
  PacketType type = 8 ;
  TransId tid;
  SlotId client_slot;
  SlotId server_slot;
 }; 

</pre>

<p>
To start a transaction, <b>Client</b> allocates a slot, prepares client <b>Info</b>, 
generates <b>TransId</b> and client <b>SlotId</b>. Then it prepares and sends the <b>CALL</b> packet.
</p>

<pre>

Client                -&gt;   CALL   -&gt; Server

TransId tid;
SlotId client_slot;
Info client_info;

</pre>

<p>
<b>Server</b> accepts transaction by allocating a server slot. It may replay with
<b>RET</b>, <b>CANCEL</b>, <b>NOINFO</b> or <b>RERET</b> packets.
</p>

<pre>

Client                &lt;-   RET    &lt;- Server

TransId tid;                         TransId tid;
SlotId client_slot;                  SlotId client_slot;
Info client_info;                    SlotId server_slot;
                                     Info client_info; // "arguments"
                                     Info server_info; // "result"

</pre>

<p>
<b>Client</b> completes transaction by the <b>ACK</b> packet, it cleanup the processing slot. 
<b>Server</b> cleanup the processing slot upon reception of this packet.
</p>

<pre>

Client                -&gt;   ACK    -&gt; Server

TransId tid;                         TransId tid;
SlotId client_slot;                  SlotId client_slot;
SlotId server_slot;                  SlotId server_slot;
Info client_info;                    Info client_info;
Info server_info;                    Info server_info;                 
                                     
</pre>

<p>
The "good" case if a transaction is finished by these 3 packets. Everthing else is to make the
protocol reliable.
</p>

<p>
Once <b>Client</b> is sent the <b>CALL</b> packet, it setup a timer to count timeout.
The initial timeout value is the <b>MinTimeout</b>. If this timer expires before an expected reply,
the <b>RECALL</b> packet is sent. <b>number</b> starts from 1 and is incremented with saturation 
per each <b>RECALL</b> packet. The timeout value is incremented each time it is expired.
</p>

<pre>

Client                -&gt;  RECALL  -&gt; Server

TransId tid;
SlotId client_slot;
Info client_info;

RecallNumber number = 1 ;
bool no_info = false ;

</pre>

<p>
<b>Server</b> may send the <b>NOINFO</b> packet instead of <b>RET</b> packet 
to confirm it has received the <b>CALL</b> packet.
</p>

<pre>

Client                &lt;-  NOINFO  &lt;- Server

TransId tid;                         TransId tid;
SlotId client_slot;                  SlotId client_slot;
Info client_info;                    SlotId server_slot;
                                     Info client_info;

</pre>

<p>
If <b>Client</b> gets this packet it sets the flag <b>no_info</b> in the processing slot.
If this flag is set, then <b>Client</b> sends the <b>SENDRET</b> packet at a timeout expiration 
instead of <b>RECALL</b>.
</p>

<pre>

Client                -&gt;  SENDRET -&gt; Server

TransId tid;                         TransId tid;
SlotId client_slot;                  SlotId client_slot;
SlotId server_slot;                  SlotId server_slot;
Info client_info;                    Info client_info;

bool no_info = true ;

</pre>

<p>
To cancel a transaction <b>Server</b> may send the <b>CANCEL</b> packet.
<b>Client</b> respondes with the <b>ACK</b> packet and cleanup the processing slot.
</p>

<p>
<b>Server</b> may also send the <b>RERET</b> (Ready Return) packet. In response, <b>Client</b> 
sends the <b>SENDRET</b> packet.
</p>

<p>
<b>Server</b> starts a transaction processing upon <b>CALL</b> or <b>RECALL</b> packet.
If there is no available slots the packet is discarded. If the packet is <b>CALL</b> and the
transaction id is used, then the packet is discarded. If <b>Server</b> serves multiple <b>Client</b>s,
<b>Client</b> id must be accounted for the transaction identification.
The <b>CALL</b> packet starts the transaction processing. If the <b>RECALL</b> packet has the 
new transaction id, it also starts the transaction processing. Otherwise one of the packet
<b>RET</b>, <b>CANCEL</b> or <b>NOINFO</b> is returned to the <b>Client</b>. <b>RET</b> or <b>CANCEL</b>
is returned if the slot processing is finished, <b>NOINFO</b> if the slot processing is in progress.
</p>

<p>
When <b>Server</b> completes the slot processing and has the processing result, it sends the <b>RET</b> 
packet or <b>CANCEL</b> packet, if the processing is cancelled by the execution entity.
Once it is done, the <b>Server</b> setup a timer to count timeout. When timer is expired,
<b>Server</b> sends <b>RERET</b> packet. <b>Server</b> sends <b>RET</b> or <b>CANCEL</b> 
packet as the answer on <b>SENDRET</b> packet from <b>Client</b>. And only <b>ACK</b> packet finally cleanup 
the processing slot.
</p>

<p>
If <b>Server</b> gets <b>SENDRET</b> packet and cannot find the correspondent processing slot, 
it respondes with <b>CANCEL</b> packet.
</p>

<p>
If <b>Client</b> gets any packet and cannot find the correspondent processing slot, 
it respondes with <b>ACK</b> packet.
</p>

<p>
The file <b>txt/PTP.txt.cpp</b> contains a precise protocol description in pseudo-C++ code. 
</p>

<h3>PTPClientDevice</h3>

<p>
<b>PTPClientDevice</b> is an implementaion of <b>PTP</b> client protocol as a device class. 
It is located in the <b>PTP</b> namespace (<b>::CCore::Net::PTP</b>).
</p>

<pre>
class <span class="att">ClientDevice</span> : public ObjBase
 {
   ....

  public:
   
   // constructors
  
   explicit ClientDevice(StrLen ep_dev_name,ulen max_slots=100);
   
   virtual ~ClientDevice();
   
   // methods
   
   PacketEndpointDevice * getEPDevice() const;
   
   void start(Packet&lt;uint8,TransExt&gt; packet);
   
   typedef ClientStatInfo StatInfo;
   
   void getStat(ClientStatInfo &ret);
   
   ulen getMaxOutboundInfoLen(); // always > 0 , <= MaxInfoLen
   
   ulen getMaxInboundInfoLen(); // always > 0 , <= MaxInfoLen
   
   // generic transactions
   
   template &lt;class Ext&gt;
   void start(Packet&lt;uint8,Ext&gt; packet,const typename Ext::InputType &amp;input);
   
   template &lt;class Ext&gt;
   void start_format(Packet&lt;uint8,Ext&gt; packet,const typename Ext::InputType &amp;input);
   
   struct FormatResult
    {
     PacketFormat format;
     bool too_short;
     
     FormatResult(NothingType) : too_short(true) {}
     
     FormatResult(PacketFormat format_) : format(format_),too_short(false) {}
     
     bool operator ! () const { return too_short; }
     
     bool noRoom() const { return format.max_data==0; }
    };
   
   template &lt;class Ext&gt;
   static PacketFormat GetFormat(); 
   
   template &lt;class Ext&gt;
   static FormatResult GetFormat(ulen max_outbound_info_len); 
   
   template &lt;class Ext&gt;
   FormatResult getFormat();
   
   template &lt;class Ext&gt;
   PacketFormat getFormat_guarded(const char *name); 
   
   // support service
   
   void support(Packet&lt;uint8,PTPSupport::LenExt&gt; packet);
   
   void support(Packet&lt;uint8,PTPSupport::SeedExt&gt; packet);
   
   void support(Packet&lt;uint8,PTPSupport::SessionExt&gt; packet);
   
   FormatResult getEchoFormat();
   
   void support(Packet&lt;uint8,PTPSupport::EchoExt&gt; packet,uint32 delay_msec);
   
   void support(Packet&lt;uint8,PTPSupport::ErrorDescExt&gt; packet,ServiceIdType service_id,FunctionIdType function_id,ErrorIdType error_id);
   
   void support(Packet&lt;uint8,PTPSupport::ExistExt&gt; packet,ServiceIdType service_id,FunctionIdType function_id);
   
   // initial interaction
   
   bool support(PacketSet&lt;uint8&gt; &amp;pset,MSec timeout=DefaultTimeout);
   
   void support_guarded(MSec timeout=DefaultTimeout);
 };
</pre>

<p>
The first constructor argument is the <b>PacketEndpointDevice</b> object name.
The second is the number of active transaction slots. When all slots are active, an extra transaction
is put into a wait queue. It is activated as soon as a slot becomes available.
</p>

<p>
<b>getEPDevice()</b> returns the <b>PacketEndpointDevice</b> this object is attached to.
</p>

<p>
<b>getMaxOutboundInfoLen()</b> and <b>getMaxInboundInfoLen()</b> are info length limits, these values
are calculated based on the <b>PacketEndpointDevice</b> properties, they are always positive.
</p>

<p>
<b>getStat()</b> returns the protocol statistic counters.
</p>

<p>
<b>start(Packet&lt;uint8,TransExt&gt; packet)</b> starts a transaction. This is the most general way
to execute a transaction. You must prepare a packet, fill it with client info and call this method.
<b>TransExt</b> constructor argument is a flag, set this flag to <b>MovePacketBuf</b> if you require the packet 
buffer movement with server info. When transaction is finished, the packet is completed. In the completion function
you will see the server info, it is the field <b>server_info</b> of the <b>TransExt</b>. You must use
the <b>operator !</b> to check if the transaction is failed. If you required the packet buffer movement,
the packet will have the packet buffer with the server info attached. Otherwise, the <b>server_info</b>
is disappeared after the completion function is returned.
</p>

<pre>
struct <span class="att">TransExt</span>
 {
  TransResult result;              // output
  PtrLen&lt;const uint8&gt; server_info; // output
  
  // constructors
  
  explicit TransExt(MoveFlagType move_flag);
  
  // methods
  
  bool operator ! () const { return result!=Trans_Ok; }

  ....
 };
</pre>

<p>
<b></b>
</p>

<h3>PTPServerDevice</h3>

<p>
<b>PTPServerDevice</b> is an implementaion of <b>PTP</b> server protocol as a device class. 
It is located in the <b>PTP</b> namespace (<b>::CCore::Net::PTP</b>).
</p>

<pre>
class <span class="att">ServerDevice</span> : public ObjBase
 {
   ....

  public: 
   
   // constructors
  
   explicit ServerDevice(StrLen mp_dev_name,ulen max_slots=100);
   
   virtual ~ServerDevice();
   
   // methods
   
   PacketMultipointDevice * getMPDevice() const;
   
   ulen getMaxOutboundInfoLen() const;
   
   ulen getMaxInboundInfoLen() const;
   
   typedef ServerStatInfo StatInfo;
   
   void getStat(ServerStatInfo &amp;ret);
   
   void send_info(TransIndex idx,Packet&lt;uint8&gt; proc_packet,PtrLen&lt;const uint8&gt; server_info);
   
   void send_cancel(TransIndex idx);
   
   void attach(ServerProc *proc);
   
   void detach();
   
   void waitActiveComplete();
   
   bool waitActiveComplete(MSec timeout);
   
   bool waitActiveComplete(TimeScope time_scope);
 };
</pre>

<p>
The first constructor argument is the <b>PacketMultipointDevice</b> object name.
The second is the number of available transaction slots.
</p>

<p>
<b>getMPDevice()</b> returns the <b>PacketMultipointDevice</b> this object is attached to.
</p>

<p>
<b>getMaxOutboundInfoLen()</b> and <b>getMaxInboundInfoLen()</b> are info length limits, these values
are calculated based on the <b>PacketMultipointDevice</b> properties, they are always positive.
</p>

<p>
<b>getStat()</b> returns the protocol statistic counters.
</p>

<p>
To implement a server functionality some server processor must be attached.
</p>

<p>
<b>attach()</b> attaches the server processor.
</p>

<p>
<b>detach()</b> detaches the server processor and waits while it is in use.
</p>

<pre> 
struct <span class="att">ServerProc</span>
 {
  virtual void inbound(XPoint point,TransIndex idx,Packet&lt;uint8&gt; packet,PtrLen&lt;const uint8&gt; client_info)=0;
  
  virtual void tick()=0;
 };
</pre>

<p>
Server processor interface has two methods. <b>inbound()</b> is called to process a transaction.
The first argument is a client address, the second is a some transaction index, then packet follows and
client info range from this packet. <b>tick()</b> is a network tick. When processor finished with
transaction, it must call either <b>send_info()</b> or <b>send_cancel()</b> methods.
Each of them starts with transaction index. <b>send_info()</b> takes aslo a packet and a server info 
data range from this packet. The original client packet may be reused, otherwise it must be completed.
</p>

<p>
<b>waitActiveComplete...()</b> methods can be used to wait until all processing slots are free (no in-progress transactions).
</p>

</body>

</html>

