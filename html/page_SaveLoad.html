<!--
/* page_SaveLoad.html */
//----------------------------------------------------------------------------------------
//
//  Project: CCore 1.02
//
//  License: Boost Software License - Version 1.0 - August 17th, 2003 
//
//            see http://www.boost.org/LICENSE_1_0.txt or the local copy
//
//  Copyright (c) 2012 Sergey Strukov. All rights reserved.
//
//----------------------------------------------------------------------------------------
-->

<!DOCTYPE html>
<html>

<head>

 <title>CCore -> SaveLoad</title>

 <link href="CCore.css" rel="stylesheet" type="text/css">

</head>

<body>

<h2>SaveLoad</h2>

<p class="Files">Files <b>CCore/inc/SaveLoad.h</b> <b>CCore/src/SaveLoad.cpp</b></p>

<h3>Serialization basics</h3>

<p>
Serialization is a process of converting an object state into a byte sequence and inversely.
We use the word "save" for the first operation and "load" for the inverse. The header <b>SaveLoad.h</b>
provides a basic binary serialization framework.
</p>

<p>
To participate in te save/load process a class must implement a save/load methods.
The simple example, how to serialize a simple data structure:
</p>

<pre>
struct Data
 {
  T1 t1;
  T2 t2;
  T3 t3;

  // save/load object

  enum { SaveLoadLen = SaveLenCounter&lt;T1,T2,T3&gt;::SaveLoadLen };
  
  template &lt;class Dev&gt;
  void save(Dev &amp;dev) const
   {
    dev.template use&lt;BeOrder&gt;(t1,t2,t3);
   }
  
  template &lt;class Dev&gt;
  void load(Dev &amp;dev)
   {
    dev.template use&lt;BeOrder&gt;(t1,t2,t3);
   }
 };
</pre>

<p>
Four basic types <b>uint8</b>, <b>uint16</b>, <b>uint32</b>, and <b>uint64</b> are serializable,
either in the big-endian or in the little-endian format.
An order specifier (<b>BeOrder</b> or <b>LeOrder</b>) affects only the basic type argument's
serialization (t1,t2,t3). If none of them has a basic type, you may use the <b>operator ()</b>:
</p>

<pre>
  template &lt;class Dev&gt;
  void save(Dev &amp;dev) const
   {
    dev(t1,t2,t3);
   }
  
  template &lt;class Dev&gt;
  void load(Dev &amp;dev)
   {
    dev(t1,t2,t3);
   }
</pre>

<p>
Type may not define the constant <b>SaveLoadLen</b>. But if it is defined, the type must serialize itself
in exact number of bytes. This constant is used to optimize a serializaion process.
</p>

<p>
A serializaion device does its job with the <b>operator ()</b>, which accepts any number of arguments.
If an <b>Order</b> must be specified, then the method <b>use&lt;Order&gt;</b> must be used instead.
</p>

<p>
To calculate a save length of the set of objects the function <b>SaveLen()</b> can be used:
</p>

<pre>
template &lt;class ... TT&gt;
ULenSat <span class="att">SaveLen</span>(const TT &amp; ... tt);
</pre>

<p>
Or the meta-function <b>SaveLenCounter</b> for a fixed-length types.
</p>

<pre>

template &lt;class ... TT&gt;
struct <span class="att">SaveLenCounter</span>
 {
  enum FlagType { Has_SaveLoadLen = true };
 
  enum LenType : ulen { SaveLoadLen = .... };
 };

template &lt;class ... TT&gt;
struct <span class="att">SaveLenCounter</span>
 {
  enum FlagType { Has_SaveLoadLen = false };
 };

</pre>

<h3>Utilities</h3>

<p>
<b>ProxyLoad()</b> loads the object using a proxy class. The proxy class type is the first template
argument class. Proxy type must be loadable and must have the method <b>get()</b> to extract
a value of the type <b>T</b> from it.
</p>

<pre>

template &lt;class Proxy,class T,class Dev&gt;
void <span class="att">ProxyLoad</span>(T &amp;obj,Dev &amp;dev);

</pre>

<p>
The following funtion family is a range serialization helpers. You may load or save the given range
of objects using them. Range can be given as an abstract range cursor class or as the pointer/length 
couple.
</p>

<pre>

template &lt;class R,class Dev&gt;
void <span class="att">SaveRange</span>(R r,Dev &amp;dev);

template &lt;class T,class Dev&gt;
void <span class="att">SaveRange</span>(const T *ptr,ulen len,Dev &amp;dev);
  
template &lt;class R,class Dev&gt;
void <span class="att">LoadRange</span>(R r,Dev &amp;dev);

template &lt;class T,class Dev&gt;
void <span class="att">LoadRange</span>(T *ptr,ulen len,Dev &amp;dev);
  
template &lt;class Custom,class R,class Dev&gt;
void <span class="att">SaveRange_use</span>(R r,Dev &amp;dev);

template &lt;class Custom,class T,class Dev&gt;
void <span class="att">SaveRange_use</span>(const T *ptr,ulen len,Dev &amp;dev);
  
template &lt;class Custom,class R,class Dev&gt;
void <span class="att">LoadRange_use</span>(R r,Dev &amp;dev);

template &lt;class Custom,class T,class Dev&gt;
void <span class="att">LoadRange_use</span>(T *ptr,ulen len,Dev &amp;dev);

</pre>

<p>
The following simple structure family is in particular is a proxy class family for
the unsigned types serialization.
</p>

<pre>

struct <span class="att">SaveLoadBe16</span>;

struct <span class="att">SaveLoadBe32</span>;

struct <span class="att">SaveLoadBe64</span>;

struct <span class="att">SaveLoadLe16</span>;

struct <span class="att">SaveLoadLe32</span>;

struct <span class="att">SaveLoadLe64</span>;

/* struct SaveLoadBe16 */ 

struct <span class="att">SaveLoadBe16</span>
 {
  uint8 buf[2];
  
  // constructors
  
  SaveLoadBe16() : buf() {}
  
  SaveLoadBe16(uint8 b0,uint8 b1) 
   {
    buf[0]=b0;
    buf[1]=b1;
   }
  
  explicit SaveLoadBe16(uint16 value)
   {
    buf[0]=uint8(value&gt;&gt;8);
    buf[1]=uint8(value   );
   }
  
  // methods
  
  uint16 get() const 
   { 
    uint16 b0=buf[0];
    uint16 b1=buf[1];
   
    return uint16( (b0&lt;&lt;8)|b1 ); 
   }
  
  // save/load object
  
  enum { SaveLoadLen = 2 };
 
  template &lt;class Dev&gt;
  void save(Dev &amp;dev) const
   {
    dev.put(buf,2);
   }
   
  template &lt;class Dev&gt;
  void load(Dev &amp;dev)
   {
    dev.get(buf,2);
   }
 };

</pre>

<h3>Serialization devices</h3>

<h4>PutDevBase/GetDevBase</h4>

<h4>BufPutDev</h4>

<h4>CountPutDev</h4>

<h4>BufGetDev</h4>

<h4>RangeGetDev</h4>

</body>

</html>

