<!--
/* page_PrintDevice.html */
//----------------------------------------------------------------------------------------
//
//  Project: CCore 1.02
//
//  License: Boost Software License - Version 1.0 - August 17th, 2003 
//
//            see http://www.boost.org/LICENSE_1_0.txt or the local copy
//
//  Copyright (c) 2012 Sergey Strukov. All rights reserved.
//
//----------------------------------------------------------------------------------------
-->

<!DOCTYPE html>
<html>

<head>

 <title>CCore -> PrintDevice</title>

 <link href="CCore.css" rel="stylesheet" type="text/css">

</head>

<body>

<h2>Printing devices</h2>

<p class="Files">Files <b>CCore/inc/Print.h</b> <b>CCore/src/Print.cpp</b></p>

<p class="Files">Subfolders <b>CCore/inc/print</b> <b>CCore/src/print</b></p>

<p>
There are several standard "printing device" classes, implemented in the <b>CCore</b>.
The lists are differ in <b>XCore</b> and <b>HCore</b>.
</p>

<h4>PrintCon (HCore)</h4>

<p>
<b>PrintCon</b> is the first and the most important class in the list. It is used to print to the console.
This class is based on the target function <b>ConWrite</b>, defined in the header <b>sys/SysCon.h</b>.
This function is assumed to call some native OS function to print the text string.
</p>

<pre>

void <span class="att">Sys::ConWrite</span>(StrLen str) noexcept;

</pre>

<p>
The word <b>Con</b> is used to print to the console.
</p>

<pre>
/* words */ 

enum ConType { <span class="att">Con</span> };
 
template &lt;&gt; 
struct PrintOutAdapter&lt;ConType&gt;
 {
  typedef PrintCon PrintOutType;
 };

</pre>

<p>
The class <b>PrintCon</b> uses a small stack buffer to accumulate the printing text:
</p>

<pre>
class <span class="att">PrintCon</span> : public PrintBase
 {
   char buf[TextBufLen];
 
  private:
  
   virtual PtrLen&lt;char&gt; do_provide(ulen hint_len);
   
   virtual void do_flush(char *ptr,ulen len); 
   
  public:
  
   explicit PrintCon(ConType) {}
   
   ~PrintCon() { flush(); }
   
   static void Print(const char *ptr,ulen len) { Print(Range(ptr,len)); }
   
   static void Print(StrLen str); // ignore errors
 };
</pre>

<p>
The static methods <b>Print()</b> can be used for the direct printing to the console.
</p>

<h4>PrintCon (XCore)</h4>

<p>
The <b>XCore</b> varaint of the <b>PrintCon</b> is close to the <b>HCore</b>.
</p>

<pre>
class <span class="att">PrintCon</span> : public PrintBase
 {
   MSec timeout;
   NanoPacket&lt;char&gt; packet;
 
  private:
  
   virtual PtrLen&lt;char&gt; do_provide(ulen hint_len);
   
   virtual void do_flush(char *ptr,ulen len); 
   
  public:
  
   explicit PrintCon(ConType,MSec timeout_=DefaultTimeout) : timeout(timeout_) {}
   
   ~PrintCon() { flush(); }
   
   static void Print(const char *ptr,ulen len); // ignore errors
   
   static void Print(StrLen str) { Print(str.ptr,str.len); } 
 };
</pre>

<p>
The small difference is the constructor takes the additional argument <b>timeout</b>, defaulted to the  
<b>DefaultTimeout</b>. Th main diffrerence, however, not the interface, but the implementation.
<b>XCore</b> <b>PrintCon</b> uses <a href="page_NanoPackets.html"><b>NanoPacket</b></a>s. Methods <b>Print()</b> create a temporary <b>PrintCon</b>
object to print the text. Printing is not permitted in the interrupt context.
</p>

<p>
<b>XCore</b> supports the console printing by the following functions, defined in
the <b>sys/SysCon.h</b> header.
</p>

<pre>

NanoPacket&lt;char&gt; <span class="att">Sys::AllocConPacket</span>(MSec timeout);

void <span class="att">Sys::ConWrite</span>(NanoPacket&lt;char&gt; packet);

</pre>

<p>
The full implementation of these functions is the target resposibility. It is doing through a derived class from
the <b>Sys::ConBase</b> class. Usually a target device has a serial port and console packets are delivered
to the host computer through the port driver.
</p>

<h4>PrintFile (HCore only)</h4>

<p>
<b>PrintFile</b> class is designed to print to the file. On <b>HCore</b> targets this class is based on the 
OS file input-output functions.
</p>

<pre>
class <span class="att">PrintFile</span> : public PrintBase
 {
   ....
   
  public:
   
   // constructors
  
   PrintFile();
   
   explicit PrintFile(StrLen file_name,FileOpenFlags oflags=Open_ToWrite);
   
   ~PrintFile();
   
   // methods
   
   bool isOpened() const;
   
   void open(StrLen file_name,FileOpenFlags oflags=Open_ToWrite);
   
   void disableExceptions(); 
   
   void soft_close(FileMultiError &amp;errout);
   
   void close();
   
   void preserveFile();
 };
</pre>

<p>
<b>PrintFile</b> object can be opened or closed. To print to the particular file, a <b>PrintFile</b>
object must be opened and a file name and <a href="page_Files.html">open flags</a> must be provided.
It can be done using the constructor or the method <b>open()</b>. Default constructor creates
an object in the closed state. Non-default opens a file. In case of error an exception is thrown.
</p>

<p>
Destructor flushs and closes opened object. Errors are reported.
</p>

<p>
<b>isOpened()</b> returns true, if the file is opened, and false otherwise.
</p>

<p>
<b>open()</b> opens a closed object with the given file and open flags. 
In case of error an exception is thrown.
</p>

<p>
<b>close()</b> closes an opened object. In case of error and if there is a pending output error
an exception is thrown.
</p>

<p>
<b>soft_close()</b> does not throw, it returns a group of errors using the 
<a href="page_Files.html"><b>FileMultiError</b></a> object.
</p>

<p>
<b>disableExceptions()</b> disables exceptions during print operations.
</p>

<p>
<b>preserveFile()</b> preserves a file, opened with the <b>AutoDelete</b> open flag.
</p>

<p>
<b>PrintFile</b> class is constructed from two classes: <b>SafeBuf</b> and <b>RawFileToPrint</b>.
</p>

<pre>
class <span class="att">SafeBuf</span> : NoCopy
 {
   static const ulen SafeLen = 32 ;
   
   char *ptr;
   ulen len;
   
   char safebuf[SafeLen];
 
  public:
  
   explicit SafeBuf(ulen len);
   
   ~SafeBuf();

   char * getPtr() const { return ptr; }
 
   ulen getLen() const { return len; }
 };
</pre>

<p>
The <b>SafeBuf</b> class is used to allocate a file buffer. <b>PrintFile</b> uses the file buffer
of size 64 KBytes. But if the required memory is not avaliable, <b>SafeBuf</b> uses an internal
small safeguard buffer of size 32 bytes. 
</p>

<pre>
class <span class="att">RawFileToPrint</span> : NoCopy
 {
   Sys::File file;
   bool opened;
   bool preserve_file;
   
  public:
   
   // constructors
  
   RawFileToPrint() : opened(false) {}
   
    // No destructor ! 
   
   // methods
   
   bool isOpened() const { return opened; }
   
   FileError open(StrLen file_name,FileOpenFlags oflags);
   
   void close(FileMultiError &amp;errout);
   
   void preserveFile() { preserve_file=true; }
   
   FileError write(const uint8 *buf,ulen len);
 }; 
</pre>

<p>
The <b>RawFileToPrint</b> class is built on the target <b>Sys::File</b> class. It performes open/close
operations and the raw file output.
</p>

<p>
The target <b>Sys::File</b> class implements the classical set of file operations.
</p>

<pre>
struct <span class="att">Sys::File</span>
 {
  ....

  // public
  
  struct IOResult
   {
    ulen len;
    FileError error;
   };
 
  struct PosResult
   {
    FilePosType pos;
    FileError error;
   };
  
  FileError open(StrLen file_name,FileOpenFlags oflags);
 
  void close(FileMultiError &errout,bool preserve_file=false); 
  
  void close(); 
   
  IOResult write(const uint8 *buf,ulen len);
  
  IOResult read(uint8 *buf,ulen len);
  
  PosResult getLen();
  
  PosResult getPos();
  
  FileError setPos(FilePosType pos);
 };
</pre>

<p>
The methods of this class call directly OS file system interface functions.
</p>

<h4>PrintAsyncFile</h4>

<h4>PrintPTPCon</h4>

</body>

</html>

