<!--
/* page_LangLR1.html */
//----------------------------------------------------------------------------------------
//
//  Project: CCore 1.02
//
//  License: Boost Software License - Version 1.0 - August 17th, 2003 
//
//            see http://www.boost.org/LICENSE_1_0.txt or the local copy
//
//  Copyright (c) 2012 Sergey Strukov. All rights reserved.
//
//----------------------------------------------------------------------------------------
-->

<!DOCTYPE html>
<html>

<head>

 <title>CCore -> LangLR1</title>

 <link href="CCore.css" rel="stylesheet" type="text/css">

</head>

<body>

<h2>LangLR1</h2>

<p>
<b>LangLR1</b> generates a parsing state machine for an LR1 language.
</p>

<pre>

LangLR1.exe &lt;lang-name&gt; &lt;file.lang&gt; &lt;CCore-Root&gt;

</pre>

<p>
The first command line argument is the language name.
</p>

<p>
The second is the file with the language definition.
</p>

<p>
The third is the path to the <b>CCore</b> root directory. If this path is relative, it starts from the
subdirectory <b>test</b> of the working directory.
</p>

<p>
Program generates two files in the working directory: <b>Result.txt</b> and <b>State.ddl</b>.
It also generates the test directory <b>test</b>. You can build and run a test project there.
</p>

<p>
<b>tools/LangLR1-tools/AMP</b> is a sample directory with AMP language.
</p>

<h2>Context-free languages and grammars</h2>

<p>
Consider a non-empty finite set <b>Atom</b>. Elements of this set are called atoms.
Finite sequences of atoms are called words. They comprise another (infinite) set &mdash; 
<b>Atom<sup>*</sup></b>. From the abstract algebra perspective, <b>Atom<sup>*</sup></b> is
a free monoid, generated by the <b>Atom</b>. This set has a natural binary operation &mdash;
word concatenation. Subsets of <b>Atom<sup>*</sup></b> are often called languages.
There is a class of languages, known as context-free languages. These languages are defined
by context-free grammars.
</p>

<p>
Consider an example &mdash; AMP language. This language is defined by the following grammar:
</p>

<pre>

/* AMP.lang */

A :
 {
  M     : A1
  A + M : A2
 }
 
M
 {
  P     : M1
  P * M : M2
 }
 
P
 {
  x     : P1
  ( A ) : P2 
 } 

</pre>

<p>
This grammar introduces three non-terminals: <b>A</b>, <b>M</b> and <b>P</b>.
Each non-terminal has a set of associated production rules. For example, <b>A</b> has two
rules: <b>A1</b> and <b>A2</b>. Each rule is a sequence of atoms and non-terminals.
For example, the rule <b>A2</b> is a length 3 sequence: ( <b>A</b> , <b>+</b> , <b>M</b> ).
The atom set is { <b>+</b> , <b>*</b> , <b>x</b> , <b>(</b> , <b>)</b> } and it is defined implicitly 
by the grammar. 
</p>

<p>
Non-terminal and rule names must be C-names. Atom name may be any string, to include one of the
character <b>{ } : `</b> prefix it with <b>`</b> character. You may not use <b>"</b> character.
</p>

<p>
Non-terminal <b>A</b> is marked with <b>:</b> character. The language of this non-terminal is 
included in the resulting language. You may mark several non-terminals, but usually only a single
non-terminal is marked as resulting.
</p>

<p>
Grammar produces a language per each non-terminal by the following inductive process:
</p>

<pre>

{A}<sub>0</sub> = &empty;

{M}<sub>0</sub> = &empty;

{P}<sub>0</sub> = &empty;

</pre>

<pre>

{A}<sub>n+1</sub> = union of
 {
  {M}<sub>n</sub>    
  {A}<sub>n</sub> + {M}<sub>n</sub>
 }
 
{M}<sub>n+1</sub> = union of
 {
  {P}<sub>n</sub>    
  {P}<sub>n</sub> * {M}<sub>n</sub>
 }
 
{P}<sub>n+1</sub> = union of
 {
  x    
  ( {A}<sub>n</sub> )
 } 

</pre>

<pre>

{A} = union of all {A}<sub>n</sub>

{M} = union of all {M}<sub>n</sub>

{P} = union of all {P}<sub>n</sub>

</pre>

<p>
The following relations are satisfied:
</p>

<pre>

{A} = union of
 {
  {M}    
  {A} + {M}
 }
 
{M} = union of
 {
  {P}    
  {P} * {M}
 }
 
{P} = union of
 {
  x    
  ( {A} )
 } 

</pre>

<h2>Language decoding</h2>

<p>
Informally speaking, decoding a language according a grammar is a reconstruction of the way how
the given word is produced by grammar rules. If this way is unique, the grammar is called uniquely
decoded. There is a convenient formal definition of a "uniquely decoded grammar".
</p>

<p>
Lets extend the initial grammar by the following way:
</p>

<pre>

A
 {
  M     [A1] : A1
  A + M [A2] : A2
 }
 
M
 {
  P     [M1] : M1
  P * M [M2] : M2
 }
 
P
 {
  x     [P1] : P1
  ( A ) [P2] : P2 
 } 

</pre>

<p>
I.g. we append each rule by a special atom &mdash; one atom per each rule.
Lets denote new languages as <b>{A[]}</b> etc...
Then if we take a word from the <b>{A[]}</b> and cleanup all extended atoms, then we receive
a word from the <b>{A}</b>. So we get a map <b>clean: {A[]} &rarr; {A}</b> and other such maps.
They are surjective and grammar is uniquely decoded if they are bijective. I.g. if we know
the word from the <b>{A}</b>, we can uniquely up this word to the word from the <b>{A[]}</b>. And doing
so we receive the production formula in the postfix form: 
</p>

<pre>

( x [P1] * x [P1] [M1] [M2] [A1] ) [P2] [M1] [A1] + x [P1] [M1] [A2]

( x * x ) + x

</pre>

<p>
If the grammar is uniquely decoded, it may be used to evaluate words. For evaluation some entities 
must be given. First, a set of types, one per each non-terminal and per each atom.
Second, a set of functions, one per each rule. Atom may carry a value of the correspondent type.
</p>

<pre>

type typeA;
type typeM;
type typeP;

type type_add; // +
type type_mul; // *
type type_obr; // (
type type_cbr; // )
type type_x;   // x

typeA funcA1(typeM);
typeA funcA2(typeA,type_add,typeM);

typeM funcM1(typeP);
typeM funcM2(typeP,type_mul,typeM);

typeP funcP1(type_x);
typeP funcP2(type_obr,typeA,type_cbr);

</pre>

<p>
The evaluation process goes using a polymorphic stack. Each time an extended atom puts on the stack,
the corespondent function is applied at the top of the stack (arguments are removed from the stack) 
and the result is put to the stack.
</p>

<pre>

( x [P1]

( funcP1(x) * x [P1]

( funcP1(x) * funcP1(x) [M1]

( funcP1(x) * funcM1(funcP1(x)) [M2]

( funcM2(funcP1(x),*,funcM1(funcP1(x))) [A1]

( funcA1(funcM2(funcP1(x),*,funcM1(funcP1(x)))) ) [P2]

funcP2((,funcA1(funcM2(funcP1(x),*,funcM1(funcP1(x)))),)) [M1]

....

</pre>

<h2>LR1 decoder</h2>

<p>
LR1 decoder is an efficient language decoder. It is working with the evaluation stack.
It looks ahead on one atom and makes a choice: put this atom to the stack or apply a rule.
</p>

<pre>

( funcP1(x) *     &larr;                x

// stack shift operation

</pre>

<pre>

( funcP1(x) * x   [P1]             )

</pre>

<p>
To make a decision decoder uses a state machine. States of this state machines are stores in the stack:
</p>

<pre>

    (   funcP1(x)  *     &larr;                x

s0  s1  s2         s<sub>top</sub>

</pre>

<p>
Empty stack has the initial state. The next stack entry generates the next state according the state machine
transition rule: 
</p>

<pre>

s1 = transition(s0,type_obr) ;
s2 = transition(s1,typeP) ;

....

</pre>

<p>
A decision is made based on the top state and the next atom. LR1 is a class of such languages, that
only a single decision can be done. 
<p>

<h2>LangLR1 output</h2>

<p>
LangLR1 generates two main output files: <b>State.ddl</b> and <b>Result.txt</b>.
<b>State.ddl</b> is a <b>DDL</b> description of the LR1 decoder for a further processing. It looks like:
</p>

<pre>

/* State.ddl */ 

RIndex RIndexLim = 7 ;
TIndex TIndexLim = 6 ;
NIndex NIndexLim = 3 ;
NTIndex NTIndexLim = 9 ; // T , N
StateIndex StateIndexLim = 22 ;
FinalIndex FinalIndexLim = 15 ;

Final[15] FinalTable=
 {
  { 0 ,
   {
    { 0 , RuleTable+0 },
    { 4 , RuleTable+0 }
   }
  },
  ....
 };

State[22] StateTable=
 {
  { 0 ,
   {
    { 1 , StateTable+1 },
    { 5 , StateTable+2 },
    { 6 , StateTable+3 },
    { 7 , StateTable+4 },
    { 8 , StateTable+16 }
   },
    FinalTable+7
  },
  ....
 };

text[6] TNames=
 {
  "(End)",
  "T(\"(\")",
  "T(\")\")",
  "T(\"*\")",
  "T(\"+\")",
  "T(\"x\")"
 };

Rule[7] RuleTable=
 {
  /* shift, special */ { 0 , "&lt;-" },
  { 1 , "A1" , 0 , { 7 } },
  { 2 , "A2" , 0 , { 6, 4, 7 } },
  { 3 , "M1" , 1 , { 8 } },
  { 4 , "M2" , 1 , { 8, 3, 7 } },
  { 5 , "P1" , 2 , { 5 } },
  { 6 , "P2" , 2 , { 1, 6, 2 } }
 };

NonTerminal[3] NonTerminalTable=
 {
  { 0 , "A" , { RuleTable+1, RuleTable+2 } },
  { 1 , "M" , { RuleTable+3, RuleTable+4 } },
  { 2 , "P" , { RuleTable+5, RuleTable+6 } }
 };

</pre>

<p>
The following type definitions are used (it can be found in <b>CCORE/tools/LangLR1-tools/StateTypes.ddl</b>):
</p>

<pre>

/* StateTypes.ddl */

type RIndex = uint ;
type TIndex = uint ;
type NIndex = uint ;
type NTIndex = uint ;
type StateIndex = uint ;
type FinalIndex = uint ;

struct Final
 {
  FinalIndex final;

  struct Action { TIndex t; Rule *rule; } [] actions;
 };

struct State
 {
  StateIndex state;

  struct Transition { NTIndex ntt; State *state; } [] transitions;

  Final *final;
 };

struct Rule
 {
  RIndex rule;
  text name;
  NIndex result;
  NTIndex[] str;
 };

struct NonTerminal
 {
  NIndex nt;
  text name;
  Rule * [] rules;
 };

</pre>

<p>
The type <b>RIndex</b> is used to index rules, <b>TIndex</b> &mdash; to index atoms (aka terminals),
<b>NIndex</b> &mdash; to index non-terminals, <b>NTIndex</b> &mdash; to index non-terminals and
atoms as the one set, where atoms go first, <b>StateIndex</b> &mdash; to index states,
<b>FinalIndex</b> &mdash; to index finals.
</p>

<p>
<b>RIndexLim</b> is the number of rules, the one special rule (shift) is added with index 0.
This rule denotes the stack shift operation.
</p>

<p>
<b>TIndexLim</b> is the number of atoms, the one special atom is added with index 0.
This atom denotes the end of input.
</p>

<p>
<b>NIndexLim</b> is the number of non-terminals.
</p>

<p>
<b>NTIndexLim</b> = <b>TIndexLim</b> + <b>NIndexLim</b>
</p>

<p>
<b>StateIndexLim</b> is the number of states. Initial state has index 0.
</p>

<p>
<b>FinalIndexLim</b> is the number of "finals". Each state has a correspondent final, which maps atoms to rules.
</p>

<p>
There are four types and five tables.
</p>

<p>
Atoms are described by <b>TNames</b> table. It is an atom name table. The name is build
like <b>T("name")</b>, where name is the atom name from the lang file: <b>T("(")</b>, <b>T(")")</b> 
etc...
</p>

<p>
<b>NonTerminaTable</b> describes non-terminals. It has a <b>NonTerminal</b> structure per each non-terminal.
</p>

<pre>

struct NonTerminal
 {
  NIndex nt;
  text name;
  Rule * [] rules;
 };

</pre>

<p>
<b>nt</b> is the non-terminal index.
</p>

<p>
<b>name</b> is the non-terminal name.
</p>

<p>
<b>rules</b> is the rule table for this non-terminal.
</p>

<p>
<b>RuleTable</b> describes rules. It has a <b>Rule</b> structure per each rule.
</p>

<pre>

struct Rule
 {
  RIndex rule;
  text name;
  NIndex result;
  NTIndex[] str;
 };

</pre>

<p>
<b>rule</b> is the rule index.
</p>

<p>
<b>name</b> is the rule name.
</p>

<p>
<b>result</b> is the result of the rule &mdash; the non-terminal index.
</p>

<p>
<b>str</b> is the rule itself, it is a sequence of atoms and non-terminals given by indexes.
</p>

<p>
The next table is the <b>StateTable</b>. It has a <b>State</b> structure per each state.
</p>

<pre>

struct State
 {
  StateIndex state;

  struct Transition { NTIndex ntt; State *state; } [] transitions;

  Final *final;
 };

</pre>

<p>
<b>state</b> is the state index.
</p>

<p>
<b>transitions</b> is the transition table. It consists of pairs: (<b>NTIndex</b> index, next state). 
If some index is missed here, the correspondent transition does not exist and will not 
appear during a decoding process.
</p>

<p>
<b>finals</b> points to the final. 
</p>

<p>
The last table is the <b>FinalTable</b>. It is a list of all finals.
</p>

<pre>

struct Final
 {
  FinalIndex final;

  struct Action { TIndex t; Rule *rule; } [] actions;
 };

</pre>

<p>
<b>final</b> is the final index.
</p>

<p>
<b>actions</b> is a list of pair: (atom index, rule). It is used to make a decision.
If some index is missed here, the correspondent atom cannot appear in a correct input sequence.
</p>

<p>
The file <b>Result.txt</b> is a more human readable description of the state machine. Each state here
has a path, leading to this state.
</p>

<pre>

/* Result.txt */ 

/* Finals */ 

Final 0
 {
  (End) -&gt; ( &lt;- )
  T("+") -&gt; ( &lt;- )
 }

Final 1
 {
  (End) -&gt; ( A1 )
  T("+") -&gt; ( A1 )
 }

Final 2
 {
  (End) -&gt; ( A2 )
  T("+") -&gt; ( A2 )
 }

Final 3
 {
  (End) -&gt; ( M1 )
  T("*") -&gt; ( &lt;- )
  T("+") -&gt; ( M1 )
 }

Final 4
 {
  (End) -&gt; ( M2 )
  T("+") -&gt; ( M2 )
 }

Final 5
 {
  (End) -&gt; ( P1 )
  T("*") -&gt; ( P1 )
  T("+") -&gt; ( P1 )
 }

Final 6
 {
  (End) -&gt; ( P2 )
  T("*") -&gt; ( P2 )
  T("+") -&gt; ( P2 )
 }

Final 7
 {
  T("(") -&gt; ( &lt;- )
  T("x") -&gt; ( &lt;- )
 }

Final 8
 {
  T(")") -&gt; ( &lt;- )
  T("+") -&gt; ( &lt;- )
 }

Final 9
 {
  T(")") -&gt; ( A1 )
  T("+") -&gt; ( A1 )
 }

Final 10
 {
  T(")") -&gt; ( A2 )
  T("+") -&gt; ( A2 )
 }

Final 11
 {
  T(")") -&gt; ( M1 )
  T("*") -&gt; ( &lt;- )
  T("+") -&gt; ( M1 )
 }

Final 12
 {
  T(")") -&gt; ( M2 )
  T("+") -&gt; ( M2 )
 }

Final 13
 {
  T(")") -&gt; ( P1 )
  T("*") -&gt; ( P1 )
  T("+") -&gt; ( P1 )
 }

Final 14
 {
  T(")") -&gt; ( P2 )
  T("*") -&gt; ( P2 )
  T("+") -&gt; ( P2 )
 }

/* Compressed States */ 

State 0
 : ( )
 {
  T("(") -&gt; State 1
  T("x") -&gt; State 2
  A -&gt; State 3
  M -&gt; State 4
  P -&gt; State 16
  ---------------------
  T("(") -&gt; ( &lt;- )
  T("x") -&gt; ( &lt;- )
 }

State 1
 : ( T("(") )
 {
  T("(") -&gt; State 5
  T("x") -&gt; State 6
  A -&gt; State 7
  M -&gt; State 8
  P -&gt; State 19
  ---------------------
  T("(") -&gt; ( &lt;- )
  T("x") -&gt; ( &lt;- )
 }

State 2
 : ( T("x") )
 {
  ---------------------
  (End) -&gt; ( P1 )
  T("*") -&gt; ( P1 )
  T("+") -&gt; ( P1 )
 }

State 3
 : ( A )
 {
  T("+") -&gt; State 9
  ---------------------
  (End) -&gt; ( &lt;- )
  T("+") -&gt; ( &lt;- )
 }

State 4
 : ( M )
 {
  ---------------------
  (End) -&gt; ( A1 )
  T("+") -&gt; ( A1 )
 }

State 5
 : ( T("(") , T("(") )
 {
  T("(") -&gt; State 5
  T("x") -&gt; State 6
  A -&gt; State 10
  M -&gt; State 8
  P -&gt; State 19
  ---------------------
  T("(") -&gt; ( &lt;- )
  T("x") -&gt; ( &lt;- )
 }

State 6
 : ( T("(") , T("x") )
 {
  ---------------------
  T(")") -&gt; ( P1 )
  T("*") -&gt; ( P1 )
  T("+") -&gt; ( P1 )
 }

State 7
 : ( T("(") , A )
 {
  T(")") -&gt; State 11
  T("+") -&gt; State 12
  ---------------------
  T(")") -&gt; ( &lt;- )
  T("+") -&gt; ( &lt;- )
 }

State 8
 : ( T("(") , M )
 {
  ---------------------
  T(")") -&gt; ( A1 )
  T("+") -&gt; ( A1 )
 }

State 9
 : ( A , T("+") )
 {
  T("(") -&gt; State 1
  T("x") -&gt; State 2
  M -&gt; State 14
  P -&gt; State 16
  ---------------------
  T("(") -&gt; ( &lt;- )
  T("x") -&gt; ( &lt;- )
 }

State 10
 : ( T("(") , T("(") , A )
 {
  T(")") -&gt; State 17
  T("+") -&gt; State 12
  ---------------------
  T(")") -&gt; ( &lt;- )
  T("+") -&gt; ( &lt;- )
 }

State 11
 : ( T("(") , A , T(")") )
 {
  ---------------------
  (End) -&gt; ( P2 )
  T("*") -&gt; ( P2 )
  T("+") -&gt; ( P2 )
 }

State 12
 : ( T("(") , A , T("+") )
 {
  T("(") -&gt; State 5
  T("x") -&gt; State 6
  M -&gt; State 18
  P -&gt; State 19
  ---------------------
  T("(") -&gt; ( &lt;- )
  T("x") -&gt; ( &lt;- )
 }

State 13
 : ( T("(") , P , T("*") )
 {
  T("(") -&gt; State 5
  T("x") -&gt; State 6
  M -&gt; State 20
  P -&gt; State 19
  ---------------------
  T("(") -&gt; ( &lt;- )
  T("x") -&gt; ( &lt;- )
 }

State 14
 : ( A , T("+") , M )
 {
  ---------------------
  (End) -&gt; ( A2 )
  T("+") -&gt; ( A2 )
 }

State 15
 : ( P , T("*") , M )
 {
  ---------------------
  (End) -&gt; ( M2 )
  T("+") -&gt; ( M2 )
 }

State 16
 : ( P , T("*") , P )
 {
  T("*") -&gt; State 21
  ---------------------
  (End) -&gt; ( M1 )
  T("*") -&gt; ( &lt;- )
  T("+") -&gt; ( M1 )
 }

State 17
 : ( T("(") , T("(") , A , T(")") )
 {
  ---------------------
  T(")") -&gt; ( P2 )
  T("*") -&gt; ( P2 )
  T("+") -&gt; ( P2 )
 }

State 18
 : ( T("(") , A , T("+") , M )
 {
  ---------------------
  T(")") -&gt; ( A2 )
  T("+") -&gt; ( A2 )
 }

State 19
 : ( T("(") , A , T("+") , P )
 {
  T("*") -&gt; State 13
  ---------------------
  T(")") -&gt; ( M1 )
  T("*") -&gt; ( &lt;- )
  T("+") -&gt; ( M1 )
 }

State 20
 : ( T("(") , P , T("*") , M )
 {
  ---------------------
  T(")") -&gt; ( M2 )
  T("+") -&gt; ( M2 )
 }

State 21
 : ( P , T("*") , P , T("*") )
 {
  T("(") -&gt; State 1
  T("x") -&gt; State 2
  M -&gt; State 15
  P -&gt; State 16
  ---------------------
  T("(") -&gt; ( &lt;- )
  T("x") -&gt; ( &lt;- )
 }

</pre>

</body>

</html>

