<!--
/* page_LangLR1.html */
//----------------------------------------------------------------------------------------
//
//  Project: CCore 1.02
//
//  License: Boost Software License - Version 1.0 - August 17th, 2003 
//
//            see http://www.boost.org/LICENSE_1_0.txt or the local copy
//
//  Copyright (c) 2012 Sergey Strukov. All rights reserved.
//
//----------------------------------------------------------------------------------------
-->

<!DOCTYPE html>
<html>

<head>

 <title>CCore -> LangLR1</title>

 <link href="CCore.css" rel="stylesheet" type="text/css">

</head>

<body>

<h2>LangLR1</h2>

<p>
<b>LangLR1</b> generates parsing state machine for an LR1 language.
</p>

<pre>
LangLR1.exe &lt;lang-name&gt; &lt;file.lang&gt; &lt;CCore-Root&gt;
</pre>

<p>
The first command line argument is the language name.
</p>

<p>
The second is the file with the language definition.
</p>

<p>
The third is the path to the <b>CCore</b> root directory.
</p>

<p>
Program generates two files in the working directoy: <b>Result.txt</b> and <b>State.ddl</b>.
It also generates the test directory <b>test</b>. Yoy can build and run a test project there.
</p>

<p>
<b>tools/LangLR1-tools/AMP</b> is a sample directory wth AMP language.
</p>

<h2>Context-free languages and grammars</h2>

<p>
Consider a non-empty finite set <b>Atom</b>. Elements of this set are called atoms.
Finite sequences of atoms are called words. They comprise another (infinite) set &mdash; 
<b>Atom<sup>*</sup></b>. From the abstarct algebra perspective, <b>Atom<sup>*</sup></b> is
a free monoid, generated by the <b>Atom</b>. This set has a natural binary operation &mdash;
word concatenation. Subsets of <b>Atom<sup>*</sup></b> are often called languages.
Thers is a class of languages, known as a context-free languages. These languages are defined
using a context-free grammars.
</p>

<p>
Consider an example &mdash; AMP language. This language is defined by the following grammar:
</p>

<pre>
/* AMP.lang */

A :
 {
  M     : A1
  A + M : A2
 }
 
M
 {
  P     : M1
  P * M : M2
 }
 
P
 {
  x     : P1
  ( A ) : P2 
 } 
</pre>

<p>
This grammar introduces three non-terminals: <b>A</b>, <b>M</b> and <b>P</b>.
Each non-terminal has a set of associated production rules. For example, <b>A</b> has two
rules: <b>A1</b> and <b>A2</b>. Each rule is a sequence of atoms and non-terminals.
For example, the rule <b>A2</b> is a length 3 sequence: ( <b>A</b> , <b>+</b> , <b>M</b> ).
The atom set is { <b>+</b> , <b>*</b> , <b>x</b> , <b>(</b> , <b>)</b> } and it is defined implicitly 
by the grammar. 
</p>

<p>
Non-terminal and rule names must be C-names. Atom names may be any string, to include one of the
character <b>{ } : `</b> prefix it with <b>`</b> character. You may not use <b>"</b> character.
</p>

<p>
Non-terminal <b>A</b> is marked with <b>:</b> character. The "value" of this non-terminal is 
included in the resulting language. You may mark several non-terminals, but usually only a single
non-terminal is marked as resulting.
</p>

<p>
Grammar produces a language per each non-terminal by the following inductive process:
</p>

<pre>

{A}<sub>0</sub> = empty

{M}<sub>0</sub> = empty

{P}<sub>0</sub> = empty

</pre>

<pre>

{A}<sub>n+1</sub> = union of
 {
  {M}<sub>n</sub>    
  {A}<sub>n</sub> + {M}<sub>n</sub>
 }
 
{M}<sub>n+1</sub> = union of
 {
  {P}<sub>n</sub>    
  {P}<sub>n</sub> * {M}<sub>n</sub>
 }
 
{P}<sub>n+1</sub> = union of
 {
  x    
  ( {A}<sub>n</sub> )
 } 

</pre>

<pre>

{A} = union of {A}<sub>n</sub>

{M} = union of {M}<sub>n</sub>

{P} = union of {P}<sub>n</sub>

</pre>

<p>
The following relations are satisfied:
</p>

<pre>

{A} = union of
 {
  {M}    
  {A} + {M}
 }
 
{M} = union of
 {
  {P}    
  {P} * {M}
 }
 
{P} = union of
 {
  x    
  ( {A} )
 } 

</pre>

<h2>Language decoding</h2>

<p>
Informally speaking, decoding a language according a grammar is a reconstruction of the way how
the given word is produced by grammar rules. If this way is unique, the grammar is called uniquely
decoded. There is a convenient formal definition of "uniquely decoded grammar".
</p>

<p>
Lets extend the initial grammar by the following way:
</p>

<pre>

A :
 {
  M     [A1] : A1
  A + M [A2] : A2
 }
 
M
 {
  P     [M1] : M1
  P * M [M2] : M2
 }
 
P
 {
  x     [P1] : P1
  ( A ) [P2] : P2 
 } 

</pre>

<p>
I.g. we append each rule by a special atom &mdash; one atom per each rule.
Lets denote the new sets as <b>{A[]}</b> etc...
Then if we take a word from the <b>{A[]}</b> and cleanup all extended atoms, then we receive
a word from <b>{A}</b>. So we get a map <b>clean: {A[]} &rarr; {A}</b> and other such maps.
They are surjective and grammare is uniquely decoded if they are bijective. I.g. if we know
the word from <b>{A}</b>, we can uniqiely up this word to the word from <b>{A[]}</b>. An doing
so we receive the production formula in the posfix form: 
</p>

<pre>

( x [P1] * x [P1] [M1] [M2] [A1] ) [P2] [M1] [A1] + x [P1] [M1] [A2]

( x * x ) + x

</pre>

<p>
If the grammar is uniquely decoded, it may be used to evaluate words. For evaluation some entities 
must be given. First, a set of types, one per each non-terminal and per each atom.
Second, the set of functions, one per each rule. Atom may carry a value of the correspondent type.
</p>

<pre>

type typeA;
type typeM;
type typeP;

type type_add;
type type_mul;
type type_obr;
type type_cbr;
type type_x;

typeA funcA1(typeM);
typeA funcA2(typeA,type_add,typeM);

typeM funcM1(typeP);
typeM funcM2(typeP,type_mul,typeM);

typeP funcP1(type_x);
typeP funcP2(type_obr,typeA,type_cbr);

</pre>

<p>
The evaluation process goes using a call stack.
</p>

<pre>

( x [P1]

( funcP1(x) * x [P1]

( funcP1(x) * funcP1(x) [M1]

( funcP1(x) * funcM1(funcP1(x)) [M2]

( funcM2(funcP1(x),*,funcM1(funcP1(x))) [A1]

( funcA1(funcM2(funcP1(x),*,funcM1(funcP1(x)))) ) [P2]

funcP2((,funcA1(funcM2(funcP1(x),*,funcM1(funcP1(x)))),)) [M1]

....

</pre>

<h2>LR1 decoder</h2>

<p>
LR1 decoder is a efficient language decoder. It is working with an evaluation stack.
It looks ahead on one atom and makes a choice: put this atom to the stack or apply a rule.
</p>

<pre>

( funcP1(x) *     &larr;                x

</pre>

<pre>

( funcP1(x) * x   [P1]             )

</pre>

</body>

</html>

