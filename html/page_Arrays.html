<!--
/* page_Arrays.html */
//----------------------------------------------------------------------------------------
//
//  Project: CCore 1.02
//
//  License: Boost Software License - Version 1.0 - August 17th, 2003 
//
//            see http://www.boost.org/LICENSE_1_0.txt or the local copy
//
//  Copyright (c) 2012 Sergey Strukov. All rights reserved.
//
//----------------------------------------------------------------------------------------
-->

<!DOCTYPE html>
<html>

<head>

 <title>CCore -> Arrays</title>

 <link href="CCore.css" rel="stylesheet" type="text/css">

</head>

<body>

<h2>Arrays</h2>

<p class="Files">Files <b>CCore/inc/Array.h</b> <b>CCore/src/Array.cpp</b></p>

<p class="Files">Subfolders <b>CCore/inc/array</b> <b>CCore/src/array</b></p>

<h3>Helpers</h3>

<p>
There are several types, which are used to specify the constructor behavior. 
</p>

<pre>

/* words */ 

enum DoBuildType { <span class="Att">DoBuild</span> };
 
enum DoReserveType { <span class="Att">DoReserve</span> };

</pre>

<p>
<b>DoBuild</b> and <b>DoReserve</b> are <b>word</b>s. They designate the build and the reserve variant of 
the constructor respectively.
</p>

<pre>

template &lt;int Sw&gt;
class DoSomething
 {
   ulen len;
   ulen maxlen;
   
  public: 
  
   explicit DoSomething(ulen len); // maxlen == len 
  
   DoSomething(ulen len,ulen maxlen); // maxlen >= len
   
   ulen getLen() const { return len; }
   
   ulen getMaxLen() const { return maxlen; }
 };
 
typedef DoSomething&lt;1&gt; <span class="Att">DoRaw</span>;

typedef DoSomething&lt;2&gt; <span class="Att">DoFill</span>; 

typedef DoSomething&lt;3&gt; <span class="Att">DoCopy</span>; 

typedef DoSomething&lt;4&gt; <span class="Att">DoCast</span>; 

typedef DoSomething&lt;5&gt; <span class="Att">DoSwap</span>; 

typedef DoSomething&lt;6&gt; <span class="Att">DoCreate</span>; 

</pre>

<p>
<b>DoRaw</b>, <b>DoFill</b>, <b>DoCopy</b>, <b>DoCast</b>, <b>DoSwap</b>, <b>DoCreate</b> are not <b>word</b>s, but 
<b>Small Data Type</b>s. They designate the correspondent variant of constructor and carry two parameters:
the array length and the reserved length. When the array is being created, the reserved length determines
the memory space to be allocated, and the length is the number of elements to be created. An exception is thrown,
if <b>len</b> is greater than <b>maxlen</b>.
</p>

<h3>Arrays</h3>

<p>
<b>Array</b> is a container, where multiple items comprise a continuous range.  
The simplest such "container" is the embedded type "array of" <b>T[Len]</b>.
Unfortunately, this type lacks many abilities, required in applications, so we need a variety
of <b>Array</b>s. We don't use STL <b>vector</b>, because it also has many deficiencies.
<b>CCore</b> <b>Array</b>s use the <b>CCore</b> heap with its extra functionality.
They also customizable using an <b>Algorithm Package</b> of array algorithms.
</p>

<p>
<b>CCore</b> <b>Array</b>s implement <b>Range Access Interface</b>. They also provide the index access to elements
through the overloaded <b>operator []</b> and the checked index access with the method <b>at()</b>.
</p>

<p>
Constant <b>CCore</b> <b>Array</b>s give constant access to its elements.
</p>

<p>
Allocation errors and index check errors throw exceptions. Default constructors are no-throw.
</p>

<p>
The method <b>apply()</b> applies the functor, given by a <a href="page_FunctorType.html"><b>Functor Init</b></a>, to array elements.
If the array is constant, then element references are constant too.
The variant <b>apply_const()</b> also enforces constness.
</p>

<p>
The method <b>applyReverse()</b> applies the functor, given by a <a href="page_FunctorType.html"><b>Functor Init</b></a>, to array elements
in the reverse order.
If the array is constant, then element references are constant too.
The variant <b>applyReverse_const()</b> also enforces constness.
</p>

<p>
<b>Array</b>s can be used with most types, there is no hard restrictions on type properties.
The only strong requirement is: the type destructor must be no-throw. Some operations, however,
require additional type properties. For example, to use <b>cloneTo()</b> methods the type must be copyable.
</p>

<p>
All <b>CCore</b> <b>Array</b>s available through the header <b>CCore/inc/Array.h</b>.
</p>

<h4>TempArray</h4>

<p>
<b>TempArray</b> is the simplest of <b>Array</b>s. It is applicable only to POD types.
This container combines stack storage and dynamic storage to speed up the array construction/destruction 
for a short lengths. Use this <b>Array</b> if you need a temporary buffer with expected short length in
the most cases.
</p>

<pre>

template &lt;class T,ulen StackLen&gt;
class <span class="Att">TempArray</span> : NoCopy
 {
  private:
  
   T *ptr;
   ulen len;
   
   T buf[StackLen];
   
  public:
   
   // constructors
   
   TempArray();
   
   explicit TempArray(ulen len);
   
   ~TempArray();
   
   // methods
   
   void provide(ulen len);
   
   void reset(ulen len);

   // range access
   
   T * getPtr() { return ptr; }
   
   const T * getPtr() const { return ptr; }
   
   const T * getPtr_const() const { return ptr; }
   
   ulen getLen() const { return len; }
   
   // index access
   
   T &amp; operator [] (ulen index);
   
   const T &amp; operator [] (ulen index) const;
   
   T &amp; at(ulen index);
   
   const T &amp; at(ulen index) const;
   
   // apply
   
   template &lt;class FuncInit&gt;
   void apply(FuncInit func_init);
   
   template &lt;class FuncInit&gt;
   void apply(FuncInit func_init) const;
   
   template &lt;class FuncInit&gt;
   void apply_const(FuncInit func_init) const;
   
   template &lt;class FuncInit&gt;
   void applyReverse(FuncInit func_init);
   
   template &lt;class FuncInit&gt;
   void applyReverse(FuncInit func_init) const;

   template &lt;class FuncInit&gt;
   void applyReverse_const(FuncInit func_init) const;
 };

</pre>

<p>
If the array length is not greater than <b>StackLen</b>, then <b>TempArray</b> uses the internal buffer.
Otherwise, the space for elements is dynamically allocated.
</p>

<p>
<b>provide()</b> ensures the array has at least the given length, reallocating it if required.
</p>

<p>
<b>reset()</b> recreates the array with the given length, reallocating it if required.
</p>

<p>
Other methods are standard array methods.
</p>

<h4>SimpleArray</h4>

<p>
<b>SimpleArray</b> is another "simple array". It is applicable to (almost) any types.
</p>

<p>
The second template argument of <b>SimpleArray</b> is an <b>Algorithm Package</b> of array algorithms.
<b>SimpleArray</b> uses only two of them: <b>Create_default()</b> and <b>Destroy()</b>.
See <a href="#ArrayAlgo">below</a> about array algorithms.
</p>

<pre>

template &lt;class T,class Algo=ArrayAlgo&lt;T&gt; &gt;
class <span class="Att">SimpleArray</span> : NoCopy
 {
   T *ptr;
   ulen len;
   
  public:
  
   // constructors
   
   explicit SimpleArray(ulen len=0);
   
   ~SimpleArray();
   
   // range access
   
   T * getPtr() { return ptr; }
   
   const T * getPtr() const { return ptr; }
   
   const T * getPtr_const() const { return ptr; }
   
   ulen getLen() const { return len; }
   
   // index access
   
   T &amp; operator [] (ulen index); 
   
   const T &amp; operator [] (ulen index) const; 
   
   T &amp; at(ulen index); 
    
   const T &amp; at(ulen index) const; 
   
   // apply
   
   template &lt;class FuncInit&gt;
   void apply(FuncInit func_init);
   
   template &lt;class FuncInit&gt;
   void apply(FuncInit func_init) const;
   
   template &lt;class FuncInit&gt;
   void apply_const(FuncInit func_init) const;
   
   template &lt;class FuncInit&gt;
   void applyReverse(FuncInit func_init);
   
   template &lt;class FuncInit&gt;
   void applyReverse(FuncInit func_init) const;

   template &lt;class FuncInit&gt;
   void applyReverse_const(FuncInit func_init) const;

   // swap/move objects
   
   void objSwap(SimpleArray&lt;T,Algo&gt; &amp;obj);
   
   explicit SimpleArray(ToMoveCtor&lt;SimpleArray&lt;T,Algo&gt; &gt; obj);
   
   SimpleArray&lt;T,Algo&gt; * objMove(Place&lt;void&gt; place);
 };

</pre>

<p>
<b>SimpleArray</b> allocates space dynamically.
</p>

<p>
Unlike <b>TempArray</b>, <b>SimpleArray</b> is swappable and movable.
</p>

<a name="DynArray"><h4>DynArray</h4></a>

<p>
<b>DynArray</b> is the "main" of <b>Array</b>s. It stores elements in a memory space with some
reserved memory behind. It can extend the range of elements, if there is an extra memory. 
If not and the type <b>T</b> supports <a href="page_Move.html">moving</a>, then the array extension can be performed
with either the memory block extension (using <b>MemExtend()</b>) or the total reallocation with the content moving.
You can also release the extra memory. All details of the array functionality can be customized using the 
second template argument, which is an <b>Algorithm Package</b> of array algorithms. You cannot
change heap functions though.
</p>

<p>
Alone with standard methods, <b>DynArray</b> has a bunch of methods to initialize and control the array content.
</p>

<pre>

template &lt;class T,class Algo=ArrayAlgo&lt;T&gt; &gt;
class <span class="Att">DynArray</span> : NoCopy
 {
   ....
 
  public:
  
   // constructors
   
   DynArray();
   
   template &lt;class S&gt;
   explicit DynArray(std::initializer_list&lt;S&gt; il); 
   
   explicit DynArray(ulen len); 
   
   DynArray(ulen len,ulen maxlen); 
    
   DynArray(DoReserveType,ulen maxlen); 
    
   explicit DynArray(DoRaw dotype); 
   
   template &lt;class ... SS&gt;
   explicit DynArray(DoFill dotype,SS &amp;&amp; ... ss); 
    
   DynArray(DoCopy dotype,const T src[]); 
   
   template &lt;class S&gt;
   DynArray(DoCast dotype,const S src[]); 
   
   DynArray(DoSwap dotype,T objs[]); 
   
   template &lt;class Creator&gt;
   DynArray(DoCreate dotype,Creator creator); 
    
   template &lt;class Builder&gt;
   DynArray(DoBuildType,Builder builder); 
    
   ~DynArray();

</pre>

<p>
Non-default constructors reserve some space and build
some elements. The <b>DoRaw</b>, ..., <b>DoCreate</b> arguments carry the length and the reserved
length of the array to be used.
</p>

<p>
Non-default constructors work the same way as the correspondent <b>extend...()</b> methods.
</p>

<p>
<b>DynArray(std::initializer_list&lt;S&gt; il)</b> uses the initialization list to "cast" 
elements from the given.
</p>
   
<p>
<b>DynArray(ulen len)</b> creates the array of the <b>len</b> elements using the default constructor.
</p>
   
<p>
<b>DynArray(ulen len,ulen maxlen)</b> also performs the default initialization of the <b>len</b> elements, 
but reserves a space for the <b>maxlen</b> elements. An exception is thrown,
if <b>len</b> is greater than <b>maxlen</b>.
</p>
   
<p>
<b>DynArray(DoReserveType,ulen maxlen)</b> just reserves a space.
</p>
   
<p>
<b>DynArray(DoRaw dotype)</b> performs the "raw" initialization. If the <b>T</b> is a POD type, elements
are not initialized. If not, the default initialization is performed.
</p>
   
<p>
<b>DynArray(DoFill dotype,SS &amp;&amp; ... ss)</b> creates new elements using some constructor, 
the specified arguments are forwarded to this constructor.
</p>
   
<p>
<b>DynArray(DoCopy dotype,const T src[])</b> creates new elements using the copy constructor, <b>src</b> 
is a range of length <b>dotype.getLen()</b>, its members are copied memberwise.
</p>
   
<p>
<b>DynArray(DoCast dotype,const S src[])</b> creates new elements using the "cast" constructor, <b>src</b> is a range of length
<b>dotype.getLen()</b>, its members are casted memberwise.
</p>
   
<p>
<b>DynArray(DoSwap dotype,T objs[])</b> creates new elements using the "swap move" approach. 
I.e. new elements are created using the default constructor and swapped with members of the range <b>objs</b>.
</p>
   
<p>
<b>DynArray(DoCreate dotype,Creator creator)</b> uses the given <b>Creator</b> object to create new elements.
</p>

<p>
<b>DynArray(DoBuildType,Builder builder)</b> uses the given <b>Builder</b> object to create new elements.
</p>

<pre>

   // range access
   
   T * getPtr();
   
   const T * getPtr() const;
   
   const T * getPtr_const() const;
   
   ulen getLen() const;
   
   ulen getMaxLen() const;
   
   ulen getExtraLen() const;
   
   // index access
   
   T &amp; operator [] (ulen index);
   
   const T &amp; operator [] (ulen index) const;
   
   T &amp; at(ulen index);
   
   const T &amp; at(ulen index) const;

</pre>

<p>
Range access and index access methods are standard. Two additional methods report memory allocation. 
</p>

<p>
<b>getMaxLen()</b> returns the reserved array length (in objects).
</p>

<p>
<b>getExtraLen()</b> is the extra space available (in objects)
</p>

<pre>

   // methods
   
   void cloneTo(DynArray&lt;T,Algo&gt; &amp;ret) const;
    
   void reserve(ulen extra_len);
   
   void erase();
    
</pre>

<p>
<b>cloneTo()</b> clones the array. The reserved length is also preserved. The type <b>T</b> must be copyable. 
</p>

<p>
<b>reserve()</b> reserves the space for <b>extra_len</b> objects.
</p>

<p>
<b>erase()</b> erases the array, it gets to the null state, with no objects and no memory allocated.
</p>

<pre>

   // shrink 
   
   ulen shrink(ulen delta_len);
    
   bool shrink_one();
    
   ulen shrink_all();
    
   void shrink_extra();
    
   void shrink_reserve(ulen maxlen);

   void shrink_reserve();

</pre>   

<p>
<b>shrink()</b> destroys the last up to <b>delta_len</b> elements of the array. It returns the 
number of elements destroyed.
</p>

<p>
<b>shrink_one()</b> destroys the last element (if any). It returns <b>true</b>, if the element is destroyed, and
<b>false</b> if the array is empty.
</p>

<p>
<b>shrink_all()</b> destroys all array elements. It returns the number of elements destroyed.
</p>

<p>
These three methods doesn't change the reserved array length.
</p>

<p>
<b>shrink_extra()</b> shrinks the memory block, returning the extra memory to the heap. After this method
the reserved array length becomes equal to the array length.
</p>

<p>
<b>shrink_reserve(ulen maxlen)</b> may shrink the memory block to store the given number of elements. It gives
a more precise control over the reserved memory. It works only if the following natural condition satisfied:
<b>maxlen&lt;getMaxLen()</b> and <b>maxlen&gt;=getLen()</b>.
</p>

<p>
<b>shrink_reserve()</b> works as <b>shrink_reserve(ulen maxlen)</b> with <b>maxlen</b> equals "double size" of the 
actual array length.
</p>

<pre>

   // extend
   
   PtrLen&lt;T&gt; extend_raw(ulen delta_len);
   
   PtrLen&lt;T&gt; extend_default(ulen delta_len);
   
   template &lt;class ... SS&gt;
   PtrLen&lt;T&gt; extend_fill(ulen delta_len,SS &amp;&amp; ... ss);
    
   PtrLen&lt;T&gt; extend_copy(ulen delta_len,const T src[]);
   
   template &lt;class S&gt;
   PtrLen&lt;T&gt; extend_cast(ulen delta_len,const S src[]);
   
   PtrLen&lt;T&gt; extend_swap(ulen delta_len,T objs[]);
   
   template &lt;class Creator&gt;
   PtrLen&lt;T&gt; extend(ulen delta_len,Creator creator);
   
   template &lt;class Builder&gt;
   PtrLen&lt;T&gt; extend(Builder builder);
   
</pre>   

<p>
<b>extend...()</b> is a family of methods, which extends the array with number elements. They differs in
element construction ways. All of them, except the last, has the first argument <b>delta_len</b>, 
which is the number of new elements. The return value is the range of these new elements.
<b>extend...()</b> are transactional, i.e. if the method has failed, then the array remains
in the original state, an exception is thrown.
</p>

<p>
<b>extend_raw()</b> for POD types leaves new elements uninitialized. For other types it works
like <b>extend_default()</b>.
</p>

<p>
<b>extend_default()</b> creates new elements using the default constructor.
</p>

<p>
<b>extend_fill()</b> creates new elements using some constructor, the specified arguments are forwarded
to this constructor.  
</p>

<p>
<b>extend_copy()</b> creates new elements using the copy constructor, <b>src</b> is a range of length
<b>delta_len</b>, its members are copied memberwise.
</p>

<p>
<b>extend_cast()</b> creates new elements using the "cast" constructor, <b>src</b> is a range of length
<b>delta_len</b>, its members are casted memberwise.
</p>

<p>
<b>extend_swap()</b> creates new elements using the "swap move" approach. I.e. new elements are 
created using the default constructor and swapped with members of the range <b>objs</b>.
</p>

<p>
Two final <b>extend()</b> are generic. The first of them uses the given <b>Creator</b> object to create 
new elements, and the second uses the <b>Builder</b>. See <a href="#Creator">below</a> explanations about <b>Creator</b>s and
<b>Builder</b>s.
</p>

<pre>

   // append
   
   T * append_raw();
   
   T * append_default();
    
   template &lt;class ... SS&gt;
   T * append_fill(SS &amp;&amp; ... ss); 
   
   T * append_copy(const T &amp;src);
   
   T * append_swap(T &amp;obj);
   
   template &lt;class Creator&gt;
   T * append(Creator creator);
   
</pre>   

<p>
<b>append...()</b> is a family of methods to append one element to the array. They are similar to the
correspondent <b>extend...()</b> methods and do exactly the same with <b>delta_len</b> equals 1.   
The return value is a pointer to the created element.
</p>

<pre>

   // apply
   
   template &lt;class FuncInit&gt;
   void apply(FuncInit func_init);
   
   template &lt;class FuncInit&gt;
   void apply(FuncInit func_init) const;
   
   template &lt;class FuncInit&gt;
   void apply_const(FuncInit func_init) const;
   
   template &lt;class FuncInit&gt;
   void applyReverse(FuncInit func_init);
   
   template &lt;class FuncInit&gt;
   void applyReverse(FuncInit func_init) const;

   template &lt;class FuncInit&gt;
   void applyReverse_const(FuncInit func_init) const;

</pre>

<p>
<b>apply...()</b> methods are standard.
</p>

<pre>

   // swap/move objects
   
   void objSwap(DynArray&lt;T,Algo&gt; &amp;obj);
   
   explicit DynArray(ToMoveCtor&lt;DynArray&lt;T,Algo&gt; &gt; obj);
    
   DynArray&lt;T,Algo&gt; * objMove(Place&lt;void&gt; place);
 };

</pre>

<p>
<b>DynArray</b> is swappable and movable.
</p>

<a name="RefArray"><h4>RefArray and AtomicRefArray</h4></a>

<p>
<b>RefArray</b> and <b>AtomicRefArray</b> are copyable arrays with efficient copy constructors.
It's assumed, the type <b>T</b> is copyable.
Multiple copies of arrays may share the same state. The state has a reference counter, which is used to
end its life-time. The only difference between <b>RefArray</b> and <b>AtomicRefArray</b> is the former
uses the atomic reference counting to be viable in a multi-threaded environment.
</p>

<p>
<b>RefArray</b> has a simulated value semantic. It means, that you may consider different copies of an array
as independent variables, despite they may share the state. That is because <b>RefArray</b> provides
only a constant access to elements. So far you don't violate this constness (using the const-cast, for example),
you may safely assume that each copy is different. To modify the array you have to call
the method <b>modify()</b> (or <b>modifyReverse()</b>). 
This method "unshares" the array, if necessary, and gives a non-constant access to elements.
<b>modifyReverse()</b> is doing the same thing as <b>modify()</b>, but gives a "reversed" range of elements.
</p>

<pre>

template &lt;class T,class Algo=ArrayAlgo&lt;T&gt; &gt;
class <span class="Att">RefArray</span>
 {
   ....

  public:
  
   // constructors
   
   RefArray();
   
   template &lt;class S&gt;
   explicit RefArray(std::initializer_list&lt;S&gt; il);
   
   explicit RefArray(ulen len); 
   
   RefArray(ulen len,ulen maxlen); 
    
   RefArray(DoReserveType,ulen maxlen); 
    
   explicit RefArray(DoRaw dotype); 
   
   template &lt;class ... SS&gt;
   explicit RefArray(DoFill dotype,SS &amp;&amp; ... ss); 
    
   RefArray(DoCopy dotype,const T src[]); 
 
   template &lt;class S&gt;
   RefArray(DoCast dotype,const S src[]); 
   
   RefArray(DoSwap dotype,T objs[]); 
   
   template &lt;class Creator&gt;
   RefArray(DoCreate dotype,Creator creator); 
    
   template &lt;class Builder&gt;
   RefArray(DoBuildType,Builder builder); 
    
   ~RefArray();
   
   // range access
   
   const T * getPtr() const;
   
   const T * getPtr_const() const;
   
   ulen getLen() const;
   
   ulen getMaxLen() const;
   
   ulen getExtraLen() const;
   
   // index access
   
   const T & operator [] (ulen index) const;
   
   const T & at(ulen index) const;
   
   // methods
   
   PtrLen&lt;T&gt; modify();
   
   PtrLenReverse&lt;T&gt; modifyReverse() { return RangeReverse(modify()); }

   void cloneTo(RefArray&lt;T,Algo&gt; &amp;ret) const;
    
   void reserve(ulen extra_len);
   
   void erase();
    
   // shrink
   
   ulen shrink(ulen delta_len);
    
   bool shrink_one();
    
   ulen shrink_all();
    
   void shrink_extra();
    
   void shrink_reserve(ulen maxlen);

   void shrink_reserve();

   // extend
   
   PtrLen&lt;T&gt; extend_raw(ulen delta_len);
   
   PtrLen&lt;T&gt; extend_default(ulen delta_len);
   
   template &lt;class ... SS&gt;
   PtrLen&lt;T&gt; extend_fill(ulen delta_len,SS &amp;&amp; ... ss);
    
   PtrLen&lt;T&gt; extend_copy(ulen delta_len,const T src[]);
   
   template &lt;class S&gt;
   PtrLen&lt;T&gt; extend_cast(ulen delta_len,const S src[]);
   
   PtrLen&lt;T&gt; extend_swap(ulen delta_len,T objs[]);
   
   template &lt;class Creator&gt;
   PtrLen&lt;T&gt; extend(ulen delta_len,Creator creator);
   
   template &lt;class Builder&gt;
   PtrLen&lt;T&gt; extend(Builder builder);
   
   // append
   
   T * append_raw();
    
   T * append_default();
    
   template &lt;class ... SS&gt;
   T * append_fill(SS &amp;&amp; ... ss); 
   
   T * append_copy(const T &amp;src);
   
   T * append_swap(T &amp;obj);
   
   template &lt;class Creator&gt;
   T * append(Creator creator);
   
   // apply
   
   template &lt;class FuncInit&gt;
   void apply_modify(FuncInit func_init);
   
   template &lt;class FuncInit&gt;
   void apply(FuncInit func_init) const;
   
   template &lt;class FuncInit&gt;
   void applyReverse_modify(FuncInit func_init);
   
   template &lt;class FuncInit&gt;
   void applyReverse(FuncInit func_init) const;

   // swap/move objects
   
   void objSwap(RefArray&lt;T,Algo&gt; &amp;obj);
   
   explicit RefArray(ToMoveCtor&lt;RefArray&lt;T,Algo&gt; &gt; obj);
   
   RefArray&lt;T,Algo&gt; * objMove(Place&lt;void&gt; place);
 };

</pre>

<p>
The <b>RefArray</b> methods are mostly the same as <b>DynArray</b> methods. The differences are:
index and range access methods gives only the constant access, and new class-specific methods <b>modify()</b>
and <b>modifyReverse()</b> exist.
</p>

<p>
<b>apply_modify()</b> applies the functor, given by a <a href="page_FunctorType.html"><b>Functor Init</b></a>, to array elements.
The array is unshared first.
</p>

<p>
<b>applyReverse_modify()</b> applies the functor, given by a <a href="page_FunctorType.html"><b>Functor Init</b></a>, to array elements
in the reverse order.
The array is unshared first.
</p>

<p>
<b>apply()</b> applies the functor, given by a <a href="page_FunctorType.html"><b>Functor Init</b></a>, to array elements.
This is a constant method.
</p>

<p>
<b>applyReverse()</b> applies the functor, given by a <a href="page_FunctorType.html"><b>Functor Init</b></a>, to array elements
in the reverse order.
This is a constant method.
</p>

<p>
<b>AtomicRefArray</b> methods <b>shrink_extra()</b> and <b>shrink_reserve()</b> are not working, if the array is shared.
</p>

<h4>Collector</h4>

<p>
<b>Collector</b> is not an array! The purpose of this container is to be an efficient collector of elements.
This container stores a sequence of elements in a list of arrays. So appending and extending 
operations are the most efficient. At desired moment you can copy or move this sequence into true array.
Or you can "flat" the <b>Collector</b> itself.
</p>

<pre>

template &lt;class T,class Algo=ArrayAlgo&lt;T&gt; &gt;
class <span class="Att">Collector</span> : NoCopy
 {
   ....

  public:
   
   // constructors
   
   static const ulen DefaultBlockLen = 1024 ;
   static const ulen MinBlockLen = 10 ;
   
   explicit Collector(ulen block_len=DefaultBlockLen);
   
   ~Collector();

</pre>   

<p>
The argument of the <b>Collector</b> constructor is the number of elements in the single element block.
The default value is 1024.
</p>

<pre>

   // methods
   
   ulen getLen() const; 
   
   void erase();
   
   template &lt;class Container&gt;
   void extractTo(Container &amp;ret)
    {
     Container temp(DoBuild,Extractor(this));
     
     Swap(temp,ret);
    }
   
   template &lt;class Container&gt;
   void copyTo(Container &amp;ret) const
    {
     Container temp(DoBuild,Copyrator(this));
     
     Swap(temp,ret);
    }
   
   PtrLen&lt;T&gt; flat();
   
</pre>

<p>
<b>Collector</b> does not provide a direct access to its content.
</p>

<p>
<b>getLen()</b> is the number of the collected elements.
</p>

<p>
<b>erase()</b> cleanup the container and put it into the null state.
</p>

<p>
<b>extractTo()</b> moves the content to another (array) container. The target container must have the <b>Build</b>
constructor. <b>Collector</b> becomes empty after this operation.
</p>

<p>
<b>copyTo()</b> copies the content to another (array) container. The target container must have the <b>Build</b>
constructor.
</p>

<p>
<b>flat()</b> rebuilds the internal data storage, making it continuous. It returns the range of elements.
This range remains valid after extend or append operations (but may become invalid after any other
modifying operations).
</p>

<pre>

   // shrink 
   
   ulen shrink(ulen delta_len);
    
   bool shrink_one();
    
   ulen shrink_all();
    
   // extend
   
   PtrLen&lt;T&gt; extend_raw(ulen delta_len);
   
   PtrLen&lt;T&gt; extend_default(ulen delta_len);
   
   template &lt;class ... SS&gt;
   PtrLen&lt;T&gt; extend_fill(ulen delta_len,SS &amp;&amp; ... ss);
    
   PtrLen&lt;T&gt; extend_copy(ulen delta_len,const T src[]);
   
   template &lt;class S&gt;
   PtrLen&lt;T&gt; extend_cast(ulen delta_len,const S src[]);
   
   PtrLen&lt;T&gt; extend_swap(ulen delta_len,T objs[]);
   
   template &lt;class Creator&gt;
   PtrLen&lt;T&gt; extend(ulen delta_len,Creator creator);
   
   template &lt;class Builder&gt;
   PtrLen&lt;T&gt; extend(Builder builder);
   
   // append
   
   T * append_raw();
   
   T * append_default();
    
   template &lt;class ... SS&gt;
   T * append_fill(SS &amp;&amp; ... ss); 
   
   T * append_copy(const T &amp;src);
   
   T * append_swap(T &amp;obj);
   
   template &lt;class Creator&gt;
   T * append(Creator creator);

</pre>   

<p>
<b>shrink...()</b>, <b>extend...()</b> and <b>append...()</b> methods are the same as for <b>DynArray</b>.
</p>

<pre>

   // swap/move object
   
   void objSwap(Collector&lt;T,Algo&gt; &amp;obj);
   
   explicit Collector(ToMoveCtor&lt;Collector&lt;T,Algo&gt; &gt; obj);
    
   Collector&lt;T,Algo&gt; * objMove(Place&lt;void&gt; place);
 };

</pre>

<p>
<b>Collector</b> is swappable and movable.
</p>

<a name="ArrayAlgo"><h3>Array algorithms</h3></a>

<p>
<b>CCore</b> <b>Array</b> implementation is based on the <b>Array Algorithm Package</b>s.
The default package is the <b>ArrayAlgo</b>.
</p>

<pre>

template &lt;class T,class Flags=NoThrowFlags&lt;T&gt; &gt; struct ArrayAlgo;

</pre>

<p>
The exact implementation depends on the kind of <b>T</b>.
</p>

<p>
If the type <b>T</b> defines the inner type <b>ArrayAlgoType</b>, then this type will be used
as the package.
</p>

<p>
Otherwise there are two variants: one for the POD types, another for the other (class) types.
</p>

<h4>ArrayAlgo_class</h4>

<p>
<b>ArrayAlgo_class</b> is the generic (class) variant. It is assumed, that the following operations: <b>~T()</b>,
<b>Move(T *,Place&lt;void&gt;)</b> and <b>Swap(T &amp;,T &amp;)</b> are <b>no-throw</b>.
The template argument <b>Flags</b> provides two flags: <b>Default_no_throw</b> and <b>Copy_no_throw</b>.
The flag is <b>true</b>, if the correspondent constructor (default or copy) is <b>no-throw</b> or does not exist.
It's an obligation of the class. 
</p>

<pre>

template &lt;class T,class Flags&gt;
struct <span class="Att">ArrayAlgo_class</span>
 {
  //
  //  assume ~T() , Move(T *,Place&lt;void&gt;) , Swap(T &amp;,T &amp;) no-throw
  //
 
  //
  //  Create...() : clean on throw
  //
  
  enum PropFlagType
   {
    Default_no_throw = Flags::Default_no_throw,
    Copy_no_throw = Flags::Copy_no_throw,
    
    MoveTo_exist = true
   };
 
  static PtrLen&lt;T&gt; Create_raw(Place&lt;void&gt; place,ulen len);
  
  static PtrLen&lt;T&gt; Create_default(Place&lt;void&gt; place,ulen len);
   
  template &lt;class ... SS&gt;
  static PtrLen&lt;T&gt; Create_fill(Place&lt;void&gt; place,ulen len,SS &amp;&amp; ... ss);
  
  static PtrLen&lt;T&gt; Create_copy(Place&lt;void&gt; place,ulen len,const T src[]);
  
  template &lt;class S&gt;
  static PtrLen&lt;T&gt; Create_cast(Place&lt;void&gt; place,ulen len,const S src[]);
  
  static PtrLen&lt;T&gt; Create_swap(Place&lt;void&gt; place,ulen len,T objs[]);
   
  //
  // using Creator
  //

  template &lt;class Creator&gt;
  static PtrLen&lt;T&gt; Create(Place&lt;void&gt; place,ulen len,Creator creator);
  
  //
  //  Single
  // 
  
  static T * Create_swap(Place&lt;void&gt; place,T &amp;obj) noexcept( EnableNoExcept && Default_no_throw );
   
  //
  //  ProvideLen() : double extension
  // 
  
  static ulen ProvideLen(ulen len,ulen maxlen,ulen extra_len);
   
  // 
  //  MoveTo() : no-throw
  //

  static PtrLen&lt;T&gt; MoveTo(T *ptr,ulen len,Place&lt;void&gt; place) noexcept(EnableNoExcept);

  //
  //  single Destroy() : no-throw
  // 
  
  static void Destroy(T *ptr) noexcept(EnableNoExcept);
  
  // 
  //  Destroy() : no-throw
  //
  
  static void Destroy(T *ptr,ulen len) noexcept(EnableNoExcept);

  //
  // Guards
  //

  class BuildGuard;
  class CreateGuard;
  class CreateGuard_nothrow;
  template &lt;bool no_throw&gt; class CreateGuardNoThrow;
 };

</pre>

<p>
The package has the following members.
</p>

<p>
Flags <b>Default_no_throw</b> and <b>Copy_no_throw</b> are copied from the <b>Flags</b>.
</p>

<p>
Flag <b>MoveTo_exist</b> is always <b>true</b>.
</p>

<p>
<b>Create_...()</b> creates a range of objects of the type <b>T</b> at the given place. To create an object,
the correspondent constructor is called. Objects are created in the ascending order. If some constructor
throw an exception, then the previously constructed objects are destroyed and the exception is propagated.
The range of the created objects is returned. The first two arguments are: the place to construct 
and the number of elements to construct. The place must be properly aligned and the memory space
must be large enough to contain the required number of objects.
</p>

<p>
<b>Create_raw()</b> and <b>Create_default()</b> use the default constructor.
</p>

<p>
<b>Create_fill()</b> uses a constructor with the given set of arguments for each object.
</p>

<p>
<b>Create_copy()</b> uses the copy constructor. The arguments are memberwise selected from the provided range of objects.
</p>

<p>
<b>Create_cast()</b> uses the "cast" constructor. The arguments are memberwise selected from the provided range of objects.
</p>

<p>
<b>Create_swap()</b> uses the default constructor and the swap operation to create objects. The arguments for 
the swap are memberwise selected from the provided range of objects.
</p>

<p>
<b>Create()</b> uses the given creator for the object creation. See <a href="#Creator">below</a> about creators.
</p>

<p>
The single <b>Create_swap()</b> function "creates-swap" a single object.
</p>

<p>
<b>ProvideLen()</b> is used to reallocate an array. It is called if there is no sufficient memory
to extend the array. The <b>len</b> is the array length, the <b>extra_len</b> is the number of extra
objects to be constructed, the <b>maxlen</b> is the allocated length. The length returned
is sufficient to extend the array and at least double of the <b>maxlen</b>. An exception is thrown in case of
overflow.
</p>

<p>
<b>MoveTo()</b> moves the given range to a new place. The old place becomes a raw memory. 
The range of new objects is returned.
</p>

<p>
Single <b>Destroy()</b> destroys the object (but don't free the memory).
</p>

<p>
Range <b>Destroy()</b> destroys the given range of objects.
</p>

<p>
There are four inner "guard" classes. They are used to created a range of objects. Guards are
responsible for the object destruction in case of failure. 
</p>

<pre>

class <span class="Att">BuildGuard</span> : NoCopy
 {
   Place&lt;void&gt; place;
   T *ptr;
   ulen len;
     
  public:
     
   explicit BuildGuard(Place&lt;void&gt; place_) : place(place_),ptr(place_),len(0) {}
     
   ~BuildGuard() { if( len ) Destroy(ptr,len); }
     
   Place&lt;void&gt; at() const { return place; }
     
   void operator ++ () { place+=sizeof (T); len++; }
     
   PtrLen&lt;T&gt; disarm() { return Range(ptr,Replace_null(len)); }
 };

</pre>

<p>
<b>BuildGuard</b> is used to create a range of objects. The constructor argument is the place
for the range. It must be properly aligned and the memory space must be large enough to store
the range.
</p>

<p>
<b>at()</b> is the current place for the object creation.
</p>

<p>
<b>operator ++ ()</b> must be called after the successful creation of an object at the current position, 
it moves to the next object position.
</p>

<p>
<b>disarm()</b> is called after the desired number of objects are created. It "disarms" the guard and
returns the created range.
</p>

<p>
The <b>BuildGuard</b> destructor destroys the created objects. It must be disarmed to prevent the destruction.
</p>

<pre>

class <span class="Att">CreateGuard</span> : public BuildGuard
 {
  public:
     
   CreateGuard(Place&lt;void&gt; place,ulen /*final_len*/) : BuildGuard(place) {}
     
   ~CreateGuard() {}
 };

</pre>

<p>
<b>CreateGuard</b> is used for creation a range of objects with the given length. 
Constructor's arguments are: the place of the range and the final number of objects.
The remaining methods are the same as for <b>BuildGuard</b>. Using <b>CreateGuard</b>
you must create the exact number of objects.
</p>

<pre>

class <span class="Att">CreateGuard_nothrow</span> : NoCopy
 {
   Place&lt;void&gt; place;
   T *ptr;
   ulen final_len;
     
  public:
     
   CreateGuard_nothrow(Place&lt;void&gt; place_,ulen final_len_) : place(place_),ptr(place_),final_len(final_len_) {}
     
   Place&lt;void&gt; at() const { return place; }
     
   void operator ++ () { place+=sizeof (T); }
     
   PtrLen&lt;T&gt; disarm() { return Range(ptr,final_len); }
 };

</pre>

<p>
<b>CreateGuard_nothrow</b> is a "no-throw" variant of the <b>CreateGuard</b>. It is used for the creation of
a range of objects with the given length, if there will be no exceptions during the objects construction.  
</p>

<pre>

template &lt;bool no_throw&gt;
class <span class="Att">CreateGuardNoThrow</span> : NoCopy
 {
  public:
     
   CreateGuardNoThrow(Place&lt;void&gt; place,ulen final_len);
    
   ~CreateGuardNoThrow();
 };

</pre>

<p>
<b>CreateGuardNoThrow</b> is the one of the <b>CreateGuard</b> and <b>CreateGuard_nothrow</b>, depending
on the <b>no_throw</b> template parameter.
</p>

<p>
Below is the implementation of the generic <b>Create</b>, it uses the <b>CreateGuardNoThrow</b>.
</p>

<pre>

template &lt;class Creator&gt;
static PtrLen&lt;T&gt; <span class="Att">Create</span>(Place&lt;void&gt; place,ulen len,Creator creator) noexcept( EnableNoExcept && Creator::NoThrow )
 {
  CreateGuardNoThrow&lt;Creator::NoThrow&gt; guard(place,len);
    
  FunctorTypeOf&lt;Creator&gt; func(creator);
    
  for(; len ;len--,++guard) func(guard.at());
    
  return guard.disarm();
 }

</pre>

<h4>ArrayAlgo_pod</h4>

<p>
<b>ArrayAlgo_pod</b> is the POD variant.
</p>

<pre>

template &lt;class T&gt;
struct <span class="Att">ArrayAlgo_pod</span>
 {
  //
  //  Create...() : clean on throw
  //
  
  enum PropFlagType
   {
    Default_no_throw = true,
    Copy_no_throw = true,
    
    MoveTo_exist = true
   };
 
  static PtrLen&lt;T&gt; Create_raw(Place&lt;void&gt; place,ulen len);
  
  static PtrLen&lt;T&gt; Create_default(Place&lt;void&gt; place,ulen len);
   
  template &lt;class ... SS&gt;
  static PtrLen&lt;T&gt; Create_fill(Place&lt;void&gt; place,ulen len,SS &amp;&amp; ... ss);
  
  static PtrLen&lt;T&gt; Create_copy(Place&lt;void&gt; place,ulen len,const T src[]);
  
  template &lt;class S&gt;
  static PtrLen&lt;T&gt; Create_cast(Place&lt;void&gt; place,ulen len,const S src[]);
  
  static PtrLen&lt;T&gt; Create_swap(Place&lt;void&gt; place,ulen len,T objs[]);
   
  //
  // using Creator
  //

  template &lt;class Creator&gt;
  static PtrLen&lt;T&gt; Create(Place&lt;void&gt; place,ulen len,Creator creator) noexcept( EnableNoExcept && Creator::NoThrow );
  
  //
  //  Single
  // 
  
  static T * Create_swap(Place&lt;void&gt; place,T &amp;obj) noexcept(EnableNoExcept);
   
  //
  //  ProvideLen() : double extension
  // 
  
  static ulen ProvideLen(ulen len,ulen maxlen,ulen extra_len);
   
  // 
  //  MoveTo() : no-throw
  //

  static PtrLen&lt;T&gt; MoveTo(T *ptr,ulen len,Place&lt;void&gt; place) noexcept(EnableNoExcept);

  //
  //  single Destroy() : empty
  // 
  
  static void Destroy(T *ptr) {}
  
  // 
  //  Destroy() : empty
  //
  
  static void Destroy(T *ptr,ulen len) {}

  //
  // Guards
  //

  class BuildGuard;
  class CreateGuard;
  class CreateGuard_nothrow;
  template &lt;bool no_throw&gt; class CreateGuardNoThrow;
 };

</pre>

<p>
Flags <b>Default_no_throw</b>, <b>Copy_no_throw</b> and <b>MoveTo_exist</b> are all <b>true</b>.
</p>

<p>
<b>Destroy()</b> functions are empty.
</p>

<p>
<b>Create_raw()</b> is not using default initialization. It leaves the memory uninitialized.
</p>

<h4>ArrayAlgo_mini</h4>

<p>
<b>ArrayAlgo_mini</b> is the mini variant without object moving.
It is assumed only, that the destructor <b>~T()</b> is <b>no-throw</b>. Swap and move are not used.
</p>

<pre>

template &lt;class T,class Flags&gt;
struct <span class="Att">ArrayAlgo_mini</span>
 {
  //
  //  assume ~T() no-throw
  //
 
  //
  //  Create...() : clean on throw
  //
  
  enum PropFlagType
   {
    Default_no_throw = Flags::Default_no_throw,
    Copy_no_throw = Flags::Copy_no_throw,
    
    MoveTo_exist = false
   };
 
  static PtrLen&lt;T&gt; Create_raw(Place&lt;void&gt; place,ulen len);
  
  static PtrLen&lt;T&gt; Create_default(Place&lt;void&gt; place,ulen len);
   
  template &lt;class ... SS&gt;
  static PtrLen&lt;T&gt; Create_fill(Place&lt;void&gt; place,ulen len,SS &amp;&amp; ... ss);
  
  static PtrLen&lt;T&gt; Create_copy(Place&lt;void&gt; place,ulen len,const T src[]);
  
  template &lt;class S&gt;
  static PtrLen&lt;T&gt; Create_cast(Place&lt;void&gt; place,ulen len,const S src[]);
  
  //
  // using Creator
  //

  template &lt;class Creator&gt;
  static PtrLen&lt;T&gt; Create(Place&lt;void&gt; place,ulen len,Creator creator) noexcept( EnableNoExcept && Creator::NoThrow );
  
  //
  //  single Destroy() : no-throw
  // 
  
  static void Destroy(T *ptr) noexcept(EnableNoExcept);
  
  // 
  //  Destroy() : no-throw
  //
  
  static void Destroy(T *ptr,ulen len) noexcept(EnableNoExcept);

  //
  // Guards
  //

  class BuildGuard;
  class CreateGuard;
  class CreateGuard_nothrow;
  template &lt;bool no_throw&gt; class CreateGuardNoThrow;
 };

</pre>

<p>
The flag <b>MoveTo_exist</b> is <b>false</b>.
</p>

<p>
The following functions: <b>Create_swap()</b>, <b>ProvideLen()</b>, <b>MoveTo()</b> are omitted.
Array, constructed with this algorithm package, cannot be extended beyond the initial allocation length.
</p>

<a name="Creator"><h4>Creators and Builders</h4></a>

<p>
<b>Creator</b> is a functor, creating objects. It looks like this:
</p>

<pre>

class Creator // copy efficient
 {
   ....

  public:

   enum NoThrowFlagType { NoThrow = .... };
  
   Creator(....);
  
   T * operator () (Place&lt;void&gt; place) noexcept(NoThrow);
 };

</pre>

<p>
Or like this:
</p>

<pre>

class Creator // copy efficient functor initializer
 {
   ....

  public:

   enum NoThrowFlagType { NoThrow = .... };

   Creator(....);

   class FunctorType : NoCopy // heavy functor
    {
      ....

     public:

      explicit FunctorType(Creator init);

      ~FunctorType();

      T * operator () (Place&lt;void&gt; place) noexcept(NoThrow);
    };
 };

</pre>

<p>
You may use a <b>Creator</b> in a generic array "Creator" constructors and methods.
</p>

<p>
<b>Builder</b> is a functor, creating a range of objects. It looks like:
</p>

<pre>

class Builder // copy efficient
 {
  public:

   Builder(....);

   ulen getLen() const;
   
   PtrLen&lt;T&gt; operator () (Place&lt;void&gt; place) const; // may create up to getLen() objects
 };

</pre>

<p>
Or like this:
</p>

<pre>

class Builder // copy efficient functor initializer
 {
  public:

   Builder(....);

   ulen getLen() const;

   class FunctorType : NoCopy // heavy functor
    {
      ....

     public:

      explicit FunctorType(Builder init);

      ~FunctorType();

      PtrLen&lt;T&gt; operator () (Place&lt;void&gt; place) const; // may create up to getLen() objects
    };
 };

</pre>

<p>
<b>Builder</b> reports the maximum object number it will create through the method <b>getLen()</b>. 
<b>operator ()</b> gets the place for the range of <b>getLen()</b> elements, it either creates
the range of objects up to this length and returns it, or leaves the memory raw and throws an exception.
</p>

<p>
You may use a <b>Builder</b> in a generic array "Builder" constructors and methods.
</p>

<h4>Standard creators</h4>

<p>
There is a list of standard creators.
</p>

<pre>

/* struct Creator_default&lt;T,bool no_throw&gt; */ 
 
template &lt;class T,bool no_throw&gt; 
struct <span class="Att">Creator_default</span>
 {
  enum NoThrowFlagType { NoThrow = no_throw };
  
  Creator_default() {}
  
  T * operator () (Place&lt;void&gt; place) noexcept( EnableNoExcept && no_throw )
   {
    return new(place) T();
   }
 };
 
/* struct Creator_fill&lt;T,SS&gt; */ 

template &lt;class T,class ... SS&gt; 
struct <span class="Att">Creator_fill</span>
 {
  enum NoThrowFlagType { NoThrow = false };
  
  ForwardTuple&lt;SS...&gt; ss;
  
  explicit Creator_fill(SS &amp;&amp; ... ss_) : ss( std::forward&lt;SS&gt;(ss_)... ) {}
  
  T * operator () (Place&lt;void&gt; place)
   {
    T *ret;
      
    ss.call( [&amp;ret,place] (SS &amp;&amp; ... ss) { ret=new(place) T( std::forward&lt;SS&gt;(ss)... ); } );
      
    return ret;
   }
 };
 
/* struct Creator_copy&lt;T,bool no_throw&gt; */ 

template &lt;class T,bool no_throw&gt; 
struct <span class="Att">Creator_copy</span>
 {
  enum NoThrowFlagType { NoThrow = no_throw };
  
  const T *src;
  
  explicit Creator_copy(const T *src_) : src(src_) {}
  
  T * operator () (Place&lt;void&gt; place) noexcept( EnableNoExcept && no_throw )
   {
    return new(place) T(*(src++));
   }
 };
 
/* struct Creator_cast&lt;T,S&gt; */ 
 
template &lt;class T,class S&gt; 
struct <span class="Att">Creator_cast</span>
 {
  enum NoThrowFlagType { NoThrow = false };
  
  const S *src;
  
  explicit Creator_cast(const S *src_) : src(src_) {}
  
  T * operator () (Place&lt;void&gt; place)
   {
    return new(place) T(*(src++));
   }
 };
 
/* struct Creator_swap&lt;T,Algo&gt; */ 

template &lt;class T,class Algo&gt;
struct <span class="Att">Creator_swap</span>
 {
  enum NoThrowFlagType { NoThrow = Algo::Default_no_throw };
  
  T *objs;
  
  explicit Creator_swap(T *objs_) : objs(objs_) {}
  
  T * operator () (Place&lt;void&gt; place) noexcept( EnableNoExcept && Algo::Default_no_throw )
   {
    return Algo::Create_swap(place,*(objs++));
   }
 };

</pre>

<h4>NoThrowFlags</h4>

<p>
The <b>NoThrowFlags</b> structure is a <b>Property Bag</b> with two flags: <b>Default_no_throw</b> and 
<b>Copy_no_throw</b>. The flag is <b>true</b>, if the correspondent object constructor does not exist or <b>no-throw</b>.
These flags are used to optimize algorithm implementations. The structure is a default "flags provider"
for the <b>ArrayAlgo</b> class.
</p>

<p>
The <b>NoThrowFlags</b> extracts the value of a flag from the inner declaration in the class if such declaration
exists:
</p>

<pre>

class SomeClass
 {
  public:

   enum NoThrowFlagType
    {
     Default_no_throw = ....,
     Copy_no_throw = ....
    };
 };

NoThrowFlags&lt;SomeClass&gt;::Default_no_throw == SomeClass::Default_no_throw

NoThrowFlags&lt;SomeClass&gt;::Copy_no_throw == SomeClass::Copy_no_throw

</pre>

<p>
If such declaration does not exist, it falls to <b>Meta::HasNoThrowDefault</b> and <b>Meta::HasNoThrowCopy</b>
meta-functions. These meta-functions are defined in the target <b>PlatformBase.h</b>.
They may be defined like this:
</p>

<pre>

/* struct HasNoThrowDefault&lt;T&gt; */

template &lt;class T&gt;
struct HasNoThrowDefault
 {
  enum RetType { Ret = !std::is_default_constructible&lt;T&gt;::value || 
                        std::is_nothrow_default_constructible&lt;T&gt;::value 
               };
 };

/* struct HasNoThrowCopy&lt;T&gt; */

template &lt;class T&gt;
struct HasNoThrowCopy
 {
  enum RetType { Ret = !std::is_copy_constructible&lt;T&gt;::value ||
                        std::is_nothrow_copy_constructible&lt;T&gt;::value 
               };
 };

</pre>

<p>
The <b>NoThrowFlags</b> is implemented in such a way, that it will emit a warning, if one of these flags is <b>false</b>.
This behavior is not desirable and it is highly recommended to design common classes either without
the default or copy constructor, or with <b>efficient</b> ones. 
</p>

<h4>NoThrowFlagsBase</h4>

<p>
The following class can be used to include no-throw flags in a class definition, simply specify it as 
the public base class.
</p>

<pre>

/* struct NoThrowFlagsBase */

struct <span class="Att">NoThrowFlagsBase</span>
 {
  // no-throw flags
  
  enum NoThrowFlagType
   {
    Default_no_throw = true,
    Copy_no_throw = true
   };
 };

</pre>

</body>

</html>

