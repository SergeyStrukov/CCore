<!--
/* page_Arrays.html */
//----------------------------------------------------------------------------------------
//
//  Project: CCore 1.02
//
//  License: Boost Software License - Version 1.0 - August 17th, 2003 
//
//            see http://www.boost.org/LICENSE_1_0.txt or the local copy
//
//  Copyright (c) 2012 Sergey Strukov. All rights reserved.
//
//----------------------------------------------------------------------------------------
-->

<!DOCTYPE html>
<html>

<head>

 <title>CCore -> Arrays</title>

 <link href="CCore.css" rel="stylesheet" type="text/css">

</head>

<body>

<h2>Arrays</h2>

<p class="Files">Files <b>CCore/inc/Array.h</b> <b>CCore/src/Array.cpp</b></p>

<p class="Files">Subfolders <b>CCore/inc/array</b> <b>CCore/src/array</b></p>

<h3>Helpers</h3>

<p>
There are several type, which are used to specify the constructor behavior. 
</p>

<pre>

/* words */ 

enum DoBuildType { <span class="Att">DoBuild</span> };
 
enum DoReserveType { <span class="Att">DoReserve</span> };

</pre>

<p>
<b>DoBuild</b> and <b>DoReserve</b> are <b>word</b>s. They designate the build and the reserve variant of constructor
respectively.
</p>

<pre>

template &lt;int Sw&gt;
class DoSomething
 {
   ulen len;
   ulen maxlen;
   
  public: 
  
   explicit DoSomething(ulen len); // maxlen == len 
  
   DoSomething(ulen len,ulen maxlen); // maxlen >= len
   
   ulen getLen() const { return len; }
   
   ulen getMaxLen() const { return maxlen; }
 };
 
typedef DoSomething&lt;1&gt; DoRaw;

typedef DoSomething&lt;2&gt; DoFill; 

typedef DoSomething&lt;3&gt; DoCopy; 

typedef DoSomething&lt;4&gt; DoCast; 

typedef DoSomething&lt;5&gt; DoSwap; 

typedef DoSomething&lt;6&gt; DoCreate; 

</pre>

<p>
<b>DoRaw</b>, <b>DoFill</b>, <b>DoCopy</b>, <b>DoCast</b>, <b>DoSwap</b>, <b>DoCreate</b> are not <b>word</b>s, but 
<b>Small Data Type</b>s. They designate the correspondent variant of constructor and carry two parameters:
the array length and the reserved length. When an array is being created, the reserved length determines
the memory space to be allocated, and the length is the number of elements to be created.
</p>

<h3>Arrays</h3>

<p>
<b>Array</b> is a container, where multiple items comprise a continuous range.  
The simplest such "container" is the embedded type "array of" <b>T[Len]</b>.
Unfortunately, this type lacks many abilities, required in applications, so we need a variety
of <b>Array</b>s. We don't use STL <b>vector</b>, because it also has many deficiencies, for example, it cannot contain
not copyable elements.
</p>

<p>
<b>CCore</b> <b>Array</b>s have <b>Range Access Interface</b>. They also provide the index access to elements
through the overloaded <b>operator []</b> and the checked index access with the method <b>at()</b>.
</p>

<p>
Constant <b>CCore</b> <b>Array</b>s give constant access to its elements.
</p>

<p>
Allocation errors and index check errors throw exceptions.
</p>

<p>
<b>Array</b>s can be used with the most types, there is no hard restrictions on the type properties.
The only strong requirement: the type destructor must be no-throw. Some operations, however,
require additional type properties. For example, to use <b>cloneTo()</b> methods the type must be copyable.
</p>

<p>
All <b>CCore</b> <b>Array</b>s available through the header <b>CCore/inc/Array.h</b>.
</p>

<h4>TempArray</h4>

<p>
<b>TempArray</b> is the simplest of <b>Array</b>s. It is applicable only to POD types.
This container combines stack storage and dynamic storage to speed up the array construction/destruction 
for a short lengths. Use this <b>Array</b> if you need a temporary buffer with expected short length in
the most cases.
</p>

<pre>
template &lt;class T,ulen StackLen&gt;
class <span class="Att">TempArray</span> : NoCopy
 {
  private:
  
   T *ptr;
   ulen len;
   
   T buf[StackLen];
   
  public:
   
   // constructors
   
   TempArray();
   
   explicit TempArray(ulen len);
   
   ~TempArray();
   
   // methods
   
   void provide(ulen len);
   
   // range access
   
   T * getPtr() { return ptr; }
   
   const T * getPtr() const { return ptr; }
   
   const T * getPtr_const() const { return ptr; }
   
   ulen getLen() const { return len; }
   
   // index access
   
   T &amp; operator [] (ulen index);
   
   const T &amp; operator [] (ulen index) const;
   
   T &amp; at(ulen index);
   
   const T &amp; at(ulen index) const;
   
   // apply
   
   template &lt;class FuncInit&gt;
   void apply(FuncInit func_init);
   
   template &lt;class FuncInit&gt;
   void apply(FuncInit func_init) const;
 };
</pre>

<p>
If the array length is not greater than <b>StackLen</b>, then <b>TempArray</b> uses the internal buffer.
Otherwise, the space for elements is dynamically allocated.
</p>

<p>
<b>provide()</b> ensures the array has at least the given length, reallocating it if required.
</p>

<p>
<b>apply()</b> applies the functor, given by a <a href="page_FunctorType.html"><b>Functor Init</b></a>, to array elements.
</p>

<h4>SimpleArray</h4>

<p>
<b>SimpleArray</b> is another "simple array". It is applicable to (almost) any types.
</p>

<p>
The second template argument of <b>SimpleArray</b> is an <b>Algorithm Package</b> of array algorithms.
<b>SimpleArray</b> uses only two of them: <b>Create_default()</b> and <b>Destroy()</b>.
See below about array algorithms.
</p>

<pre>
template &lt;class T,class Algo=ArrayAlgo&lt;T&gt; &gt;
class <span class="Att">SimpleArray</span> : NoCopy
 {
   T *ptr;
   ulen len;
   
  public:
  
   // constructors
   
   explicit SimpleArray(ulen len=0);
   
   ~SimpleArray();
   
   // range access
   
   T * getPtr() { return ptr; }
   
   const T * getPtr() const { return ptr; }
   
   const T * getPtr_const() const { return ptr; }
   
   ulen getLen() const { return len; }
   
   // index access
   
   T &amp; operator [] (ulen index); 
   
   const T &amp; operator [] (ulen index) const; 
   
   T &amp; at(ulen index); 
    
   const T &amp; at(ulen index) const; 
   
   // apply
   
   template &lt;class FuncInit&gt;
   void apply(FuncInit func_init);
   
   template &lt;class FuncInit&gt;
   void apply(FuncInit func_init) const;
   
   // swap/move objects
   
   void objSwap(SimpleArray&lt;T,Algo&gt; &amp;obj);
   
   explicit SimpleArray(ToMoveCtor&lt;SimpleArray&lt;T,Algo&gt; &gt; obj);
   
   SimpleArray&lt;T,Algo&gt; * objMove(Place&lt;void&gt; place);
 };
</pre>

<p>
<b>SimpleArray</b> allocates space dynamically.
</p>

<p>
<b>apply()</b> applies the functor, given by a <a href="page_FunctorType.html"><b>Functor Init</b></a>, to array elements.
</p>

<p>
Unlike <b>TempArray</b>, <b>SimpleArray</b> is swapable and moveable.
</p>

<h4>DynArray</h4>

<p>
<b>DynArray</b> is the "main" of <b>Array</b>s. It stores elements in a memory space with some
reserved memory behind. It allows extend the range of elements, if there is an extra memory. 
If not and the type <b>T</b> supports moving, then the array extension can be performed
with either the memory block extension (using <b>MemExtend()</b>) or the total reallocation with moving content.
You can also release the extra memory. All details of the array functionality can be customized using the 
second template argument, which is an <b>Algorithm Package</b> of array algorithms. You cannot
change heap functions though.
</p>

<p>
Alone with standard methods, <b>DynArray</b> has a bunch of methods to initialize and control the array content.
</p>

<pre>
template &lt;class T,class Algo=ArrayAlgo&lt;T&gt; &gt;
class <span class="Att">DynArray</span> : NoCopy
 {
   ....
 
  public:
  
   // constructors
   
   DynArray();
   
   template &lt;class S&gt;
   explicit DynArray(std::initializer_list&lt;S&gt; il); 
   
   explicit DynArray(ulen len); 
   
   DynArray(ulen len,ulen maxlen); 
    
   DynArray(DoReserveType,ulen maxlen); 
    
   explicit DynArray(DoRaw dotype); 
   
   template &lt;class ... SS&gt;
   explicit DynArray(DoFill dotype,SS &amp;&amp; ... ss); 
    
   DynArray(DoCopy dotype,const T src[]); 
   
   template &lt;class S&gt;
   DynArray(DoCast dotype,const S src[]); 
   
   DynArray(DoSwap dotype,T objs[]); 
   
   template &lt;class Creator&gt;
   DynArray(DoCreate dotype,Creator creator); 
    
   template &lt;class Builder&gt;
   DynArray(DoBuildType,Builder builder); 
    
   ~DynArray();

</pre>

<p>
Default constructor and destructor are no-throw. Non-default constructors reserve some space and build
some elements. The <b>DoRaw</b>, ..., <b>DoCreate</b> arguments carry the length and the reserved
length of the array to be used.
</p>

<p>
<b>DynArray(std::initializer_list&lt;S&gt; il)</b> uses an initialization list to "cast" 
the new elements from the given.
</p>
   
<p>
<b>DynArray(ulen len)</b> creates the array of the <b>len</b> elements using the default constructor.
</p>
   
<p>
<b>DynArray(ulen len,ulen maxlen)</b> also performs the default initialization of the <b>len</b> elements, 
but reserves a space for <b>maxlen</b> elements.
</p>
   
<p>
<b>DynArray(DoReserveType,ulen maxlen)</b> just reserves a space.
</p>
   
<p>
<b>DynArray(DoRaw dotype)</b> performes the "raw" initialization. If the <b>T</b> is a POD type, elements
are not initialized. If not, the default initialization if performed.
</p>
   
<p>
<b>DynArray(DoFill dotype,SS &amp;&amp; ... ss)</b> creates the new elements using some constructor, 
the specified arguments are forwarded to this constructor.
</p>
   
<p>
<b>DynArray(DoCopy dotype,const T src[])</b> creates the new elements using the copy constructor, <b>src</b> 
is a range of length <b>dotype.getLen()</b>, its members are copied memberwise.
</p>
   
<p>
<b>DynArray(DoCast dotype,const S src[])</b> creates the new elements using the "cast" constructor, <b>src</b> is a range of length
<b>dotype.getLen()</b>, its members are casted memberwise.
</p>
   
<p>
<b>DynArray(DoSwap dotype,T objs[])</b> creates the new elements using the "swap move" approach. 
I.e. the new elements are created using the default constructor and swapped with the members of the range <b>objs</b>.
</p>
   
<p>
<b>DynArray(DoCreate dotype,Creator creator)</b> uses the given <b>Creator</b> object to create the 
new elements.
</p>

<p>
<b>DynArray(DoBuildType,Builder builder)</b> uses the given <b>Builder</b> object to create the new elements.
</p>

<pre>
   // range access
   
   T * getPtr();
   
   const T * getPtr() const;
   
   const T * getPtr_const() const;
   
   ulen getLen() const;
   
   ulen getMaxLen() const;
   
   ulen getExtraLen() const;
   
   // index access
   
   T &amp; operator [] (ulen index);
   
   const T &amp; operator [] (ulen index) const;
   
   T &amp; at(ulen index);
   
   const T &amp; at(ulen index) const;

</pre>

<p>
Range access and index access methods are standard. Two additional methods reports memory allocation. 
</p>

<p>
<b>getMaxLen()</b> return the reserved array length (in objects).
</p>

<p>
<b>getExtraLen()</b> is the extra space available (in objects)
</p>

<pre>
   // methods
   
   void cloneTo(DynArray&lt;T,Algo&gt; &amp;ret) const;
    
   void reserve(ulen extra_len);
   
   void erase();
    
</pre>

<p>
<b>cloneTo()</b> clones the array. The reserved length is also preserved. The type <b>T</b> must be copyable. 
</p>

<p>
<b>reserve()</b> reserves the space for <b>extra_len</b> objects.
</p>

<p>
<b>erase()</b> erases the array, it gets to the null state, with no obects and no memory allocated.
</p>

<pre>
   // shrink 
   
   ulen shrink(ulen delta_len);
    
   bool shrink_one();
    
   ulen shrink_all();
    
   void shrink_extra();
    
</pre>   

<p>
<b>shrink()</b> destroys the last up to <b>delta_len</b> elements of the array. It returns the 
number of elements destroyed.
</p>

<p>
<b>shrink_one()</b> destroys the last element (if any). It returns true, if the element is destroyed, and
false if the array is empty.
</p>

<p>
<b>shrink_all()</b> destroys all array elements. It returns the number of elements destroyed.
</p>

<p>
These three methods doesn't change the reserved array length.
</p>

<p>
<b>shrink_extra()</b> shrinks the memory block, returning the extra memory to the heap. After this method
the reserved array length becomes equal to the array length.
</p>

<pre>
   // extend
   
   PtrLen&lt;T&gt; extend_raw(ulen delta_len);
   
   PtrLen&lt;T&gt; extend_default(ulen delta_len);
   
   template &lt;class ... SS&gt;
   PtrLen&lt;T&gt; extend_fill(ulen delta_len,SS &amp;&amp; ... ss);
    
   PtrLen&lt;T&gt; extend_copy(ulen delta_len,const T src[]);
   
   template &lt;class S&gt;
   PtrLen&lt;T&gt; extend_cast(ulen delta_len,const S src[]);
   
   PtrLen&lt;T&gt; extend_swap(ulen delta_len,T objs[]);
   
   template &lt;class Creator&gt;
   PtrLen&lt;T&gt; extend(ulen delta_len,Creator creator);
   
   template &lt;class Builder&gt;
   PtrLen&lt;T&gt; extend(Builder builder);
   
</pre>   

<p>
<b>extend...()</b> is a family of methods, which extends the array with number elements. They differs in
the element construction ways. All of them, except the last, has the first argument <b>delta_len</b>, 
which is the number of new elements. The return value is the range of these new elements.
<b>extend...()</b> are transactional, i.g. if the method if failed, then the array is remaining 
in the original state, the exception is thrown.
</p>

<p>
<b>extend_raw()</b> for POD types leaves the new elements uninitialized. For other types it works
like <b>extend_default()</b>.
</p>

<p>
<b>extend_default()</b> creates the new elements using the default constructor.
</p>

<p>
<b>extend_fill()</b> creates the new elements using some constructor, the specified arguments are forwarded
to this constructor.  
</p>

<p>
<b>extend_copy()</b> creates the new elements using the copy constructor, <b>src</b> is a range of length
<b>delta_len</b>, its members are copied memberwise.
</p>

<p>
<b>extend_cast()</b> creates the new elements using the "cast" constructor, <b>src</b> is a range of length
<b>delta_len</b>, its members are casted memberwise.
</p>

<p>
<b>extend_swap()</b> creates the new elements using the "swap move" approach. I.e. the new elements are 
created using the default constructor and swapped with the members of the range <b>objs</b>.
</p>

<p>
Two final <b>extend()</b> are generic. The first of them uses the given <b>Creator</b> object to create the 
new elements, and the second uses the <b>Builder</b>. See below explanations about <b>Creator</b>s and
<b>Builder</b>s.
</p>

<pre>
   // append
   
   T * append_raw();
   
   T * append_default();
    
   template &lt;class ... SS&gt;
   T * append_fill(SS &amp;&amp; ... ss); 
   
   T * append_copy(const T &amp;src);
   
   T * append_swap(T &amp;obj);
   
   template &lt;class Creator&gt;
   T * append(Creator creator);
   
</pre>   

<p>
<b>append...()</b> is a family of methods to append one element to the array. They are similar to the
correspondent <b>extend...()</b> methods and do exactly the same with <b>delta_len</b> equals 1.   
The return value is the pointer to the created element.
</p>

<pre>
   // apply
   
   template &lt;class FuncInit&gt;
   void apply(FuncInit func_init);
   
   template &lt;class FuncInit&gt;
   void apply(FuncInit func_init) const;
   
</pre>

<p>
<b>apply()</b> applies the functor, given by a <a href="page_FunctorType.html"><b>Functor Init</b></a>, to array elements.
</p>

<pre>
   // swap/move objects
   
   void objSwap(DynArray&lt;T,Algo&gt; &amp;obj);
   
   explicit DynArray(ToMoveCtor&lt;DynArray&lt;T,Algo&gt; &gt; obj);
    
   DynArray&lt;T,Algo&gt; * objMove(Place&lt;void&gt; place);
 };
</pre>

<p>
<b>DynArray</b> is swapable and moveable.
</p>

<h4>RefArray and AtomicRefArray</h4>

<p>
<b>RefArray</b> and <b>AtomicRefArray</b> are copyable arrays with efficient copy constructors.
It's assumed, the type <b>T</b> is copyable.
Multiple copies of arrays may share the same state. The state has a reference counter, which is used to
end its life-time. The only difference between <b>RefArray</b> and <b>AtomicRefArray</b> is the former
uses the atomic reference counting to be viable in a multithreaded environment.
</p>

<p>
<b>RefArray</b> has a simulated value semantic. It means that you may consider different copies of an array
as independent variables, despite they may share the state. That is because <b>RefArray</b> provides
only a constant access to elements. So far you don't violate this constantness (using the const-cast, for example),
you may safely assume the each copy is different. To modify an array you have to call
the method <b>modify()</b>. This method "unshares" the array, if necessary, and gives a non-constant access to
elements.
</p>

<pre>
template &lt;class T,class Algo=ArrayAlgo&lt;T&gt; &gt;
class <span class="Att">RefArray</span>
 {
   ....

  public:
  
   // constructors
   
   RefArray() {}
   
   template &lt;class S&gt;
   explicit RefArray(std::initializer_list&lt;S&gt; il);
   
   explicit RefArray(ulen len); 
   
   RefArray(ulen len,ulen maxlen); 
    
   RefArray(DoReserveType,ulen maxlen); 
    
   explicit RefArray(DoRaw dotype); 
   
   template &lt;class ... SS&gt;
   explicit RefArray(DoFill dotype,SS &amp;&amp; ... ss); 
    
   RefArray(DoCopy dotype,const T src[]); 
 
   template &lt;class S&gt;
   RefArray(DoCast dotype,const S src[]); 
   
   RefArray(DoSwap dotype,T objs[]); 
   
   template &lt;class Creator&gt;
   RefArray(DoCreate dotype,Creator creator); 
    
   template &lt;class Builder&gt;
   RefArray(DoBuildType,Builder builder); 
    
   ~RefArray();
   
   // range access
   
   const T * getPtr() const;
   
   const T * getPtr_const() const;
   
   ulen getLen() const;
   
   ulen getMaxLen() const;
   
   ulen getExtraLen() const;
   
   // index access
   
   const T & operator [] (ulen index) const;
   
   const T & at(ulen index) const;
   
   // methods
   
   PtrLen&lt;T&gt; modify();
   
   void cloneTo(RefArray&lt;T,Algo&gt; &amp;ret) const;
    
   void reserve(ulen extra_len);
   
   void erase();
    
   // shrink
   
   ulen shrink(ulen delta_len);
    
   bool shrink_one();
    
   ulen shrink_all();
    
   void shrink_extra();
    
   // extend
   
   PtrLen&lt;T&gt; extend_raw(ulen delta_len);
   
   PtrLen&lt;T&gt; extend_default(ulen delta_len);
   
   template &lt;class ... SS&gt;
   PtrLen&lt;T&gt; extend_fill(ulen delta_len,SS &amp;&amp; ... ss);
    
   PtrLen&lt;T&gt; extend_copy(ulen delta_len,const T src[]);
   
   template &lt;class S&gt;
   PtrLen&lt;T&gt; extend_cast(ulen delta_len,const S src[]);
   
   PtrLen&lt;T&gt; extend_swap(ulen delta_len,T objs[]);
   
   template &lt;class Creator&gt;
   PtrLen&lt;T&gt; extend(ulen delta_len,Creator creator);
   
   template &lt;class Builder&gt;
   PtrLen&lt;T&gt; extend(Builder builder);
   
   // append
   
   T * append_raw();
    
   T * append_default();
    
   template &lt;class ... SS&gt;
   T * append_fill(SS &amp;&amp; ... ss); 
   
   T * append_copy(const T &amp;src);
   
   T * append_swap(T &amp;obj);
   
   template &lt;class Creator&gt;
   T * append(Creator creator);
   
   // apply
   
   template &lt;class FuncInit&gt;
   void apply_modify(FuncInit func_init);
   
   template &lt;class FuncInit&gt;
   void apply(FuncInit func_init) const;
   
   // swap/move objects
   
   void objSwap(RefArray&lt;T,Algo&gt; &amp;obj);
   
   explicit RefArray(ToMoveCtor&lt;RefArray&lt;T,Algo&gt; &gt; obj);
   
   RefArray&lt;T,Algo&gt; * objMove(Place&lt;void&gt; place);
 };
</pre>

<p>
The <b>RefArray</b> methods are mostly the same as <b>DynArray</b> methods. The differences are:
index and range access methods gives only the constant access, and the new class-specific method <b>modify()</b>
exists.
</p>

<p>
<b>apply_modify()</b> applies the functor, given by a <a href="page_FunctorType.html"><b>Functor Init</b></a>, to array elements.
Before application the arrays is unshared.
</p>

<p>
<b>apply()</b> applies the functor, given by a <a href="page_FunctorType.html"><b>Functor Init</b></a>, to array elements.
This is a constant method.
</p>

<h4>Collector</h4>

<p>
<b>Collector</b> is not an array! The purpose of this container is to be an efficient collector of elements.
This container stores a sequense of elements in a list of arrays. So appending and extending 
operations are the most efficient. At desired moment you can copy or move this sequence into true array.
Or you can "flat" the <b>Collector</b> itself.
</p>

<pre>
template &lt;class T,class Algo=ArrayAlgo&lt;T&gt; &gt;
class <span class="Att">Collector</span> : NoCopy
 {
   ....

  public:
   
   // constructors
   
   static const ulen DefaultBlockLen = 1024 ;
   static const ulen MinBlockLen = 10 ;
   
   explicit Collector(ulen block_len=DefaultBlockLen);
   
   ~Collector();

</pre>   

<p>
The argument of the <b>Collector</b> constructor is the number of elements in the single element block.
The default value is 1024.
</p>

<pre>
   // methods
   
   ulen getLen() const; 
   
   void erase();
   
   template &lt;class Container&gt;
   void extractTo(Container &amp;ret)
    {
     Container temp(DoBuild,Extractor(this));
     
     Swap(temp,ret);
    }
   
   template &lt;class Container&gt;
   void copyTo(Container &amp;ret) const
    {
     Container temp(DoBuild,Copyrator(this));
     
     Swap(temp,ret);
    }
   
   PtrLen&lt;T&gt; flat();
   
</pre>

<p>
<b>Collector</b> does not provide a direct access to its content.
</p>

<p>
<b>getLen()</b> is the number of the collected elements.
</p>

<p>
<b>erase()</b> cleanup the container and put it into the null state.
</p>

<p>
<b>extractTo()</b> moves the content to another (array) container. The target container must have the <b>Build</b>
constructor. <b>Collector</b> becomes empty after this operation.
</p>

<p>
<b>copyTo()</b> copys the content to another (array) container. The target container must have the <b>Build</b>
constructor.
</p>

<p>
<b>flat()</b> rebuilds the internal data storage, making it continuous. It returns the range of elements.
This range remains valid after extend or append operations (but may become invalid after any other
modifying operation).
</p>

<pre>
   // shrink 
   
   ulen shrink(ulen delta_len);
    
   bool shrink_one();
    
   ulen shrink_all();
    
   // extend
   
   PtrLen&lt;T&gt; extend_raw(ulen delta_len);
   
   PtrLen&lt;T&gt; extend_default(ulen delta_len);
   
   template &lt;class ... SS&gt;
   PtrLen&lt;T&gt; extend_fill(ulen delta_len,SS &amp;&amp; ... ss);
    
   PtrLen&lt;T&gt; extend_copy(ulen delta_len,const T src[]);
   
   template &lt;class S&gt;
   PtrLen&lt;T&gt; extend_cast(ulen delta_len,const S src[]);
   
   PtrLen&lt;T&gt; extend_swap(ulen delta_len,T objs[]);
   
   template &lt;class Creator&gt;
   PtrLen&lt;T&gt; extend(ulen delta_len,Creator creator);
   
   template &lt;class Builder&gt;
   PtrLen&lt;T&gt; extend(Builder builder);
   
   // append
   
   T * append_raw();
   
   T * append_default();
    
   template &lt;class ... SS&gt;
   T * append_fill(SS &amp;&amp; ... ss); 
   
   T * append_copy(const T &amp;src);
   
   T * append_swap(T &amp;obj);
   
   template &lt;class Creator&gt;
   T * append(Creator creator);

</pre>   

<p>
<b>shrink...()</b>, <b>extend...()</b> and <b>append...()</b> methods are the same as for <b>DynArray</b>.
</p>

<pre>
   // swap/move object
   
   void objSwap(Collector&lt;T,Algo&gt; &amp;obj);
   
   explicit Collector(ToMoveCtor&lt;Collector&lt;T,Algo&gt; &gt; obj);
    
   Collector&lt;T,Algo&gt; * objMove(Place&lt;void&gt; place);
 };
</pre>

<p>
<b>Collector</b> is swapable and movable.
</p>

<h3>Array algorithms</h3>

<p>
<b>CCore</b> <b>Array</b> implementation is based on the <b>Array Algorithm Package</b>s.
The default package is the <b>ArrayAlgo</b>.
</p>

<pre>

template &lt;class T,class Flags=NoThrowFlags&lt;T&gt; &gt; struct ArrayAlgo;

</pre>

<p>
The exact implementation depends on the kind of <b>T</b>.
</p>

<p>
If the type <b>T</b> defines an inner type <b>ArrayAlgoType</b>, then this type will be used
as the package.
</p>

<p>
Otherwise there are two variants: one for the POD types, another for the other (class) types.
</p>

<h4>ArrayAlgo_class</h4>

<p>
<b>ArrayAlgo_class</b> is the generic (class) variant. It is assumed, that the following operations: <b>~T()</b>,
<b>Move(T *,Place&lt;void&gt;)</b> and <b>Swap(T &amp;,T &amp;)</b>; are <b>no-throw</b>.
The template argument <b>Flags</b> provides two flags: <b>Default_no_throw</b> and <b>Copy_no_throw</b>.
The flag is true, if the correspondent constructor (default or copy) is <b>no-throw</b> or does not exist.
</p>

<pre>
template &lt;class T,class Flags&gt;
struct <span class="Att">ArrayAlgo_class</span>
 {
  //
  //  assume ~T() , Move(T *,Place&lt;void&gt;) , Swap(T &amp;,T &amp;) no-throw
  //
 
  //
  //  Create...() : clean on throw
  //
  
  enum PropFlagType
   {
    Default_no_throw = Flags::Default_no_throw,
    Copy_no_throw = Flags::Copy_no_throw,
    
    MoveTo_exist = true
   };
 
  static PtrLen&lt;T&gt; Create_raw(Place&lt;void&gt; place,ulen len);
  
  static PtrLen&lt;T&gt; Create_default(Place&lt;void&gt; place,ulen len);
   
  template &lt;class ... SS&gt;
  static PtrLen&lt;T&gt; Create_fill(Place&lt;void&gt; place,ulen len,SS &amp;&amp; ... ss);
  
  static PtrLen&lt;T&gt; Create_copy(Place&lt;void&gt; place,ulen len,const T src[]);
  
  template &lt;class S&gt;
  static PtrLen&lt;T&gt; Create_cast(Place&lt;void&gt; place,ulen len,const S src[]);
  
  static PtrLen&lt;T&gt; Create_swap(Place&lt;void&gt; place,ulen len,T objs[]);
   
  //
  // using Creator
  //

  template &lt;class Creator&gt;
  static PtrLen&lt;T&gt; Create(Place&lt;void&gt; place,ulen len,Creator creator);
  
  //
  //  Single
  // 
  
  static T * Create_swap(Place&lt;void&gt; place,T &amp;obj) noexcept(EnableNoExcept);
   
  //
  //  ProvideLen() : double extension
  // 
  
  static ulen ProvideLen(ulen len,ulen maxlen,ulen extra_len);
   
  // 
  //  MoveTo() : no-throw
  //

  static PtrLen&lt;T&gt; MoveTo(T *ptr,ulen len,Place&lt;void&gt; place) noexcept(EnableNoExcept);

  //
  //  single Destroy() : no-throw
  // 
  
  static void Destroy(T *ptr) noexcept(EnableNoExcept);
  
  // 
  //  Destroy() : no-throw
  //
  
  static void Destroy(T *ptr,ulen len) noexcept(EnableNoExcept);

  //
  // Guards
  //

  class BuildGuard;
  class CreateGuard;
  class CreateGuard_nothrow;
  template &lt;bool no_throw&gt; class CreateGuardNoThrow;
 };
</pre>

<p>
The package has the following members.
</p>

<p>
Flags <b>Default_no_throw</b> and <b>Copy_no_throw</b> are copied from the <b>Flags</b>.
</p>

<p>
Flag <b>MoveTo_exist</b> is always true.
</p>

<p>
<b>Create_...()</b> creates a range of objects of the type <b>T</b> at the given place. To create an object,
the correspondent constructor is called. Objects are created in the ascending order. If the some constructor
throw an exception, then the previously constructed objects are destroyed and the exception is propagated.
The range of the created objects is returned. The first two arguments are: the place to construct 
and the number of elements to construct. The place must be propely aligned and the memory space
must be large enough to contain the required number of objects.
</p>

<p>
<b>Create_raw()</b> and <b>Create_default()</b> use the default constructor.
</p>

<p>
<b>Create_fill()</b> uses a constructor with the given set of arguments for each object.
</p>

<p>
<b>Create_copy()</b> uses the copy constructor. The arguments are selected from the provided range of objects.
</p>

<p>
<b>Create_cast()</b> uses the "cast" constructor. The arguments are selected from the provided range of objects.
</p>

<p>
<b>Create_swap()</b> uses the default constructor and the swap operation to create objects. The arguments for 
the swap are selected from the provided range of objects.
</p>

<p>
<b>Create()</b> uses the given creator for the object creation. See below about creators.
</p>

<p>
The single <b>Create_swap()</b> function "creates-swap" the single object.
</p>

<p>
<b>ProvideLen()</b> is used to reallocate an array. It is called if there is insufficient memory
to extend the array. The <b>len</b> is the array length, the <b>extra_len</b> is the number of extra
objects to be constructed, the <b>maxlen</b> is the allocated length. The length returned
is sufficient to extend the array and at least double of the <b>maxlen</b>.
</p>

<p>
<b>MoveTo()</b> moves the given range to the new place. The old place becomes a raw memory. 
The range of the new objects is returned.
</p>

<p>
Single <b>Destroy()</b> destroys the object (but don't free the memory).
</p>

<p>
Range <b>Destroy()</b> destroys the given range of objects.
</p>

<p>
There are four inner "guard" classes. They are used to created a range of objects. Guards are
responsible for the object destruction in case of failure. 
</p>

<pre>
class <span class="Att">BuildGuard</span> : NoCopy
 {
   Place&lt;void&gt; place;
   T *ptr;
   ulen len;
     
  public:
     
   explicit BuildGuard(Place&lt;void&gt; place_) : place(place_),ptr(place_),len(0) {}
     
   ~BuildGuard() { if( len ) Destroy(ptr,len); }
     
   Place&lt;void&gt; at() const { return place; }
     
   void operator ++ () { place+=sizeof (T); len++; }
     
   PtrLen&lt;T&gt; disarm() { return Range(ptr,Replace_null(len)); }
 };
</pre>

<p>
<b>BuildGuard</b> is used to create a range of objects. The constructor argument is the place
for the range. It must be properly aligned and the memory space must be large enough to store
the range.
</p>

<p>
<b>at()</b> is the current place for the object creation.
</p>

<p>
<b>operator ++ ()</b> must be called after the sucessfull creation of an object at the current position, 
it moves to the next object position.
</p>

<p>
<b>disarm()</b> is called after the desired number of objects are created. It "disarms" the gurad and
returns the created range.
</p>

<p>
The <b>BuildGuard</b> destructor destroys the created objects. It must be disarmed to prevent the destruction.
</p>

<pre>
class <span class="Att">CreateGuard</span> : public BuildGuard
 {
  public:
     
   CreateGuard(Place&lt;void&gt; place,ulen /*final_len*/) : BuildGuard(place) {}
     
   ~CreateGuard() {}
 };
</pre>

<p>
<b>CreateGuard</b> is used for creation a range of objects with the given length. 
Constructor's arguments are: the place of the range and the final number of objects.
The remaining methods are the same as for <b>BuildGuard</b>. Using <b>CreateGuard</b>
you must create the exact number of objects.
</p>

<pre>
class <span class="Att">CreateGuard_nothrow</span> : NoCopy
 {
   Place&lt;void&gt; place;
   T *ptr;
   ulen final_len;
     
  public:
     
   CreateGuard_nothrow(Place&lt;void&gt; place_,ulen final_len_) : place(place_),ptr(place_),final_len(final_len_) {}
     
   Place&lt;void&gt; at() const { return place; }
     
   void operator ++ () { place+=sizeof (T); }
     
   PtrLen&lt;T&gt; disarm() { return Range(ptr,final_len); }
 };
</pre>

<p>
<b>CreateGuard_nothrow</b> is a "no-throw" variant of the <b>CreateGuard</b>. It is used for creation
a range of objects with the given length, if we are sure there will be no exceptions during the objects 
construction.  
</p>

<pre>
template &lt;bool no_throw&gt;
class <span class="Att">CreateGuardNoThrow</span> : NoCopy
 {
  public:
     
   CreateGuardNoThrow(Place&lt;void&gt; place,ulen final_len);
    
   ~CreateGuardNoThrow();
 };
</pre>

<p>
<b>CreateGuardNoThrow</b> is the one of the <b>CreateGuard</b> and <b>CreateGuard_nothrow</b>, depending
on the <b>no_throw</b> template argument.
</p>

<p>
Below is the implementation of the generic <b>Create</b>, it uses <b>CreateGuardNoThrow</b>.
</p>

<pre>
template &lt;class Creator&gt;
static PtrLen&lt;T&gt; <span class="Att">Create</span>(Place&lt;void&gt; place,ulen len,Creator creator)
 {
  CreateGuardNoThrow&lt;Creator::NoThrow&gt; guard(place,len);
    
  FunctorTypeOf&lt;Creator&gt; func(creator);
    
  for(; len ;len--,++guard) func(guard.at());
    
  return guard.disarm();
 }
</pre>

<h4>ArrayAlgo_pod</h4>

<p>
<b>ArrayAlgo_pod</b> is the POD variant.
</p>

<pre>
template &lt;class T&gt;
struct <span class="Att">ArrayAlgo_pod</span>
 {
  //
  //  Create...() : clean on throw
  //
  
  enum PropFlagType
   {
    Default_no_throw = true,
    Copy_no_throw = true,
    
    MoveTo_exist = true
   };
 
  static PtrLen&lt;T&gt; Create_raw(Place&lt;void&gt; place,ulen len);
  
  static PtrLen&lt;T&gt; Create_default(Place&lt;void&gt; place,ulen len);
   
  template &lt;class ... SS&gt;
  static PtrLen&lt;T&gt; Create_fill(Place&lt;void&gt; place,ulen len,SS &amp;&amp; ... ss);
  
  static PtrLen&lt;T&gt; Create_copy(Place&lt;void&gt; place,ulen len,const T src[]);
  
  template &lt;class S&gt;
  static PtrLen&lt;T&gt; Create_cast(Place&lt;void&gt; place,ulen len,const S src[]);
  
  static PtrLen&lt;T&gt; Create_swap(Place&lt;void&gt; place,ulen len,T objs[]);
   
  //
  // using Creator
  //

  template &lt;class Creator&gt;
  static PtrLen&lt;T&gt; Create(Place&lt;void&gt; place,ulen len,Creator creator);
  
  //
  //  Single
  // 
  
  static T * Create_swap(Place&lt;void&gt; place,T &amp;obj) noexcept(EnableNoExcept);
   
  //
  //  ProvideLen() : double extension
  // 
  
  static ulen ProvideLen(ulen len,ulen maxlen,ulen extra_len);
   
  // 
  //  MoveTo() : no-throw
  //

  static PtrLen&lt;T&gt; MoveTo(T *ptr,ulen len,Place&lt;void&gt; place) noexcept(EnableNoExcept);

  //
  //  single Destroy() : empty
  // 
  
  static void Destroy(T *ptr) {}
  
  // 
  //  Destroy() : empty
  //
  
  static void Destroy(T *ptr,ulen len) {}

  //
  // Guards
  //

  class BuildGuard;
  class CreateGuard;
  class CreateGuard_nothrow;
  template &lt;bool no_throw&gt; class CreateGuardNoThrow;
 };
</pre>

<p>
Flags <b>Default_no_throw</b>, <b>Copy_no_throw</b> and <b>MoveTo_exist</b> are all true.
</p>

<p>
<b>Destroy()</b> functions are empty.
</p>

<p>
<b>Create_raw()</b> is not using default initialization. It leaves the memory uninitialized.
</p>

<h4>ArrayAlgo_mini</h4>

<p>
<b>ArrayAlgo_mini</b> is the mini variant without object moving.
It is assumed, that the destructor <b>~T()</b> is <b>no-throw</b>. Swap and move are not used.
</p>

<pre>
template &lt;class T,class Flags&gt;
struct <span class="Att">ArrayAlgo_mini</span>
 {
  //
  //  assume ~T() no-throw
  //
 
  //
  //  Create...() : clean on throw
  //
  
  enum PropFlagType
   {
    Default_no_throw = Flags::Default_no_throw,
    Copy_no_throw = Flags::Copy_no_throw,
    
    MoveTo_exist = false
   };
 
  static PtrLen&lt;T&gt; Create_raw(Place&lt;void&gt; place,ulen len);
  
  static PtrLen&lt;T&gt; Create_default(Place&lt;void&gt; place,ulen len);
   
  template &lt;class ... SS&gt;
  static PtrLen&lt;T&gt; Create_fill(Place&lt;void&gt; place,ulen len,SS &amp;&amp; ... ss);
  
  static PtrLen&lt;T&gt; Create_copy(Place&lt;void&gt; place,ulen len,const T src[]);
  
  template &lt;class S&gt;
  static PtrLen&lt;T&gt; Create_cast(Place&lt;void&gt; place,ulen len,const S src[]);
  
  //
  // using Creator
  //

  template &lt;class Creator&gt;
  static PtrLen&lt;T&gt; Create(Place&lt;void&gt; place,ulen len,Creator creator);
  
  //
  //  single Destroy() : no-throw
  // 
  
  static void Destroy(T *ptr) noexcept(EnableNoExcept);
  
  // 
  //  Destroy() : no-throw
  //
  
  static void Destroy(T *ptr,ulen len) noexcept(EnableNoExcept);

  //
  // Guards
  //

  class BuildGuard;
  class CreateGuard;
  class CreateGuard_nothrow;
  template &lt;bool no_throw&gt; class CreateGuardNoThrow;
 };
</pre>

<p>
The flag <b>MoveTo_exist</b> is false.
</p>

<p>
The following functions: <b>Create_swap()</b>, <b>ProvideLen()</b>, <b>MoveTo()</b>; are ommited.
Array, constructed with this algorithm package cannot extend itself beyond the original allocation length.
</p>

<h4>Creators and Builders</h4>

<p>
<b>Creator</b> is a functor, creating objects. It looks like this:
</p>

<pre>
class Creator // copy efficient
 {
   ....

  public:

   enum NoThrowFlagType { NoThrow = .... };
  
   Creator(....);
  
   T * operator () (Place&lt;void&gt; place) noexcept(NoThrow);
 };
</pre>

<p>
Or like this:
</p>

<pre>
class Creator // copy efficient functor initializer
 {
   ....

  public:

   enum NoThrowFlagType { NoThrow = .... };

   Creator(....);

   class FunctorType : NoCopy // heavy functor
    {
      ....

     public:

      explicit FunctorType(Creator init);

      ~FunctorType();

      T * operator () (Place&lt;void&gt; place) noexcept(NoThrow);
    };
 };
</pre>

<p>
You may use a <b>Creator</b> in a generic array "Creator" constructors and methods.
</p>

<p>
<b>Builder</b> is a functor, creating a range of objects. It looks like:
</p>

<pre>
class Builder // copy efficient
 {
  public:

   Builder(....);

   ulen getLen() const;
   
   PtrLen&lt;T&gt; operator () (Place&lt;void&gt; place) const; // may create up to getLen() objects
 };
</pre>

<p>
Or like this:
</p>

<pre>
class Builder // copy efficient functor initializer
 {
  public:

   Builder(....);

   ulen getLen() const;

   class FunctorType : NoCopy // heavy functor
    {
      ....

     public:

      explicit FunctorType(Builder init);

      ~FunctorType();

     PtrLen&lt;T&gt; operator () (Place&lt;void&gt; place) const; // may create up to getLen() objects
    };
 };
</pre>

<p>
<b>Builder</b> reports the maximum object number it will create through the method <b>getLen()</b>. 
<b>operator ()</b> gets the place for the range of <b>getLen()</b> elements, it either creates
the range of objects up to this length and returns it, or leaves the memory raw and throw an exception.
</p>

<p>
You may use a <b>Builder</b> in a generic array "Builder" constructors and methods.
</p>

<h4>Standard creators</h4>

<p>
There is a list of standard creators.
</p>

<pre>
/* struct Creator_default&lt;T,bool no_throw&gt; */ 
 
template &lt;class T,bool no_throw&gt; 
struct <span class="Att">Creator_default</span>
 {
  enum NoThrowFlagType { NoThrow = no_throw };
  
  Creator_default() {}
  
  T * operator () (Place&lt;void&gt; place) noexcept( EnableNoExcept && no_throw )
   {
    return new(place) T();
   }
 };
 
/* struct Creator_fill&lt;T,SS&gt; */ 

template &lt;class T,class ... SS&gt; 
struct <span class="Att">Creator_fill</span>
 {
  enum NoThrowFlagType { NoThrow = false };
  
  ForwardTuple&lt;SS...&gt; ss;
  
  explicit Creator_fill(SS &amp;&amp; ... ss_) : ss( std::forward&lt;SS&gt;(ss_)... ) {}
  
  T * operator () (Place&lt;void&gt; place)
   {
    T *ret;
      
    ss.call( [&amp;ret,place] (SS &amp;&amp; ... ss) { ret=new(place) T( std::forward&lt;SS&gt;(ss)... ); } );
      
    return ret;
   }
 };
 
/* struct Creator_copy&lt;T,bool no_throw&gt; */ 

template &lt;class T,bool no_throw&gt; 
struct <span class="Att">Creator_copy</span>
 {
  enum NoThrowFlagType { NoThrow = no_throw };
  
  const T *src;
  
  explicit Creator_copy(const T *src_) : src(src_) {}
  
  T * operator () (Place&lt;void&gt; place) noexcept( EnableNoExcept && no_throw )
   {
    return new(place) T(*(src++));
   }
 };
 
/* struct Creator_cast&lt;T,S&gt; */ 
 
template &lt;class T,class S&gt; 
struct <span class="Att">Creator_cast</span>
 {
  enum NoThrowFlagType { NoThrow = false };
  
  const S *src;
  
  explicit Creator_cast(const S *src_) : src(src_) {}
  
  T * operator () (Place&lt;void&gt; place)
   {
    return new(place) T(*(src++));
   }
 };
 
/* struct Creator_swap&lt;T,Algo&gt; */ 

template &lt;class T,class Algo&gt;
struct <span class="Att">Creator_swap</span>
 {
  enum NoThrowFlagType { NoThrow = true };
  
  T *objs;
  
  explicit Creator_swap(T *objs_) : objs(objs_) {}
  
  T * operator () (Place&lt;void&gt; place) noexcept(EnableNoExcept)
   {
    return Algo::Create_swap(place,*(objs++));
   }
 };
</pre>

<h4>NoThrowFlags</h4>

<p>
The <b>NoThrowFlags</b> structure is a <b>Property Bag</b> with two flags: <b>Default_no_throw</b> and 
<b>Copy_no_throw</b>. The flag is true if the correspondent object constructor does not exist or <b>no-throw</b>.
These flags are used to optimize the algorithm implementations. The structure is a default "flags provider"
for the <b>ArrayAlgo</b> class.
</p>

<p>
The <b>NoThrowFlags</b> extracts the value of a flag from the inner declaration of the class if such declaration
exists:
</p>

<pre>

class SomeClass
 {
  public:

   enum NoThrowFlagType
    {
     Default_no_throw = ....,
     Copy_no_throw = ....
    };
 };

NoThrowFlags&lt;SomeClass&gt;::Default_no_throw == SomeClass::Default_no_throw

NoThrowFlags&lt;SomeClass&gt;::Copy_no_throw == SomeClass::Copy_no_throw

</pre>

<p>
If such declaration does not exist, it falls to <b>Meta::HasNoThrowDefault</b> and <b>Meta::HasNoThrowCopy</b>
meta-functions. These meta-functions are defined in the <b>PlatformBase.h</b> target header.
They may be defined like this:
</p>

<pre>
/* struct HasNoThrowDefault&lt;T&gt; */

template &lt;class T&gt;
struct HasNoThrowDefault
 {
  enum RetType { Ret = !std::is_default_constructible&lt;T&gt;::value || 
                        std::is_nothrow_default_constructible&lt;T&gt;::value 
               };
 };

/* struct HasNoThrowCopy&lt;T&gt; */

template &lt;class T&gt;
struct HasNoThrowCopy
 {
  enum RetType { Ret = !std::is_copy_constructible&lt;T&gt;::value ||
                        std::is_nothrow_copy_constructible&lt;T&gt;::value 
               };
 };
</pre>

<p>
The <b>NoThrowFlags</b> is implemented in such a way, that it will emit a warning, if one of these flags is false.
This behavior is not desirable and it is highly recommended to design common classes either without
the default or copy constructor, or with <b>efficient</b> ones. 
</p>

</body>

</html>

