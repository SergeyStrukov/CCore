<!--
/* page_Arrays.html */
//----------------------------------------------------------------------------------------
//
//  Project: CCore 1.02
//
//  License: Boost Software License - Version 1.0 - August 17th, 2003 
//
//            see http://www.boost.org/LICENSE_1_0.txt or the local copy
//
//  Copyright (c) 2012 Sergey Strukov. All rights reserved.
//
//----------------------------------------------------------------------------------------
-->

<!DOCTYPE html>
<html>

<head>

 <title>CCore -> Arrays</title>

 <link href="CCore.css" rel="stylesheet" type="text/css">

</head>

<body>

<h2>Arrays</h2>

<p class="Files">Files <b>CCore/inc/Array.h</b> <b>CCore/src/Array.cpp</b></p>

<p class="Files">Subfolders <b>CCore/inc/array</b> <b>CCore/src/array</b></p>

<h3>Helpers</h3>

<p>
There are several type, which are used to specify the constructor behavior. 
</p>

<pre>

/* words */ 

enum DoBuildType { <span class="att">DoBuild</span> };
 
enum DoReserveType { <span class="att">DoReserve</span> };

</pre>

<p>
<b>DoBuild</b> and <b>DoReserve</b> are <b>word</b>s. They designate the build and the reserve type of construction
respectively.
</p>

<pre>

template &lt;int Sw&gt;
class DoSomething
 {
   ulen len;
   ulen maxlen;
   
  public: 
  
   explicit DoSomething(ulen len); // maxlen == len 
  
   DoSomething(ulen len,ulen maxlen); // maxlen >= len
   
   ulen getLen() const { return len; }
   
   ulen getMaxLen() const { return maxlen; }
 };
 
typedef DoSomething&lt;1&gt; DoRaw;

typedef DoSomething&lt;2&gt; DoFill; 

typedef DoSomething&lt;3&gt; DoCopy; 

typedef DoSomething&lt;4&gt; DoCast; 

typedef DoSomething&lt;5&gt; DoSwap; 

typedef DoSomething&lt;6&gt; DoCreate; 

</pre>

<p>
<b>DoRaw</b>, <b>DoFill</b>, <b>DoCopy</b>, <b>DoCast</b>, <b>DoSwap</b>, <b>DoCreate</b> are not <b>word</b>s, but 
<b>Small Data Type</b>s. They designate the correspondent type of construction and carry two parameters:
the array length and the reserved length. When an array is being creating, the reserved length determines
the memory space to be allocated, and the length is the number of elements to be created.
</p>

<h3>Arrays</h3>

<p>
<b>Array</b> is a container, where multiple items comprise a continuous range.  
The simplest such "container" is the embedded type "array of" <b>T[Len]</b>.
Unfortunately, this type lacks many abilities, required in applications, so we need a variaty
of <b>Array</b>s. We don't use STL <b>vector</b>, because it also has many deficiencies, for example, it cannot contain
not copyable elements.
</p>

<p>
<b>CCore</b> <b>Array</b>s have <b>Range Access Interface</b>. They also provide the index access to elements
through overloaded <b>operator []</b> and checked index access with the method <b>at()</b>.
</p>

<p>
Constant <b>CCore</b> <b>Array</b>s give constant access to its elements.
</p>

<p>
Allocation errors and index check errors throw exceptions.
</p>

<p>
<b>Array</b>s can be used with the most types, there is no hard restrictions on the type properties.
The only strong requirement: the type destructor must be no-throw. Some operation, however,
requires additional type properties. For example, to use the <b>cloneTo()</b> methods the type must be copyable.
</p>

<p>
All <b>CCore</b> <b>Array</b>s available through the header <b>CCore/inc/Array.h</b>.
</p>

<h4>TempArray</h4>

<p>
<b>TempArray</b> is the simplest of <b>Array</b>s. It is applicable only to POD types.
This container combines stack storage and dynamic storage to speed up the array construction/destruction 
for a short lengths. Use this <b>Array</b> if you need a temporary buffer with expected short length in
the most cases.
</p>

<pre>
template &lt;class T,ulen StackLen&gt;
class <span class="att">TempArray</span> : NoCopy
 {
  private:
  
   T *ptr;
   ulen len;
   
   T buf[StackLen];
   
  public:
   
   // constructors
   
   TempArray();
   
   explicit TempArray(ulen len);
   
   ~TempArray();
   
   // methods
   
   void provide(ulen len);
   
   // range access
   
   T * getPtr() { return ptr; }
   
   const T * getPtr() const { return ptr; }
   
   const T * getPtr_const() const { return ptr; }
   
   ulen getLen() const { return len; }
   
   // index access
   
   T &amp; operator [] (ulen index);
   
   const T &amp; operator [] (ulen index) const;
   
   T &amp; at(ulen index);
   
   const T &amp; at(ulen index) const;
 };
</pre>

<p>
If the array length is not greater than <b>StackLen</b>, then <b>TempArray</b> uses the internal buffer.
Otherwise, the space for elements is dynamically allocated.
</p>

<p>
<b>provide()</b> ensures the array have at least the given length, reallocating it if required.
</p>

<h4>SimpleArray</h4>

<p>
<b>SimpleArray</b> is another "simple array". It is applicable to (almost) any types.
</p>

<p>
The second template argument of <b>SimpleArray</b> is an <b>Algorithm Package</b> of array algorithms.
<b>SimpleArray</b> uses only two of them: <b>Create_default()</b> and <b>Destroy()</b>.
See below about array algorithms.
</p>

<pre>
template &lt;class T,class Algo=ArrayAlgo&lt;T&gt; &gt;
class <span class="att">SimpleArray</span> : NoCopy
 {
   T *ptr;
   ulen len;
   
  public:
  
   // constructors
   
   explicit SimpleArray(ulen len=0);
   
   ~SimpleArray();
   
   // range access
   
   T * getPtr() { return ptr; }
   
   const T * getPtr() const { return ptr; }
   
   const T * getPtr_const() const { return ptr; }
   
   ulen getLen() const { return len; }
   
   // index access
   
   T &amp; operator [] (ulen index); 
   
   const T &amp; operator [] (ulen index) const; 
   
   T &amp; at(ulen index); 
    
   const T &amp; at(ulen index) const; 
   
   // swap/move objects
   
   void objSwap(SimpleArray&lt;T,Algo&gt; &amp;obj);
   
   explicit SimpleArray(ToMoveCtor&lt;SimpleArray&lt;T,Algo&gt; &gt; obj);
   
   SimpleArray&lt;T,Algo&gt; * objMove(Place&lt;void&gt; place);
 };
</pre>

<p>
<b>SimpleArray</b> allocates space dynamically.
</p>

<p>
Unlike <b>TempArray</b>, <b>SimpleArray</b> is swapable and moveable.
</p>

<h4>DynArray</h4>

<p>
<b>DynArray</b> is the "main" of <b>Array</b>s. It stores elements in a memory space with some
reserved memory behind. It allows extend the range of elements, if there is an extra memory. 
If not and the type <b>T</b> supports moving, then the array extension can be performed
with either the memory block extension (using <b>MemExtend()</b>) or total reallocation with moving content.
You can also release the extra memory. All details of the array functionality can be customized using the 
second template argument, which is an <b>Algorithm Package</b> of array algorithms. You cannot
change the heap functions though.
</p>

<p>
Alone with the standard methods, <b>DynArray</b> has a bunch of methods to initialize and control the array content.
</p>

<pre>
template &lt;class T,class Algo=ArrayAlgo&lt;T&gt; &gt;
class <span class="att">DynArray</span> : NoCopy
 {
   ....
 
  public:
  
   // constructors
   
   DynArray();
   
   template &lt;class S&gt;
   explicit DynArray(std::initializer_list&lt;S&gt; il); 
   
   explicit DynArray(ulen len); 
   
   DynArray(ulen len,ulen maxlen); 
    
   DynArray(DoReserveType,ulen maxlen); 
    
   explicit DynArray(DoRaw dotype); 
   
   template &lt;class ... SS&gt;
   explicit DynArray(DoFill dotype,SS &amp;&amp; ... ss); 
    
   DynArray(DoCopy dotype,const T src[]); 
   
   template &lt;class S&gt;
   DynArray(DoCast dotype,const S src[]); 
   
   DynArray(DoSwap dotype,T objs[]); 
   
   template &lt;class Creator&gt;
   DynArray(DoCreate dotype,Creator creator); 
    
   template &lt;class Builder&gt;
   DynArray(DoBuildType,Builder builder); 
    
   ~DynArray();

</pre>

<p>
Default constructor and destructor are no-throw. Non-default constructors reserve some space and build
some elements. The <b>DoRaw</b>, ..., <b>DoCreate</b> arguments carry the length and the reserved
length of the array to be used.
</p>

<p>
<b>DynArray(std::initializer_list&lt;S&gt; il)</b> uses an initialization list to "cast" 
the new elements from the given.
</p>
   
<p>
<b>DynArray(ulen len)</b> creates the array of the <b>len</b> elements using the default constructor.
</p>
   
<p>
<b>DynArray(ulen len,ulen maxlen)</b> also performs the default initialization of the <b>len</b> elements, 
but reserves a space for <b>maxlen</b> elements.
</p>
   
<p>
<b>DynArray(DoReserveType,ulen maxlen)</b> just reserves a space.
</p>
   
<p>
<b>DynArray(DoRaw dotype)</b> performes the "raw" initialization. If the <b>T</b> is a POD type, elements
are not initialized. If not, the default initialization if performed.
</p>
   
<p>
<b>DynArray(DoFill dotype,SS &amp;&amp; ... ss)</b> creates the new elements using some constructor, 
the specified arguments are forwarded to this constructor.
</p>
   
<p>
<b>DynArray(DoCopy dotype,const T src[])</b> creates the new elements using the copy constructor, <b>src</b> 
is a range of length <b>dotype.getLen()</b>, its members are copied memberwise.
</p>
   
<p>
<b>DynArray(DoCast dotype,const S src[])</b> creates the new elements using the "cast" constructor, <b>src</b> is a range of length
<b>dotype.getLen()</b>, its members are casted memberwise.
</p>
   
<p>
<b>DynArray(DoSwap dotype,T objs[])</b> creates the new elements using the "swap move" approach. 
I.e. the new elements are created using the default constructor and swapped with the members of the range <b>objs</b>.
</p>
   
<p>
<b>DynArray(DoCreate dotype,Creator creator)</b> uses the given <b>Creator</b> object to create the 
new elements.
</p>

<p>
<b>DynArray(DoBuildType,Builder builder)</b> uses the given <b>Builder</b> object to create the new elements.
</p>

<pre>
   // range access
   
   T * getPtr();
   
   const T * getPtr() const;
   
   const T * getPtr_const() const;
   
   ulen getLen() const;
   
   ulen getMaxLen() const;
   
   ulen getExtraLen() const;
   
   // index access
   
   T &amp; operator [] (ulen index);
   
   const T &amp; operator [] (ulen index) const;
   
   T &amp; at(ulen index);
   
   const T &amp; at(ulen index) const;

</pre>

<p>
Range access and index access methods are standard. Two additional methods reports memory allocation. 
</p>

<p>
<b>getMaxLen()</b> return the reserved array length (in objects).
</p>

<p>
<b>getExtraLen()</b> is the extra space available (in objects)
</p>

<pre>
   // methods
   
   void cloneTo(DynArray&lt;T,Algo&gt; &amp;ret) const;
    
   void reserve(ulen extra_len);
   
   void erase();
    
</pre>

<p>
<b>cloneTo()</b> clones the array. The reserved length is also preserved. The type <b>T</b> must be copyable. 
</p>

<p>
<b>reserve()</b> reserves the space for <b>extra_len</b> objects.
</p>

<p>
<b>erase()</b> erases the array, it gets to the null state, with no obects and no memory allocated.
</p>

<pre>
   // shrink 
   
   ulen shrink(ulen delta_len);
    
   bool shrink_one();
    
   ulen shrink_all();
    
   void shrink_extra();
    
</pre>   

<p>
<b>shrink()</b> destroys the last up to <b>delta_len</b> elements of the array. It returns the 
number of elements destroyed.
</p>

<p>
<b>shrink_one()</b> destroys the last element (if any). It returns true, if the element is destroyed, and
false if the array is empty.
</p>

<p>
<b>shrink_all()</b> destroys all array elements. It returns the number of elements destroyed.
</p>

<p>
These three methods doesn't change the reserved array length.
</p>

<p>
<b>shrink_extra()</b> shrinks the memory block, returning the extra memory to the heap. After this method
the reserved array length becomes equal to the array length.
</p>

<pre>
   // extend
   
   PtrLen&lt;T&gt; extend_raw(ulen delta_len);
   
   PtrLen&lt;T&gt; extend_default(ulen delta_len);
   
   template &lt;class ... SS&gt;
   PtrLen&lt;T&gt; extend_fill(ulen delta_len,SS &amp;&amp; ... ss);
    
   PtrLen&lt;T&gt; extend_copy(ulen delta_len,const T src[]);
   
   template &lt;class S&gt;
   PtrLen&lt;T&gt; extend_cast(ulen delta_len,const S src[]);
   
   PtrLen&lt;T&gt; extend_swap(ulen delta_len,T objs[]);
   
   template &lt;class Creator&gt;
   PtrLen&lt;T&gt; extend(ulen delta_len,Creator creator);
   
   template &lt;class Builder&gt;
   PtrLen&lt;T&gt; extend(Builder builder);
   
</pre>   

<p>
<b>extend...()</b> is a family of methods, which extends the array with number elements. They differs in
the element construction ways. All of them, except the last, has the first argument <b>delta_len</b>, 
which is the number of new elements. The return value is the range of these new elements.
<b>extend...()</b> are transactional, i.g. if the method if failed, then the array is remaining 
in the original state, the exception is thrown.
</p>

<p>
<b>extend_raw()</b> for POD types leaves the new elements uninitialized. For other types it works
like <b>extend_default()</b>.
</p>

<p>
<b>extend_default()</b> creates the new elements using the default constructor.
</p>

<p>
<b>extend_fill()</b> creates the new elements using some constructor, the specified arguments are forwarded
to this constructor.  
</p>

<p>
<b>extend_copy()</b> creates the new elements using the copy constructor, <b>src</b> is a range of length
<b>delta_len</b>, its members are copied memberwise.
</p>

<p>
<b>extend_cast()</b> creates the new elements using the "cast" constructor, <b>src</b> is a range of length
<b>delta_len</b>, its members are casted memberwise.
</p>

<p>
<b>extend_swap()</b> creates the new elements using the "swap move" approach. I.e. the new elements are 
created using the default constructor and swapped with the members of the range <b>objs</b>.
</p>

<p>
Two final <b>extend()</b> are generic. The first of them uses the given <b>Creator</b> object to create the 
new elements, and the second uses the <b>Builder</b>. See below explanations about <b>Creator</b>s and
<b>Builder</b>s.
</p>

<pre>
   // append
   
   T * append_raw();
   
   T * append_default();
    
   template &lt;class ... SS&gt;
   T * append_fill(SS &amp;&amp; ... ss); 
   
   T * append_copy(const T &amp;src);
   
   T * append_swap(T &amp;obj);
   
   template &lt;class Creator&gt;
   T * append(Creator creator);
   
</pre>   

<p>
<b>append...()</b> is a family of methods to append one element to the array. They are similar to the
correspondent <b>extend...()</b> methods and do exactly the same with <b>delta_len</b> equals 1.   
The return value is the pointer to the created element.
</p>

<pre>
   // swap/move objects
   
   void objSwap(DynArray&lt;T,Algo&gt; &amp;obj);
   
   explicit DynArray(ToMoveCtor&lt;DynArray&lt;T,Algo&gt; &gt; obj);
    
   DynArray&lt;T,Algo&gt; * objMove(Place&lt;void&gt; place);
 };
</pre>

<p>
<b>DynArray</b> is swapable and moveable.
</p>

<h4>RefArray and AtomicRefArray</h4>

<p>
<b>RefArray</b> and <b>AtomicRefArray</b> are copyable arrays with an efficient copy constructors.
It's assumed, the type <b>T</b> is copyable.
Multiple copies of arrays may share the same state. The state has a reference counter, which is used to
end its life-time. The only difference between <b>RefArray</b> and <b>AtomicRefArray</b> is the former
uses the atomic reference counting to be viable in a multithreaded environment.
</p>

<p>
<b>RefArray</b> has a simulated value semantic. It means that you may consider the different copy of the array
as independent variables, despite they may share the state. That is because <b>RefArray</b> provides
only the constant access to the elements. So far you don't violate this constantness (using the const-cast, for example),
you may safely assume the each copy is different. To modify the array you have to call
the method <b>modify()</b>. This method "unshares" the array, if necessary, and gives the non-constant access to the
elements.
</p>

<pre>
template &lt;class T,class Algo=ArrayAlgo&lt;T&gt; &gt;
class <span class="att">RefArray</span>
 {
   ....

  public:
  
   // constructors
   
   RefArray() {}
   
   template &lt;class S&gt;
   explicit RefArray(std::initializer_list&lt;S&gt; il);
   
   explicit RefArray(ulen len); 
   
   RefArray(ulen len,ulen maxlen); 
    
   RefArray(DoReserveType,ulen maxlen); 
    
   explicit RefArray(DoRaw dotype); 
   
   template &lt;class ... SS&gt;
   explicit RefArray(DoFill dotype,SS &amp;&amp; ... ss); 
    
   RefArray(DoCopy dotype,const T src[]); 
 
   template &lt;class S&gt;
   RefArray(DoCast dotype,const S src[]); 
   
   RefArray(DoSwap dotype,T objs[]); 
   
   template &lt;class Creator&gt;
   RefArray(DoCreate dotype,Creator creator); 
    
   template &lt;class Builder&gt;
   RefArray(DoBuildType,Builder builder); 
    
   ~RefArray();
   
   // range access
   
   const T * getPtr() const;
   
   const T * getPtr_const() const;
   
   ulen getLen() const;
   
   ulen getMaxLen() const;
   
   ulen getExtraLen() const;
   
   // index access
   
   const T & operator [] (ulen index) const;
   
   const T & at(ulen index) const;
   
   // methods
   
   PtrLen&lt;T&gt; modify();
   
   void cloneTo(RefArray&lt;T,Algo&gt; &amp;ret) const;
    
   void reserve(ulen extra_len);
   
   void erase();
    
   // shrink
   
   ulen shrink(ulen delta_len);
    
   bool shrink_one();
    
   ulen shrink_all();
    
   void shrink_extra();
    
   // extend
   
   PtrLen&lt;T&gt; extend_raw(ulen delta_len);
   
   PtrLen&lt;T&gt; extend_default(ulen delta_len);
   
   template &lt;class ... SS&gt;
   PtrLen&lt;T&gt; extend_fill(ulen delta_len,SS &amp;&amp; ... ss);
    
   PtrLen&lt;T&gt; extend_copy(ulen delta_len,const T src[]);
   
   template &lt;class S&gt;
   PtrLen&lt;T&gt; extend_cast(ulen delta_len,const S src[]);
   
   PtrLen&lt;T&gt; extend_swap(ulen delta_len,T objs[]);
   
   template &lt;class Creator&gt;
   PtrLen&lt;T&gt; extend(ulen delta_len,Creator creator);
   
   template &lt;class Builder&gt;
   PtrLen&lt;T&gt; extend(Builder builder);
   
   // append
   
   T * append_raw();
    
   T * append_default();
    
   template &lt;class ... SS&gt;
   T * append_fill(SS &amp;&amp; ... ss); 
   
   T * append_copy(const T &amp;src);
   
   T * append_swap(T &amp;obj);
   
   template &lt;class Creator&gt;
   T * append(Creator creator);
   
   // swap/move objects
   
   void objSwap(RefArray&lt;T,Algo&gt; &amp;obj);
   
   explicit RefArray(ToMoveCtor&lt;RefArray&lt;T,Algo&gt; &gt; obj);
   
   RefArray&lt;T,Algo&gt; * objMove(Place&lt;void&gt; place);
 };
</pre>

<p>
The <b>RefArray</b> methods are mostly the same as <b>DynArray</b> methods. The differences are:
index and range access methods gives only the constant access, and the new class-specific method <b>modify()</b>
exists.
</p>

<h4>Collector</h4>

<p>
<b>Collector</b> is not an array! The purpose of this container is to be an efficient collector of elements.
This container stores a sequense of elements in a list of arrays. So appending and extending 
operations are the most efficient. At desired moment you can copy or move this sequence into true array.
Or you can "flat" the <b>Collector</b> itself.
</p>

<pre>
template &lt;class T,class Algo=ArrayAlgo&lt;T&gt; &gt;
class <span class="att">Collector</span> : NoCopy
 {
   ....

  public:
   
   // constructors
   
   static const ulen DefaultBlockLen = 1024 ;
   static const ulen MinBlockLen = 10 ;
   
   explicit Collector(ulen block_len=DefaultBlockLen);
   
   ~Collector();

</pre>   

<p>
The argument of the <b>Collector</b> constructor is the number of elements in the single element block.
The default value is 1024.
</p>

<pre>
   // methods
   
   ulen getLen() const; 
   
   void erase();
   
   template &lt;class Container&gt;
   void extractTo(Container &amp;ret)
    {
     Container temp(DoBuild,Extractor(this));
     
     Swap(temp,ret);
    }
   
   template &lt;class Container&gt;
   void copyTo(Container &amp;ret) const
    {
     Container temp(DoBuild,Copyrator(this));
     
     Swap(temp,ret);
    }
   
   PtrLen&lt;T&gt; flat();
   
</pre>

<p>
<b>Collector</b> does not provide a direct access to its content.
</p>

<p>
<b>getLen()</b> is the number of the collected elements.
</p>

<p>
<b>erase()</b> cleanup the container and put it into the null state.
</p>

<p>
<b>extractTo()</b> moves the content to another (array) container. The target container must have the <b>Build</b>
constructor. <b>Collector</b> becomes empty after this operation.
</p>

<p>
<b>copyTo()</b> copys the content to another (array) container. The target container must have the <b>Build</b>
constructor.
</p>

<p>
<b>flat()</b> rebuilds the internal data storage, making it continuous. It returns the range of elements.
This range remains valid after extend or append operations (but may become invalid after any other
modifying operation).
</p>

<pre>
   // shrink 
   
   ulen shrink(ulen delta_len);
    
   bool shrink_one();
    
   ulen shrink_all();
    
   // extend
   
   PtrLen&lt;T&gt; extend_raw(ulen delta_len);
   
   PtrLen&lt;T&gt; extend_default(ulen delta_len);
   
   template &lt;class ... SS&gt;
   PtrLen&lt;T&gt; extend_fill(ulen delta_len,SS &amp;&amp; ... ss);
    
   PtrLen&lt;T&gt; extend_copy(ulen delta_len,const T src[]);
   
   template &lt;class S&gt;
   PtrLen&lt;T&gt; extend_cast(ulen delta_len,const S src[]);
   
   PtrLen&lt;T&gt; extend_swap(ulen delta_len,T objs[]);
   
   template &lt;class Creator&gt;
   PtrLen&lt;T&gt; extend(ulen delta_len,Creator creator);
   
   template &lt;class Builder&gt;
   PtrLen&lt;T&gt; extend(Builder builder);
   
   // append
   
   T * append_raw();
   
   T * append_default();
    
   template &lt;class ... SS&gt;
   T * append_fill(SS &amp;&amp; ... ss); 
   
   T * append_copy(const T &amp;src);
   
   T * append_swap(T &amp;obj);
   
   template &lt;class Creator&gt;
   T * append(Creator creator);

</pre>   

<p>
<b>shrink...()</b>, <b>extend...()</b> and <b>append...()</b> methods are the same as for <b>DynArray</b>.
</p>

<pre>
   // swap/move object
   
   void objSwap(Collector&lt;T,Algo&gt; &amp;obj);
   
   explicit Collector(ToMoveCtor&lt;Collector&lt;T,Algo&gt; &gt; obj);
    
   Collector&lt;T,Algo&gt; * objMove(Place&lt;void&gt; place);
 };
</pre>

<p>
<b>Collector</b> is swapable and movable.
</p>

<h3>Array algorithms</h3>

<p>
<b>CCore</b> <b>Array</b> implementation is based on the <b>Array Algorithm Package</b>s.
The default package is the <b>ArrayAlgo</b>.
</p>

<pre>

template &lt;class T,class Flags=NoThrowFlags&lt;T&gt; &gt; struct ArrayAlgo;

</pre>

<p>
The exact implementation depends on the kind of <b>T</b>.
</p>

<p>
If the type <b>T</b> defines an inner type <b>ArrayAlgoType</b>, then this type will be used
as the package.
</p>

<p>
Otherwise there are two variants: one for the POD types, another for the other (class) types.
</p>

<h4>ArrayAlgo_class</h4>

<p>
<b>ArrayAlgo_class</b> is the generic (class) variant.
</p>

<pre>
template &lt;class T,class Flags&gt;
struct ArrayAlgo_class
 {
  //
  //  assume ~T() , Move(T *,Place&lt;void&gt;) , Swap(T &amp;,T &amp;) no-throw
  //
 
  //
  //  Create...() : clean on throw
  //
  
  enum PropFlagType
   {
    Default_no_throw = Flags::Default_no_throw,
    Copy_no_throw = Flags::Copy_no_throw,
    
    MoveTo_exist = true
   };
 
  static PtrLen&lt;T&gt; Create_raw(Place&lt;void&gt; place,ulen len);
  
  static PtrLen&lt;T&gt; Create_default(Place&lt;void&gt; place,ulen len);
   
  template &lt;class ... SS&gt;
  static PtrLen&lt;T&gt; Create_fill(Place&lt;void&gt; place,ulen len,SS &amp;&amp; ... ss);
  
  static PtrLen&lt;T&gt; Create_copy(Place&lt;void&gt; place,ulen len,const T src[]);
  
  template &lt;class S&gt;
  static PtrLen&lt;T&gt; Create_cast(Place&lt;void&gt; place,ulen len,const S src[]);
  
  static PtrLen&lt;T&gt; Create_swap(Place&lt;void&gt; place,ulen len,T objs[]);
   
  //
  //  Single
  // 
  
  static T * Create_swap(Place&lt;void&gt; place,T &amp;obj) noexcept(EnableNoExcept);
   
  //
  //  ProvideLen() : double extension
  // 
  
  static ulen ProvideLen(ulen len,ulen maxlen,ulen extra_len);
   
  // 
  //  MoveTo() : no-throw
  //

  static PtrLen&lt;T&gt; MoveTo(T *ptr,ulen len,Place&lt;void&gt; place) noexcept(EnableNoExcept);

  //
  // 
  //

  template &lt;class Creator&gt;
  static PtrLen&lt;T&gt; Create(Place&lt;void&gt; place,ulen len,Creator creator);
  
  //
  //  single Destroy() : no-throw
  // 
  
  static void Destroy(T *ptr) noexcept(EnableNoExcept);
  
  // 
  //  Destroy() : no-throw
  //
  
  static void Destroy(T *ptr,ulen len) noexcept(EnableNoExcept);
 };
</pre>

<h4>ArrayAlgo_pod</h4>

<p>
<b>ArrayAlgo_pod</b> is the POD variant.
</p>

<pre>
</pre>

</body>

</html>

