<!--
/* page_APRTest.html */
//----------------------------------------------------------------------------------------
//
//  Project: CCore 1.08
//
//  License: Boost Software License - Version 1.0 - August 17th, 2003 
//
//            see http://www.boost.org/LICENSE_1_0.txt or the local copy
//
//  Copyright (c) 2014 Sergey Strukov. All rights reserved.
//
//----------------------------------------------------------------------------------------
-->

<!DOCTYPE html>
<html>

<head>

 <title>CCore -> APRTest</title>

 <link href="CCore.css" rel="stylesheet" type="text/css">

</head>

<body>

<h2>APRTest</h2>

<p class="Files">Files <b>CCore/inc/math/APRTest.h</b> <b>CCore/src/math/APRTest.cpp</b></p>

<p>
<b>APRTest</b> is a primality test (stands for Adelman-Pomerance-Rumely). 
It can determine for the given Integer is it prime or not. 
The all related software entities are enclosed in the namespace <b>APRTest</b>.
</p>

<pre>

namespace APRTest {

/* enum TestResult */

enum <span class="Att">TestResult</span>
 {
  IsPrime = 0,
  
  NoPrime,
  HasDivisor,
  HardCase,
  TooLarge
 };

const char * GetTextDesc(TestResult res);

....

template &lt;class Integer&gt;
class <span class="Att">TestEngine</span> : NoCopy
 {
  public:

   TestEngine()
   
   ~TestEngine() {}
   
   template &lt;class Report&gt;
   TestResult operator () (Integer N,Report &report) const;
 };

} // namespace APRTest

</pre>

<p>
To run the test you need a <b>TestEngine</b> object. The template parameter is an <a href="page_Integer.html">Integer</a> class.
This test can work with numbers below the cap equals <b>23443376766399015365370094014394044591022942877740133
9531905315226385879149594583663988919650332600595200884837591299917987079434841807932707365345822805139711009
4758345585309832973789983795850774473546833351202515196582495343983029018958774636288347077987727058525824502
7248014151549412058989423421123615687052297471776447851217026334921294092499020627182545933934679225763954455
7278966806568490654218019232364207776803001408703788591463083448356792852975601177124756827636111351138800139
3484403543076071666731682242042101932602436714526377645190012794671047277351572336293756142780995748899251824
6107838771311726985720414263932870520424340454793737983323520768198897056509822102755788426876904915875455885
9646640446861411241617794489384285048373774732477456156090373771180710513353194468667023586369662285645762015
8525443179536580748507307152398175860469295141350553588551487227997364542498126759812417046521705659662042123
0689914375294656355123266523300469063571738978971258879678847168416519494825019447667108736352236292460528034
4584808426462776461486553498751672651048735025223797785660067952446270665261377787844134075732390500690020179
2679157603016127377518393864831126561602715213141126058233848792488795326134373148850736324312919886997218561
4566009603479109634455992139666601766043654450399694577896052051888073932043997306437670601959738752480561143
2050771814223829726429023213337912340580460354380741424755549264802253245352841717268600146619850089549120758
1780032375011816107621606610250675027386707007781142168530846576081212867139662696695047672572359662200294496
4573672094740483267405423849061004318678239699030541058123140966728010722658659745107230286811969277892072040
3481886302070655779146178297533320554790910730326106451845257463507561272899421287549624400560723516533571191
4621609165286318453807291146422169704392586520387701891425544357472300429578010581103545069432635783020195734
9944479360350486458460580640215470462880417740684142948484334489570630940249785222564343666957116106823555429
3464199193396919617491789783935442503388374670609662331164193236937025615869841579305773891499364844497557924
5608653237989267513937095546850031712547589411981327192126225542098643729904385752270582230039152113451626086
1112229668835120905248115729261261736226883766430044275044174340814527730479437844669366015440938731750165423
7034229164329991564186121601002665397164207819724465172173241965716661395738850214541005300716662080283654703
4262579320675600648865858127949014420092818949480659599144465790803006089118291434926172431743125050286078479
9046163961947905818150287118990151388987901338641914242193735473811672373491427528497702326938376478320741181
75088107303607024215622196062450785284458052516</b>.
This number has <b>9021</b> bit length. So numbers with <b>9020</b> bit length or less can be tested.
</p>

<p>
To test the given Integer use the <b>operator ()</b>. The first argument is the number to be tested.
The second is the reference to a report object. There is a default silent <b>Report</b> class:
</p>

<pre>

class <span class="Att">NoReport</span>
 {
  public:
   
   NoReport() {}
  
   template &lt;class Integer&gt;
   void start(Integer N) { Used(N); }
   
   void sanity(const char *msg) { Used(msg); }
   
   void isSmallPrime() {}
   
   void testP(unsigned prime_p) { Used(prime_p); }
   
   void testQ(QType prime_q) { Used(prime_q); }
   
   template &lt;class Integer&gt;
   void cappa(PtrLen&lt;const Integer&gt; cappa,Integer Nminus1) { Used(cappa); Used(Nminus1); }
   
   template &lt;class Integer&gt;
   void cappa2(Integer cappa,Integer Nminus1) { Used(cappa); Used(Nminus1); }
   
   void startProbe() {}
   
   template &lt;class Integer&gt;
   void probe(Integer cnt) { Used(cnt); }
   
   template &lt;class Integer&gt;
   void div(Integer D) { Used(D); }
   
   void hard() {}
   
   void isPrime() {}
   
   void noPrime() {}
 };

</pre>

<p>
Any report class must have the same interface.
</p>

<p>
A test result is returned as the value of the enumeration <b>TestResult</b>.
</p>

<p>
<b>IsPrime</b> equals 0 means the number is prime.
</p>

<p>
<b>NoPrime</b> means the number is no prime.
</p>

<p>
<b>HasDivisor</b> means the number is no prime and some divisor can be presented.
</p>

<p>
<b>HardCase</b> means the test was unable to determine the primality of the given number. This is
a very rare case.
</p>

<p>
<b>TooLarge</b> means the number is above the test cap.
</p>

<p>
Report methods are called to indicate some stages of the test.
</p>

<p>
<b>start()</b> is called at the start of the test. The argument is the number to be tested.
</p>

<p>
<b>sanity()</b> is called if some sanity checks are failed. The argument is the text description of the situation.
</p>

<p>
<b>isSmallPrime()</b> is called if the number been tested is a small prime.
</p>

<p>
<b>testP()</b> is called at the beginning of a series of subtests. The argument is a small prime number <b>p</b>.
</p>

<p>
<b>testQ()</b> is called at the beginning of a subtest. The argument is a small prime number <b>q</b>. 
The couple <b>(p,q)</b> is the subtest index.
</p>

<p>
<b>startProbe()</b> is called at the beginning of the searching divisors.
</p>

<p>
<b>probe()</b> is called during the searching divisors. The argument is the remaining possible divisor count.
</p>

<p>
<b>div()</b> is called if some divisor has been found. The argument is that divisor. 
</p>

<p>
<b>hard()</b> is called if it is the hard case.
</p>

<p>
<b>isPrime()</b> is called if the number been tested is prime.
</p>

<p>
<b>noPrime()</b> is called if the number been tested is not prime.
</p>

</body>

</html>

