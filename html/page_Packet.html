<!--
/* page_Packet.html */
//----------------------------------------------------------------------------------------
//
//  Project: CCore 1.02
//
//  License: Boost Software License - Version 1.0 - August 17th, 2003 
//
//            see http://www.boost.org/LICENSE_1_0.txt or the local copy
//
//  Copyright (c) 2012 Sergey Strukov. All rights reserved.
//
//----------------------------------------------------------------------------------------
-->

<!DOCTYPE html>
<html>

<head>

 <title>CCore -> Packet</title>

 <link href="CCore.css" rel="stylesheet" type="text/css">

</head>

<body>

<h2>Packet</h2>

<p class="Files">Files <b>CCore/inc/Packet.h</b> <b>CCore/src/Packet.cpp</b></p>
 
<p>
Packets is an infra-structure for efficient flexible parallel mass request processing.
In this infra-structure processing nodes, also called devices, are exchanging packets. Packet is
a task request. It contains a small stack for request parameters and return value and typically has an
attached data buffer to transfer a bulk of data. Packet might be cancelled by the originator.
Each packet device has a packet entry gate, through which packets are coming for processing.
During processing packet can be stored, transferred to another packet device or completed.
Eventually packet must be completed and during completion returned to the packet pool, from which
it was borrowed. Packet cancellation is a mean, the packet originator can use to ask a current
packet device to cancel a packet processing. It is assumed, that packet should be quickly disengaged from the 
processing and completed.
</p>

<p>
<span class="alert">Packet functions, complete or cancel, must be called in a lock-free context</span>.
</p>

<p>
The number of software entities are required to deal with packets.
</p>

<h4>Types, constants and functions</h4>

<pre>

typedef SecTimer::ValueType <span class="att">TimeStamp</span>;

typedef Function&lt;void (PacketHeader *)&gt; <span class="att">PacketFunction</span>;

</pre>

<p>
<b>TimeStamp</b> is a type of time-stamp value.
</p>

<p>
<b>PacketFunction</b> is a packet function type.
</p>

<pre>

const ulen <span class="att">MaxPacketExtLen</span> = Align(256) ;

const ulen <span class="att">MaxPacketCompleteFunctions</span> = 8 ;

const ulen <span class="att">DefaultPacketMaxDataLen</span> = 1600 ;

enum <span class="att">PacketCancelState</span>
 {
  Packet_NoCancelFunction,
  Packet_HasCancelFunction,
  Packet_Cancelled
 };
 
enum <span class="att">LenStatus</span>
 {
  Len_ok,
  Len_too_short,
  Len_too_long
 };

</pre>    

<p>
<b>MaxPacketExtLen</b> is a space for the packet extension stack.
</p>

<p>
<b>MaxPacketCompleteFunctions</b> is a packet complete function stack depth.
</p>

<p>
<b>DefaultPacketMaxDataLen</b> is a default packet data buffer length.
</p>

<p>
<b>PacketCancelState</b> is a packet cancel state constants.
</p>

<p>
<b>LenStatus</b> is a length status.
</p>

<pre>

void GuardLenSubTooShort(const char *name,ulen len,ulen delta);

inline ulen LenSub(const char *name,ulen len,ulen delta) // always > 0 
 {
  if( len<=delta ) GuardLenSubTooShort(name,len,delta);
  
  return len-delta;
 }

inline PacketHeader * GetPacketHeader(PacketHeader *packet) { return packet; }
 
template &lt;class POD,class ... TT&gt;
PacketHeader * GetPacketHeader(Packet&lt;POD,TT...&gt; packet) { return packet.getPtr(); }
 
template &lt;class POD,class T&gt;
void DropPacketExt(PacketHeader *packet_)
 {
  Packet&lt;POD,T&gt; packet=packet_;
  
  packet.popExt().complete();
 }

</pre>

<p>
<b>LenSub()</b> performs the length subtraction. It is expected, the result is positive.
Otherwise, an exception is thrown. <b>GuardLenSubTooShort()</b> throw an exception. <b>name</b> 
is a function name in the exception message.
</p>

<p>
<b>GetPacketHeader()</b> casts a "packet" to the pointer to the <b>PacketHeader</b>.
</p>

<p>
<b>DropPacketExt()</b> is a simple packet completion function. Use it when you need only
to pop some packet extension.
</p>

<h4>PacketBuf</h4>

<p>
<b>PacketBuf</b> is used to handle a packet data buffer. This class keeps a pointer to the data buffer
alone with its length and the data length, stored in the buffer. From the <b>PacketBuf</b>
perspective data is a raw data, i.g. a sequence of bytes.
</p>

<pre>
class <span class="att">PacketBuf</span> : NoCopy
 {
   void *data;
   ulen max_data_len;
   ulen data_len;

   ....
   
  public:
   
   // constructors
  
   PacketBuf();
   
   explicit PacketBuf(ulen max_data_len);
   
   ~PacketBuf();
   
   // methods
   
   bool provide(ulen max_data_len);
   
   void detach();
   
   void moveTo(PacketBuf &pbuf);
   
   // data methods
   
   bool noSpace() const { return !max_data_len; }
   
   ulen getMaxRawLen() const { return max_data_len; }
   
   ulen getRawLen() const { return data_len; }
   
   void setRawLen(ulen data_len_) { guardLen(data_len_); data_len=data_len_; }
   
   Place&lt;void&gt; getRaw() { return PlaceAt(data); }
 };
</pre>

<p>
Default constructor creates an empty data buffer.
</p>

<p>
Another constructor creates a data buffer with the given capacity. The <b>data_len</b> is zero.
Exception is thrown in case of error.
</p>

<p>
Destructor releases the buffer.
</p>

<p>
<b>provide()</b> ensures the data buffer has the given capacity. It also clears <b>data_len</b>.
If the buffer of a greater capacity was already allocated, the extra memory is returned to the heap.
The return value is true, if the operation is successful.
</p>

<p>
<b>detach()</b> releases the buffer. The object becomes empty.
</p>

<p>
<b>moveTo()</b> moves the buffer to another <b>PacketBuf</b> object. The original object becomes empty.
The previous destination buffer is released. If the source and the destination are the same, the operation
does nothing.
</p>

<p>
<b>noSpace()</b> is true, if the buffer is empty.
</p>

<p>
<b>getMaxRawLen()</b> returns the buffer capacity in bytes.
</p>

<p>
<b>getRawLen()</b> returns the actual data length in the buffer.
</p>

<p>
<b>setRawLen()</b> sets the actual data length, the value must not exceed the buffer capacity,
otherwise an exception is thrown.
</p>

<p>
<b>getRaw()</b> returns the "place" of the beginning of the data buffer. You may
use this value to put data to the buffer.
</p>

<h4>PacketHeader</h4>

<p>
Packet itself consists of the packet header, which is an object of the class <b>PacketHeader</b>
and the packet extension behind the header. All of this is placed in a memory block of
some predefined length. Packet extension is organized as a stack of any type objects.
<b>PacketHeader</b> contains another stack of completion functions.
</p>

<pre>
class <span class="att">PacketHeader</span> : NoCopy
 {
   PacketBuf pbuf;
   
   TimeStamp time_stamp;
   
   Atomic cancel_state; // PacketCancelState
   PacketFunction cancel_function;
   void *cancel_arg;
  
   PacketFunction stack[MaxPacketCompleteFunctions];
   ulen stack_len;
   
   ulen ext_len;
  
   DLink&lt;PacketHeader&gt; link;
   bool in_list;
  
  public:
   
   // constructors
   
   static constexpr ulen AllocLen() { return Delta()+MaxPacketExtLen; }
  
   explicit PacketHeader(PacketFunction complete_function) noexcept(EnableNoExcept);
   
   void recycle(PacketFunction complete_function);
   
   ~PacketHeader() {}
   
</pre>

<p>
<b>PacketHeader</b> has a number of inner data fields. It also has an extension.
</p>

<p>
Normally you don't need the <b>PacketHeader</b> constructor, because you get a ready-to-use
packet from a packet pool. This constructor creates a clean packet with the given completion function.
</p>

<p>
The destructor is not trivial: it calls a destructor of the inner <b>PacketBuf</b>.
And again, you don't use it directly, because once you finished with a packet, you call its complete
method and packet returns to the packet pool, where it was originaly taken.
</p>

<p>
<b>recycle()</b> is used to prepare the packet for reuse. The packet must have empty extension,
complete stack and no cancel function.
</p>

<p>
<b>AllocLen()</b> is a packet memory block length.
</p>

<pre>

   // complete
   
   void pushCompleteFunction(PacketFunction complete_function); 
   
   PacketFunction popCompleteFunction(); 
  
   void complete() { popCompleteFunction()(this); }
   
</pre>

<p>
Packet has the inner complete function stack. Onec the packet processing is finished, the method 
<b>complete()</b> must be called to complete the packet. A packet originator assignes a complete function,
when preparing packet for processing. When packet is taken from a packet pool, it has the one complete
function, which returns the packet to the pool.
</p>

<p>
<b>pushCompleteFunction()</b> pushs a packet function to the complete function stack.
</p>

<p>
<b>popCompleteFunction()</b> pops a packet function from the complete function stack.
</p>

<p>
<b>complete()</b> pops a packet function from the complete function stack and applies it to the packet.
</p>

<p>
In case of stack overflow or underflow the <b>Abort()</b> is called.
</p>

<pre>

   // cancel
   
   PacketCancelState setCancelFunction(PacketFunction cancel_function,void *cancel_arg=0);
   
   PacketCancelState clearCancelFunction();
   
   PacketCancelState getCancelFunction(PacketFunction &amp;ret);
   
   void * getCancelArg() const { return cancel_arg; }

</pre>

<p>
Packet has a cancel state. The state has one of three values: <b>Packet_NoCancelFunction</b>, 
<b>Packet_HasCancelFunction</b>, <b>Packet_Cancelled</b>.
</p>

<p>
<b>setCancelFunction()</b> assigns a cancel function with optionally argument. The packet
must not have a cancel function assigned. If the packet is already cancelled, the function does nothing,
otherwise it assigns a cancel function and changes the packet state to the <b>Packet_HasCancelFunction</b>.
The previous state is returned.
</p>

<p>
<b>clearCancelFunction()</b> clears a cancel function. The packet must be in 
<b>Packet_HasCancelFunction</b> or <b>Packet_Cancelled</b> state.
If the packet is already cancelled, the function does nothing, otherwise it clears
a cancel function and changes the packet state to the <b>Packet_NoCancelFunction</b>.
The previous state is returned.
</p>

<p>
These two functions are called by packet processors. Once packet is received for processing,
a packet processor may assign a cancel function to it, if the packet processing is not
immediate. Before packet is disengaged, a cancel function must be cleared. To learn how
to properly use this feature, see <a href="page_CancelPacketList.html"><b>CancelPacketList</b></a>
implementation.
</p>

<p>
<b>getCancelFunction()</b> cancels a packet. The state is change to <b>Packet_Cancelled</b>.
The previous state is returned and a cancel function is returned if has been set.
This function is called by the packet orignator to cancel the packet processing.
If the packet has an assigned cancel function, then it must be called to request the packet
processing cancellation. The cancel function, if exists, completes the packet.
</p>

<p>
<b>getCancelArg()</b> returns a cancel argument.
</p>

<pre>
   
   // stamp
  
   TimeStamp getStamp() const { return time_stamp; }
  
   bool isOld(TimeStamp now,TimeStamp how_old) const { return now-time_stamp>how_old; }
  
   void stamp() { time_stamp=SecTimer::Get(); }
   
</pre>

<p>
<b>PacketHeader</b> has the inner time-stamp field. The second timer is used for the time-stamping.
</p>

<p>
<b>getStamp()</b> return the packet time-stamp.
</p>

<p>
<b>isOld()</b> is used to check if the packet is old enough. The first argument is the current time
and the second is a desired time.
</p>

<p>
<b>stamp()</b> sets the current time as a time-stamp.
</p>

<pre>

   // ext
   
   template &lt;class T,class ... SS&gt;
   T * pushExt(SS &amp;&amp; ... ss);
   
   template &lt;class T&gt;
   T * getExt();
    
   template &lt;class T,class ... TT&gt;  // T, T1, T2, ... , Ttop
   T * getDeepExt();
    
   template &lt;class T&gt;
   void popExt();
    
</pre>

<p>
The next set of methods are to "extend" the packet.
</p>

<p>
<b>pushExt()</b> pushs the object of the type <b>T</b> to the extension stack. The object
is constructed using the given set of arguments. Pointer to the constructed object is returned.
If there is no enough room for the object the <b>Abort()</b> is called.
</p>

<p>
<b>getExt()</b> returns a pointer to the top of the extension stack. You must known exactly, the
object exists and has the given type.
</p>

<p>
<b>getDeepExt()</b> is used, if you have to look deeper into the extension stack. If the stack
contains a sequence of objects of types <b>T, T1, ... Ttop</b>, you may use this methods
to get a pointer to the deep object of the type <b>T</b>.
</p>

<p>
<b>popExt()</b> pops and destroys the top object from the extension stack. You must known exactly, the
object exists and has the given type.
</p>

<pre>

   // data attach/detach 
   
   bool provide(ulen max_data_len=DefaultPacketMaxDataLen);
   
   void detach();
   
   void attach(PacketBuf &amp;pbuf);
   
   void detach(PacketBuf &amp;pbuf);
   
   void detach(PacketHeader *dst);

</pre>

<p>
<b>PacketHeader</b> has the inner <b>PacketBuf</b> field and a set of methods
to manipulate with it. This buffer can be used to store a bulk of data with a packet.
</p>

<p>
These methods are direct calls of the correspondent <b>PacketBuf</b> methods.
Last three methods use the <b>moveTo()</b> <b>PacketBuf</b> method to move the data buffer.
The only difference they are not allowed if the packet belongs to a packet list.
In this case <b>Abort()</b> is called. The last method moves the packet buffer to another packet.
This packet also must not belong to a packet list.
</p>

<pre>
   
   // raw data
   
   bool noSpace() const { return pbuf.noSpace(); }
    
   ulen getMaxRawLen() const { return pbuf.getMaxRawLen(); }
   
   ulen getRawLen() const { return pbuf.getRawLen(); }
   
   void setRawLen(ulen data_len) { pbuf.setRawLen(data_len); }
   
   Place&lt;void&gt; getRaw() { return pbuf.getRaw(); }
 };
</pre>

<p>
Raw data methods are direct calls of the correspondent <b>PacketBuf</b> methods.
</p>

<h4>PacketList</h4>

<p>
<b>PacketHeader</b> contains a list link and can be inserted into a <b>PacketList</b>.
It is not possible to have a <b>PacketHeader</b> in two lists. If a packet belongs to a list,
it cannot be completed also.
</p>

<pre>
class <span class="att">PacketList</span> : NoCopy
 {
   ....

  public:
   
   // constructors
  
   PacketList();
  
   ~PacketList();
   
   ulen getCount() const { return count; }
   
   ulen getTotalLen() const { return total_len; }
   
   // put
   
   void put(PacketHeader *packet);
   
   void put_first(PacketHeader *packet);
   
   template &lt;class P&gt;
   void put(P packet) { put(GetPacketHeader(packet)); }
  
   template &lt;class P&gt;
   void put_first(P packet) { put_first(GetPacketHeader(packet)); }
   
   // get
   
   PacketHeader * get();
   
   PacketHeader * get_last();
   
   // del
   
   void del(PacketHeader *packet);
    
   template &lt;class P&gt;
   void del(P packet) { del(GetPacketHeader(packet)); }
   
   // methods
   
   void complete();
  
   void moveOld(TimeStamp how_old,PacketList &amp;dest);
   
   // swap/move object
   
   void objSwap(PacketList &amp;obj);
   
   explicit PacketList(ToMoveCtor&lt;PacketList&gt; obj);
   
   PacketList * objMove(Place&lt;void&gt; place);
 };
</pre>

<p>
<b>PacketList</b> must be empty before destructor is called, otherwise the <b>Abort()</b> is called.
</p>

<p>
<b>getCount()</b> is the number of packets in the list.
</p>

<p>
<b>getTotalLen()</b> is the total buffer space of packets in the list.
</p>

<p>
<b>put()</b> puts the packet into the list. Packet must not be in a list, otherwise 
the <b>Abort()</b> is called.
</p>

<p>
<b>put_first()</b> puts the packet into the list as the first element. Packet must not be in a list, 
otherwise the <b>Abort()</b> is called.
</p>

<p>
<b>get()</b> gets the first packet from the list. If the list is empty, null pointer is returned.
</p>

<p>
<b>get_last()</b> gets the last packet from the list. If the list is empty, null pointer is returned.
</p>

<p>
<b>del()</b> deletes the packet form the list. Packet must belong to this list.
</p>

<p>
<b>complete()</b> completes all packets from the list. List becomes empty.
</p>

<p>
<b>moveOld()</b> moves all packets, older than <b>how_old</b> to the destination list.
</p>

<p>
<b>PacketList</b> is swapable and moveable.
</p>

<h4>Packet</h4>

<p>
<b>Packet</b> is a <b>PacketHeader</b> pointer wrapper. It behaves like a raw pointer, so use it 
with caution.
</p>

<pre>
template &lt;class POD,class ... TT&gt; // T1, T2, ... , Ttop
class Packet
 {
   PacketHeader *packet;
   
  public:
   
   // constructors
  
   Packet() : packet(0) {}
   
   Packet(NothingType) : packet(0) {}
   
   Packet(PacketHeader *packet_) : packet(packet_) {}

</pre>
<pre>
   
   // props
   
   PacketHeader * operator + () const { return packet; }
   
   bool operator ! () const { return packet==0; }
   
   PacketHeader * getPtr() const { return packet; }

</pre>
<pre>
   
   // complete
   
   void pushCompleteFunction(PacketFunction complete_function) { packet-&gt;pushCompleteFunction(complete_function); }
   
   PacketFunction popCompleteFunction() { return packet-&gt;popCompleteFunction(); }
  
   void complete() { Replace_null(packet)-&gt;complete(); }

</pre>
<pre>
   
   // cancel
   
   PacketCancelState setCancelFunction(PacketFunction cancel_function,void *cancel_arg=0) { return packet-&gt;setCancelFunction(cancel_function,cancel_arg); }
   
   PacketCancelState clearCancelFunction() { return packet-&gt;clearCancelFunction(); }
   
   void * getCancelArg() { return packet-&gt;getCancelArg(); }
   
</pre>
<pre>

   // stamp
  
   TimeStamp getStamp() { return packet-&gt;getStamp(); }
  
   bool isOld(TimeStamp now,TimeStamp how_old) { return packet-&gt;isOld(now,how_old); }
  
   void stamp() { packet-&gt;stamp(); }
   
</pre>
<pre>

   // ext
   
   template &lt;class T,class ... SS&gt;
   Packet&lt;POD,TT...,T&gt; pushExt(SS &amp;&amp; ... ss) 
    { 
     PacketHeader *ret=Replace_null(packet);
     
     ret-&gt;pushExt&lt;T&gt;( std::forward&lt;SS&gt;(ss)... );
     
     return ret; 
    }
    
   typename PacketExtType&lt;POD,TT...&gt;::TopType * getExt()
    {
     return packet-&gt;getExt&lt;typename PacketExtType&lt;POD,TT...&gt;::TopType&gt;();
    }
    
   typename PacketExtType&lt;POD,TT...&gt;::PopType popExt() 
    {
     PacketHeader *ret=Replace_null(packet);
     
     ret-&gt;popExt&lt;typename PacketExtType&lt;POD,TT...&gt;::TopType&gt;();
     
     return ret; 
    }
 
   template&lt;ulen Index&gt;
   typename PacketDeepExt&lt;Index,TT...&gt;::GetType * getDeepExt()
    {
     return PacketDeepExt&lt;Index,TT...&gt;::Get(packet);
    }
    
   template&lt;ulen Index&gt;
   typename PacketForgetExt&lt;Index,POD,TT...&gt;::RetType forgetExt()
    {
     return Replace_null(packet);
    }
 
</pre>
<pre>

   // data attach/detach 
   
   bool provide(ulen max_data_len) { return packet-&gt;provide(max_data_len*sizeof (POD)); }
   
   bool provide() { return packet-&gt;provide(); }
 
   void detach() { packet-&gt;detach(); }
   
   void attach(PacketBuf &pbuf) { packet-&gt;attach(pbuf); }
   
   void detach(PacketBuf &pbuf) { packet-&gt;detach(pbuf); }
   
   void detach(PacketHeader *dst) { packet-&gt;detach(dst); }
   
   template &lt;class ... SS&gt;
   void detach(Packet&lt;POD,SS...&gt; dst) { packet-&gt;detach(dst.getPtr()); }
   
</pre>
<pre>

   // data 
   
   bool noSpace() { return packet-&gt;noSpace(); }
    
   ulen getMaxDataLen() { return packet-&gt;getMaxRawLen()/sizeof (POD); }
   
   ulen getDataLen() { return packet-&gt;getRawLen()/sizeof (POD); }
   
   POD * getData() { return packet-&gt;getRaw(); }
    
   PtrLen&lt;POD&gt; getMaxRange() { return Range(getData(),getMaxDataLen()); }
   
   PtrLen&lt;POD&gt; getRange() { return Range(getData(),getDataLen()); }
  
   bool checkDataLen(ULenSat data_len)
    {
     return data_len&lt;=getMaxDataLen();
    }
   
   PtrLen&lt;POD&gt; setDataLen(ULenSat data_len) // assume checkDataLen(data_len)
    { 
     ulen raw_len=data_len.value*sizeof (POD); 
     
     packet-&gt;setRawLen(raw_len);
     
     return Range(getData(),data_len.value);
    }
    
</pre>
<pre>

   // format
   
   PacketFormat::SubResult getMaxDataLen(PacketFormat format) 
    { 
     return format.sub(getMaxDataLen()); 
    }
   
   PacketFormat::SubResult getDataLen(PacketFormat format) 
    { 
     return format.sub(getDataLen()); 
    }
   
   PacketFormat::CutResult&lt;POD&gt; getMaxRange(PacketFormat format) 
    { 
     return format.cutMax(getMaxRange()); 
    }
   
   bool checkRange(PacketFormat format) 
    { 
     return format.check(getDataLen()); 
    }
   
   PtrLen&lt;POD&gt; getRange(PacketFormat format) // assume checkRange(format)
    { 
     return format.cut(getRange()); 
    }
   
   PtrLen&lt;POD&gt; getPrefix(PacketFormat format) // assume checkRange(format)
    { 
     return format.cutPrefix(getRange()); 
    }
   
   PtrLen&lt;POD&gt; getSuffix(PacketFormat format) // assume checkRange(format)
    { 
     return format.cutSuffix(getRange()); 
    }
   
   bool checkDataLen(PacketFormat format,ULenSat data_len)
    {
     return format.checkLen(data_len,getMaxDataLen());
    }
   
   PtrLen&lt;POD&gt; setDataLen(PacketFormat format,ULenSat data_len) // assume checkDataLen(format,data_len)
    { 
     setDataLen(format.add(data_len.value)); 
     
     return Range(getData()+format.prefix,data_len.value);
    }
 };
</pre>

<h4>PacketCanceller</h4>

<p>
<b>PacketCanceller</b> is a helper class. It simplifies the process of packet cancellation. 
</p>

<pre>
class <span class="att">PacketCanceller</span> : NoCopy
 {
   PacketHeader *packet;
   PacketFunction cancel_function;
   
  public: 
   
   template &lt;class P&gt;
   explicit PacketCanceller(P packet_) : packet(GetPacketHeader(packet_)) {}
   
   bool getCancelFunction() { return packet->getCancelFunction(cancel_function)==Packet_HasCancelFunction; }
   
   void cancel() { cancel_function(packet); }
 };
</pre>

<p>
Constructor records a packet pointer. 
</p>

<p>
<b>getCancelFunction()</b> cancels the recorded packet. The method returns true, if a cancel function
has been retrieved.
</p>

<p>
<b>cancel()</b> calls the cancel function. Use must call it, if the <b>getCancelFunction()</b> returned true.
</p>

<p>
The process has two phases, because the first call can be done in any context, but a cancel function
must be called in a lock-free context.
</p>

<h4>PacketFormat</h4>

<pre>
struct <span class="att">PacketFormat</span>
 {
  ulen prefix;
  ulen max_data;
  ulen suffix;
  
   // prefix + suffix + max_data &lt;= MaxULen
  
  PacketFormat()
   {
    prefix=0;
    max_data=0;
    suffix=0;
   }
  
  PacketFormat(NothingType)
   {
    prefix=0;
    max_data=0;
    suffix=0;
   }
  
  ulen getMaxTotalLen() const { return prefix+max_data+suffix; }
   
  PacketFormat addPrefix(ulen prefix_len) const; 
  
  PacketFormat addSuffix(ulen suffix_len) const;
  
  PacketFormat addPrefixSuffix(ulen prefix_len,ulen suffix_len) const; 
  
  ulen add(ulen len) const // return total_len; 
   { 
    ulen delta=prefix+suffix;
    
    return len+delta; 
   }
   
  struct SubResult
   {
    ulen len;
    LenStatus status;
    
    SubResult(ulen len_,LenStatus status_) : len(len_),status(status_) {}
     
    bool isTooShort() const { return status==Len_too_short; }
    
    bool notFitFormat() const { return status!=Len_ok; }
   };
  
  SubResult sub(ulen total_len) const // return len;
   {
    ulen delta=prefix+suffix;
    
    if( total_len&gt;=delta ) 
      {
       ulen len=total_len-delta;
       
       if( len&lt;=max_data ) return SubResult(len,Len_ok);
       
       return SubResult(max_data,Len_too_long);
      }
    
    return SubResult(0,Len_too_short);
   }
   
  bool checkLen(ULenSat len,ulen max_total_len) const
   {
    ulen delta=prefix+suffix;
    
    return len&lt;=max_data && len.value+delta&lt;=max_total_len ;
   }
  
  bool check(ulen total_len) const
   {
    ulen delta=prefix+suffix;
    
    return total_len&gt;=delta && total_len&lt;=delta+max_data ;
   }
   
  template &lt;class T&gt;
  PtrLen&lt;T&gt; cut(PtrLen&lt;T&gt; range) const // assume check(range.len)
   {
    return range.inner(prefix,suffix);
   }
   
  template &lt;class T&gt;
  PtrLen&lt;T&gt; cutPrefix(PtrLen&lt;T&gt; range) const // assume check(range.len)
   {
    return range.prefix(prefix);
   }
   
  template &lt;class T&gt;
  PtrLen&lt;T&gt; cutSuffix(PtrLen&lt;T&gt; range) const // assume check(range.len)
   {
    return range.suffix(suffix);
   }
   
  template &lt;class T&gt; 
  struct CutResult
   {
    PtrLen&lt;T&gt; range;
    LenStatus status;
    
    CutResult(PtrLen&lt;T&gt; range_,LenStatus status_) : range(range_),status(status_) {}
    
    LenStatus operator ! () const { return status==Len_too_short; } 
   }; 
   
  template &lt;class T&gt;
  CutResult&lt;T&gt; cutMax(PtrLen&lt;T&gt; range) const
   {
    ulen delta=prefix+suffix;
   
    if( range.len&gt;=delta ) 
      {
       ulen len=range.len-delta;
       
       if( len&lt;=max_data ) return CutResult&lt;T&gt;(range.part(prefix,len),Len_ok);
      
       return CutResult&lt;T&gt;(range.part(prefix,max_data),Len_too_long);
      }
    
    return CutResult&lt;T&gt;(Nothing,Len_too_short);
   }
 };
</pre>

</body>

</html>

