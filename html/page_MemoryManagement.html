<!--
/* page_MemoryManagement.html */
//----------------------------------------------------------------------------------------
//
//  Project: CCore 1.02
//
//  License: Boost Software License - Version 1.0 - August 17th, 2003 
//
//            see http://www.boost.org/LICENSE_1_0.txt or the local copy
//
//  Copyright (c) 2012 Sergey Strukov. All rights reserved.
//
//----------------------------------------------------------------------------------------
-->

<!DOCTYPE html>
<html>

<head>

 <title>CCore -> Memory Management</title>

 <link href="CCore.css" rel="stylesheet" type="text/css">

</head>

<body>

<h2>Memory Management</h2>

<h3>Basic of the memory management in <b>CCore</b></h3>

<p class="Files">Files <b>CCore/inc/MemBase.h</b> <b>CCore/src/MemBase_general.cpp</b> <b>HCore/CCore/src/MemBase.cpp</b> <b>XCore/CCore/src/MemBase.cpp</b></p>

<p class="Files">Files <b>CCore/inc/RadixHeap.h</b> <b>CCore/src/RadixHeap.cpp</b></p>

<p class="Files">Files <b>CCore/inc/HeapEngine.h</b> <b>CCore/src/HeapEngine.cpp</b></p>

<p>
<b>CCore</b> uses its own memory management subsystem. We don't rely on the standard <b>malloc/free</b> or <b>new/delete</b>, 
provided by the C++ compiler support libraries. In fact, in <b>XCore</b> targets it is recommended to build these libraries 
based on <b>CCore</b> memory allocation functions. This is because we need much more from the heap, namely:
</p>

<ul>
<li>additional memory functions, like <b>MemExtend()</b> or <b>MemShrink()</b>,</li>
<li>accounting functions to watch the memory usage,</li>
<li>some protection from invalid arguments,</li>
<li>speed!, more speed!,</li>
<li>for <b>XCore</b> we need several heaps for the interrupt context and for special memory regions.</li>
</ul>

<p>
The heart of <b>CCore</b> heaps is the class <b>RadixHeap</b>. This class implements a radix-tree based heap atop on
a primary memory management facility. The heap is maintained in the one or several large blocks of memory, obtained dynamically
from the OS, or fixed in the memory. <b>RadixHeap</b> is the real-time heap. Its operations has a time excecution limit, assuming
there is no primary memory management functions calls. In practise, the cost of allocation and deallocation memory functions
is a 100s CPU clocks. This heap is also best-fit and provides a protection from wrong memory block address arguments.
If you try to free a memory at an arbitary address, then it's very likely the abort will be called.
</p>

<p>
<b>CCore</b> heap is a global object, maintained by the <a href="page_PlanInit.html"><b>PlanInit</b></a> and derived from 
the <b>HeapEngine</b> class, which implements the top-level logic over the <b>RadixHeap</b> functionality.
Been a general purpose global object, <b>CCore</b> heap is a Mutex-protected. In <b>HCore</b> primary large blocks of memory
are obtained from the OS. In <b>XCore</b> it is a single fixed block of memory, provided by the Target.
</p>

<h3>MemBase</h3>

<p>
Here is the basic memory function list from <b>MemBase.h</b>:
</p>

<pre>

/* words */ 

enum <span class="att">JustTryType</span> { <span class="att">JustTry</span> };
 
/* functions */ 

void <span class="att">GuardNoMem</span>(ulen len);

/* Mem...() */  
 
void * <span class="att">TryMemAlloc</span>(ulen len) noexcept;

void * <span class="att">MemAlloc</span>(ulen len);

ulen <span class="att">MemLen</span>(const void *mem);       // mem may == 0

bool <span class="att">MemExtend</span>(void *mem,ulen len); // mem may == 0

bool <span class="att">MemShrink</span>(void *mem,ulen len); // mem may == 0
 
void <span class="att">MemFree</span>(void *mem);            // mem may == 0

void <span class="att">MemLim</span>(ulen limit);

</pre>

<p>
<b>MemAlloc()</b> allocates a memory block of required length and returns its address. The block is always <b>MaxAlign</b>ed,
the actual length can be a slightly greater than the required and always non-null. If the operation is failed, then an exception 
is thrown. The exception class is derived from the <b>std::bad_alloc</b> as required by the C++ standard, but it is also derived
from the <b>CatchType</b>, according <b>CCore</b> rules.
</p>

<p>
<b>TryMemAlloc()</b> is similar, but in case of failure it just returns null.
</p>

<p>
<b>MemLim()</b> setup the global allocation limit. If the argument is null, then there is no limit. If it is not null,
heap will keep the total allocated memory length below this limit (approximately). This feature is useful for testing purpose, 
it helps reproduce the situation of the memory shortage.
</p>

<p>
In the remaining four functions the argument <b>mem</b> must be either an address of the allocated memory block or null.
Otherwise the memory heap protection abort is called (with high probability, the detection is not 100%).
</p>

<p>
<b>MemFree()</b> releases the allocated memory block.
</p>

<p>
<b>MemExtend()</b> tries to extend the allocated memory block. If successful, it returns true and the new length 
of the block is at least <b>len</b>. If the <b>mem</b> is null, the function does nothing and returns false.
<b>MemExtend()</b> is always successful, if <b>len</b> is not greater than the length of the memory block, 
in this case it does nothing. If additional space is required, then <b>MemExtend()</b> is looking for the space
above the block. If enough such space is free, it resizes both memory blocks. Otherwise it fails.
</p>

<p>
<b>MemShrink()</b> shrinks the allocated memory block. If successful, it returns true and the new length 
of the block is at least <b>len</b>. If the <b>mem</b> is null, the function does nothing and returns false.
<b>MemShrink()</b> fails only if the <b>len</b> is greater than the length of the memory block.
</p>

<p>
<b>MemLen()</b> returns the actual length of the allocated memory block or 0 for the null <b>mem</b>.
</p>

<p>
<b>GuardNoMem()</b> throw an exception, it is used when no memory error happens. 
</p>

<p>
<b>JustTry</b> is a <b>word</b>. It is used to distinguish between throwing and non-throwing variants of some operation.
</p>

<p>
<b>MemStatData</b> is a simple <b>Small Data Type</b>, used to represent a memory allocation statistics. It has two
field: <b>block_count</b> &mdash; the number of allocated blocks, and <b>len_count</b> &mdash; the total length of blocks.
It has number of methods with obvious meaning. The method <b>setMax()</b> replaces the current object with the given argument,
if the argument has a greater <b>len_count</b>. It is used to accumulate a "peak" stat value.
</p>

<pre>
struct <span class="att">MemStatData</span>
 {
  ulen block_count;
  ulen len_count;
  
  MemStatData();
  
  // count
  
  void add(ulen len) { block_count++; len_count+=len; }
  
  void del(ulen len) { block_count--; len_count-=len; }
  
  void extend(ulen delta) { len_count+=delta; }
  
  void shrink(ulen delta) { len_count-=delta; }
  
  // set
  
  void set(const MemStatData &amp;obj) { *this=obj; }
  
  void setMax(const MemStatData &amp;obj);
  
  // compare
  
  bool operator == (const MemStatData &amp;obj) const; 
  
  bool operator != (const MemStatData &amp;obj) const; 
  
  // print object
   
  template &lt;class P&gt;
  void print(P &amp;out) const;
 };
</pre>

<p>
To get a heap statistic information there are two <b>Class-function</b>s:
</p>

<pre>

/* struct MemStat */  

struct <span class="att">MemStat</span> : MemStatData
 {
  MemStat();
 };
 
/* struct MemPeak */ 

struct <span class="att">MemPeak</span> : MemStatData
 {
  MemPeak();
 };
 
</pre>

<p>
<b>MemStat</b> returns the current heap usage, while <b>MemPeak</b> &mdash; the peak usage.
</p>

<h3>MemBase utilities</h3>

<p>
<b>MemScope</b> is a <b>Scope Lock Type</b>, which controls memory release during some scope of execution.
In constructor it records the current heap statistic, in destructor it retrieves it again and compares. If they doesn't
match, a error message is printed using <b>Printf(NoException,...)</b>.
</p>

<pre>
class <span class="att">MemScope</span> : NoCopy
 {
   MemStat on_init;
   
  public: 
  
   MemScope() {}
   
   ~MemScope();
 };
</pre>

<p>
This class is useful for the checking of memory leaks.
</p>

<p>
Another helpful <b>Property Type</b> class is the <b>MemBase</b>:
</p>

<pre>
struct <span class="att">MemBase</span>
 {
  // placement new/delete
  
  void * operator new(std::size_t,Place&lt;void&gt; place) { return place; }
   
  void operator delete(void *,Place&lt;void&gt;) {}
  
  // new/delete
   
  void * operator new(std::size_t len) { return MemAlloc(len); }
  
  void * operator new(std::size_t len,JustTryType) noexcept { return TryMemAlloc(len); }
  
  void operator delete(void *mem) { MemFree(mem); }
  
  // extra space
  
  template &lt;class T&gt;
  static Place&lt;void&gt; ExtraSpace(T *obj) { return PlaceAt(obj)+Align(sizeof (T)); }
  
  void * operator new(std::size_t len,ulen extra,ulen size_of=1) { return MemAlloc(LenOf(extra,size_of,Align(len))); }
  
  void operator delete(void *mem,ulen,ulen) { MemFree(mem); }
 };
</pre>

<p>
This class redefines the <b>new/delete</b> operators to use the <b>CCore</b> heap. Specify this class as the base class to make sure
the derived class objects will be placed in the <b>CCore</b> heap been created by the <b>new</b> operator. 
</p>

<p>
You may also take some additional space after the object, using the overloaded <b>new</b> operator.
<b>extra</b> is the number of parts of <b>size_of</b> length. To retrieve this space use the function <b>ExtraSpace</b>:
</p>

<pre>
template &lt;class T&gt;
struct Header : MemBase_nocopy
 {
  ulen object_count;

  explicit Header(ulen object_count_) : object_count(object_count_) {}

  Place&lt;void&gt; getSpace() { return ExtraSpace(this); }

  static Header * Create(ulen object_count)
   {
    return new(object_count,sizeof (T)) Header(object_count);
   }
 };
</pre>

<p>
<b>MemBase_nocopy</b> is a non-copyable variant of <b>MemBase</b>.
</p>

<h3>MemSpaceHeap</h3>

<p class="Files">Files <b>CCore/inc/MemSpaceHeap.h</b> <b>CCore/src/MemSpaceHeap.cpp</b></p>

<h3><b>HCore</b> MemPageHeap</h3>

<p class="Files">Files <b>HCore/CCore/inc/MemPageHeap.h</b> <b>HCore/CCore/src/MemPageHeap.cpp</b></p>

<h3><b>XCore</b> SpecialMemBase</h3>

<p class="Files">Files <b>XCore/CCore/inc/SpecialMemBase.h</b> <b>XCore/CCore/src/SpecialMemBase.cpp</b></p>

</body>

</html>

